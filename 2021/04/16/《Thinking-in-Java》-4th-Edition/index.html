<!DOCTYPE html>
<html lang="en">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="https://avatars.githubusercontent.com/SuiteLHY">
  <title>《Thinking in Java》（第4版） ← 整理手册 | 夜与花海</title>
  <meta name="author" content="Suite" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Java, 《Thinking in Java》, 计算机科学" />
  
  <meta name="description" content="目录 第1章 面向对象导论  1.1 抽象过程 1.2 每个对象都有一个接口 1.3 每个对象都提供服务 1.4 被隐藏的具体实现 1.5 复用具体实现 1.6 继承 1.6.1 “是一个”与“像是一个”的关系   1.7 伴随多态的可互换对象 1.8 单根继承结构 1.9 容器 1.9.1 参数化类型   1.10 对象的创建和生命周期 1.11 异常处理：错误处理 1.12 并发编程 1.13">
<meta property="og:type" content="article">
<meta property="og:title" content="《Thinking in Java》（第4版） ← 整理手册">
<meta property="og:url" content="https://suitelhy.github.io/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/index.html">
<meta property="og:site_name" content="夜与花海">
<meta property="og:description" content="目录 第1章 面向对象导论  1.1 抽象过程 1.2 每个对象都有一个接口 1.3 每个对象都提供服务 1.4 被隐藏的具体实现 1.5 复用具体实现 1.6 继承 1.6.1 “是一个”与“像是一个”的关系   1.7 伴随多态的可互换对象 1.8 单根继承结构 1.9 容器 1.9.1 参数化类型   1.10 对象的创建和生命周期 1.11 异常处理：错误处理 1.12 并发编程 1.13">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://suitelhy.github.io/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/%E3%80%8AThinking%20in%20Java%E3%80%8B-4th.jpg">
<meta property="article:published_time" content="2021-04-16T18:53:02.000Z">
<meta property="article:modified_time" content="2021-04-22T03:59:20.780Z">
<meta property="article:author" content="Suite">
<meta property="article:tag" content="计算机科学">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="《Thinking in Java》">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://suitelhy.github.io/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/%E3%80%8AThinking%20in%20Java%E3%80%8B-4th.jpg">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <div class="nav-toggle"><a class="kratos-nav-toggle js-kratos-nav-toggle"><i></i></a></div>
            <header id="kratos-header-section">
                <div class="container">
                    <div class="nav-header">
                        <div class="color-logo"><a href="/">夜与花海</a></div>
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/SuiteLHY">本站作者</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/SuiteLHY/SuiteLHY.github.io">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>夜与花海</h2> <br />
                        <span>我写下的——是世界</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        <section class="col-md-8">
    <article>
        <div class="kratos-hentry kratos-post-inner clearfix">
            <header class="kratos-entry-header">
                <h1 class="kratos-entry-title text-center">《Thinking in Java》（第4版） ← 整理手册</h1>
                
                <ul class="kratos-post-meta text-center">
                    <li><i class="fa fa-calendar"></i> 2021-04-16</li>
                    <li><i class="fa fa-user"></i> 作者 Suite</li>
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~30.45K
                        
                        字
                    </li>
                    
                </ul>
            </header>
            <div class="kratos-post-content">
                <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                    本文最后编辑于 <time datetime="1619063960780"></time> 前，其中的内容可能需要更新。
                </div>
                
                    <div class="kratos-post-inner-toc">
                        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">第1章 面向对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Object-oriend-Programming%EF%BC%8COOP%EF%BC%89%E3%80%82"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象程序设计（Object-oriend Programming，OOP）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.1.2.</span> <span class="toc-text">主要特征：封装性、继承性、多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">设计优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="toc-number">2.1.4.</span> <span class="toc-text">设计缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">2.1.5.</span> <span class="toc-text">名词解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">第1章-1 抽象过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-2-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">第1章-2 每个对象都有一个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-3-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.4.</span> <span class="toc-text">第1章-3 每个对象都提供服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-4-%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">第1章-4 被隐藏的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-5-%E5%A4%8D%E7%94%A8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">第1章-5 复用具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.</span> <span class="toc-text">第1章-6 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-1-%E2%80%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E4%B8%8E%E2%80%9C%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.7.1.</span> <span class="toc-text">第1章-6-1 “是一个”与“像是一个”的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-7-%E4%BC%B4%E9%9A%8F%E5%A4%9A%E6%80%81%E7%9A%84%E5%8F%AF%E4%BA%92%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.8.</span> <span class="toc-text">第1章-7 伴随多态的可互换对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-8-%E5%8D%95%E6%A0%B9%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">2.9.</span> <span class="toc-text">第1章-8 单根继承结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.10.</span> <span class="toc-text">第1章-9 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-1-%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.10.1.</span> <span class="toc-text">第1章-9-1 参数化类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.11.</span> <span class="toc-text">第1章-10 对象的创建和生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.12.</span> <span class="toc-text">第1章-11 异常处理：错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">2.13.</span> <span class="toc-text">第1章-12 并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-Java%E4%B8%8EInternet"><span class="toc-number">2.14.</span> <span class="toc-text">第1章-13 Java与Internet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-1-Web%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.14.1.</span> <span class="toc-text">第1章-13-1 Web是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">2.14.2.</span> <span class="toc-text">第1章-13-2 客户端编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">2.14.3.</span> <span class="toc-text">第1章-13-3 服务器端编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">2.15.</span> <span class="toc-text">第1章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">第2章 一切都是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-1-%E7%94%A8%E5%BC%95%E7%94%A8%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">第2章-1 用引用操纵对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-%E5%BF%85%E9%A1%BB%E7%94%B1%E4%BD%A0%E5%88%9B%E5%BB%BA%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E3%80%90%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-number">3.2.</span> <span class="toc-text">第2章-2 必须由你创建所有对象【底层存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-1-%E5%AD%98%E5%82%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E3%80%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">第2章-2-1 存储到什么地方【对象的存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">寄存器。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%EF%BC%88Heap%EF%BC%89%E3%80%82"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">堆栈（Heap）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Stack%EF%BC%89%E3%80%82"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">堆（Stack）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%89%E3%80%82"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">常量存储（常量池）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9ERAM%E5%AD%98%E5%82%A8%E3%80%82"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">非RAM存储。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-2-%E7%89%B9%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">第2章-2-2 特例：基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-3-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">第2章-2-3 Java中的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-3-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.4.</span> <span class="toc-text">第2章-3 永远不需要销毁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">第2章-4 创建新的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-5-%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.6.</span> <span class="toc-text">第2章-5 方法、参数和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.7.</span> <span class="toc-text">第2章-6 构建一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-7-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.8.</span> <span class="toc-text">第2章-7 你的第一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-8-%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E6%A1%A3"><span class="toc-number">3.2.9.</span> <span class="toc-text">第2章-8 注释和嵌入式文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-9-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.2.10.</span> <span class="toc-text">第2章-9 编码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.11.</span> <span class="toc-text">第2章-10 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-11-%E7%BB%83%E4%B9%A0"><span class="toc-number">3.2.12.</span> <span class="toc-text">第2章-11 练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">第3章 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-1-%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">第3章-1 更简单的打印语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-2-%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">第3章-2 使用Java操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-3-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.3.</span> <span class="toc-text">第3章-3 优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-%E8%B5%8B%E5%80%BC"><span class="toc-number">4.4.</span> <span class="toc-text">第3章-4 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84%E5%88%AB%E5%90%8D%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">第3章-4.1 方法调用中的别名问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">第3章-5 算数操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-1-%E4%B8%80%E5%85%83%E5%8A%A0%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.5.1.</span> <span class="toc-text">第3章-5-1 一元加减操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-6-%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F"><span class="toc-number">4.6.</span> <span class="toc-text">第3章-6 自动递增和递减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.7.</span> <span class="toc-text">第3章-7 关系操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-1-%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">4.7.1.</span> <span class="toc-text">第3章-7-1 测试对象的等价性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.8.</span> <span class="toc-text">第3章-8 逻辑操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-1-%E7%9F%AD%E8%B7%AF"><span class="toc-number">4.8.1.</span> <span class="toc-text">第3章-8-1 短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-%E7%9B%B4%E6%8E%A5%E5%B8%B8%E9%87%8F"><span class="toc-number">4.9.</span> <span class="toc-text">第3章-9 直接常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-1-%E6%8C%87%E6%95%B0%E8%AE%B0%E6%95%B0%E6%B3%95"><span class="toc-number">4.9.1.</span> <span class="toc-text">第3章-9-1 指数记数法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-10-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.10.</span> <span class="toc-text">第3章-10 按位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-11-%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.11.</span> <span class="toc-text">第3章-11 移位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-12-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6if-else"><span class="toc-number">4.12.</span> <span class="toc-text">第3章-12 三元操作符if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%92%8C"><span class="toc-number">4.13.</span> <span class="toc-text">第3章-13 字符串操作符+和&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-14-%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">4.14.</span> <span class="toc-text">第3章-14 使用操作符时常犯的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.15.</span> <span class="toc-text">第3章-15 类型转换操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-1-%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5"><span class="toc-number">4.15.1.</span> <span class="toc-text">第3章-15-1 截尾和舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-2-%E6%8F%90%E5%8D%87"><span class="toc-number">4.15.2.</span> <span class="toc-text">第3章-15-2 提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-16-Java%E6%B2%A1%E6%9C%89sizeof"><span class="toc-number">4.16.</span> <span class="toc-text">第3章-16 Java没有sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B0%8F%E7%BB%93"><span class="toc-number">4.17.</span> <span class="toc-text">第3章-17 操作符小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-18-%E6%80%BB%E7%BB%93"><span class="toc-number">4.18.</span> <span class="toc-text">第3章-18 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第4章 控制执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">第5章 初始化与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-1-%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%A1%AE%E4%BF%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">第5章-1 用构造器确保初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-2-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">第5章-2 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">第5章-3 默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.4.</span> <span class="toc-text">第5章-4 this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-1-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">6.4.1.</span> <span class="toc-text">第5章-4-1 在构造器中调用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-2-static%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">第5章-4-2 static的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.5.</span> <span class="toc-text">第5章-5 清理：终结处理和垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.6.</span> <span class="toc-text">第5章-6 成员初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-1-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.6.1.</span> <span class="toc-text">第5章-6-1 指定初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.</span> <span class="toc-text">第5章-7 构造器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.7.1.</span> <span class="toc-text">第5章-7-1 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-2-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.2.</span> <span class="toc-text">第5章-7-2 静态数据的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-3-%E6%98%BE%E5%BC%8F%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.3.</span> <span class="toc-text">第5章-7-3 显式的静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-4-%E9%9D%9E%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.4.</span> <span class="toc-text">第5章-7-4 非静态实例初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.8.</span> <span class="toc-text">第5章-8 数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">6.8.1.</span> <span class="toc-text">第5章-8-1 可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.</span> <span class="toc-text">第5章-9 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enum%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.9.1.</span> <span class="toc-text">第5章-9-1 枚举类（enum）——基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.9.2.</span> <span class="toc-text">第5章-9-2 枚举类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">6.10.</span> <span class="toc-text">第5章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">第6章 访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-%E5%8C%85%EF%BC%9A%E5%BA%93%E5%8D%95%E5%85%83"><span class="toc-number">7.1.</span> <span class="toc-text">第6章-1 包：库单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-1-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">7.1.1.</span> <span class="toc-text">第6章-1-1 代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-2-%E5%88%9B%E5%BB%BA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%8C%85%E5%90%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">第6章-1-2 创建独一无二的包名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-3-%E5%AE%9A%E5%88%B6%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">7.1.3.</span> <span class="toc-text">第6章-1-3 定制工具库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-4-%E7%94%A8import%E6%94%B9%E5%8F%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">7.1.4.</span> <span class="toc-text">第6章-1-4 用import改变行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-5-%E5%AF%B9%E4%BD%BF%E7%94%A8%E5%8C%85%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-number">7.1.5.</span> <span class="toc-text">第6章-1-5 对使用包的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-2-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-number">7.2.</span> <span class="toc-text">第6章-2 Java访问权限修饰词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">第6章-3 接口和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-4-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">7.4.</span> <span class="toc-text">第6章-4 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-5-%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.</span> <span class="toc-text">第6章-5 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">第7章 复用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-1-%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">第7章-1 组合语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">第7章-2 继承语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB"><span class="toc-number">8.2.1.</span> <span class="toc-text">第7章-2-1 初始化基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E7%AC%AC7%E7%AB%A0-2-2-%E9%87%8D%E5%86%99"><span class="toc-number">8.2.2.</span> <span class="toc-text">【拓展】第7章-2-2 重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-3-%E4%BB%A3%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">第7章-3 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.</span> <span class="toc-text">第7章-4 结合使用组合和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-5-%E5%9C%A8%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-number">8.5.</span> <span class="toc-text">第7章-5 在组合与继承之间选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-6-protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.6.</span> <span class="toc-text">第7章-6 protected关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.7.</span> <span class="toc-text">第7章-7 向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.8.</span> <span class="toc-text">第7章-8 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-1-final%E6%95%B0%E6%8D%AE"><span class="toc-number">8.8.1.</span> <span class="toc-text">第7章-8-1 final数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-2-final%E6%96%B9%E6%B3%95"><span class="toc-number">8.8.2.</span> <span class="toc-text">第7章-8-2 final方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-3-final%E7%B1%BB"><span class="toc-number">8.8.3.</span> <span class="toc-text">第7章-8-3 final类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-4-%E6%9C%89%E5%85%B3final%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-number">8.8.4.</span> <span class="toc-text">第7章-8-4 有关final的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.9.</span> <span class="toc-text">第7章-9 初始化类及类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">8.10.</span> <span class="toc-text">第7章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">第8章 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-1-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">第8章-1 再论向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-%E8%BD%AC%E6%9C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">第8章-2 转机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">9.3.</span> <span class="toc-text">第8章-3 构造器和多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-4-%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.4.</span> <span class="toc-text">第8章-4 协变返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.5.</span> <span class="toc-text">第8章-5 用继承进行设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-1-%E7%BA%AF%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8B%93%E5%B1%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">第8章-5-1 纯继承与拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">9.5.2.</span> <span class="toc-text">第8章-5-2 向下转型与运行时类型识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-number">9.6.</span> <span class="toc-text">第8章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">第9章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">第9章-1 抽象类和抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.</span> <span class="toc-text">第9章-2 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-3-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">10.3.</span> <span class="toc-text">第9章-3 完全解耦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-4-Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">10.4.</span> <span class="toc-text">第9章-4 Java中的多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-5-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.5.</span> <span class="toc-text">第9章-5 通过继承来拓展接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-6-%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.6.</span> <span class="toc-text">第9章-6 适配接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-7-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F"><span class="toc-number">10.7.</span> <span class="toc-text">第9章-7 接口中的域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-8-%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.8.</span> <span class="toc-text">第9章-8 嵌套接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-number">10.9.</span> <span class="toc-text">第9章-9 接口与工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">10.10.</span> <span class="toc-text">第9章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">第10章 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-1-%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">第10章-1 创建内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-2-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">第10章-2 链接到外部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-3-%E4%BD%BF%E7%94%A8-this%E4%B8%8E-new"><span class="toc-number">11.3.</span> <span class="toc-text">第10章-3 使用.this与.new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-4-%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">11.4.</span> <span class="toc-text">第10章-4 内部类与向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-5-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.5.</span> <span class="toc-text">第10章-5 在方法和作用域内的内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.6.</span> <span class="toc-text">第10章-6 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-7-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">11.7.</span> <span class="toc-text">第10章-7 嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.8.</span> <span class="toc-text">第10章-8 为什么需要内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-9-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">11.9.</span> <span class="toc-text">第10章-9 内部类的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-10-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A6%86%E7%9B%96%E5%90%97"><span class="toc-number">11.10.</span> <span class="toc-text">第10章-10 内部类可以被覆盖吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-11-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.11.</span> <span class="toc-text">第10章-11 局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-12-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">11.12.</span> <span class="toc-text">第10章-12 内部类标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-13-%E6%80%BB%E7%BB%93"><span class="toc-number">11.13.</span> <span class="toc-text">第10章-13 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">第11章 持有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-1-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">12.1.</span> <span class="toc-text">第11章-1 泛型和类型安全的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">12.2.</span> <span class="toc-text">第11章-2 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">12.3.</span> <span class="toc-text">第11章-3 添加一组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-4-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-number">12.4.</span> <span class="toc-text">第11章-4 容器的打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-5-List%EF%BC%88%E5%8E%9F%E7%90%86-amp-%E7%AE%80%E4%BB%8B%EF%BC%89"><span class="toc-number">12.5.</span> <span class="toc-text">第11章-5 List（原理 &amp; 简介）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-6-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.6.</span> <span class="toc-text">第11章-6 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-7-LinkedList"><span class="toc-number">12.7.</span> <span class="toc-text">第11章-7 LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-8-Stack"><span class="toc-number">12.8.</span> <span class="toc-text">第11章-8 Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-9-Set"><span class="toc-number">12.9.</span> <span class="toc-text">第11章-9 Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-10-Map"><span class="toc-number">12.10.</span> <span class="toc-text">第11章-10 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-11-Queue"><span class="toc-number">12.11.</span> <span class="toc-text">第11章-11 Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-12-Collection%E5%92%8CIterator"><span class="toc-number">12.12.</span> <span class="toc-text">第11章-12 Collection和Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-Foreach%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.13.</span> <span class="toc-text">第11章-13 Foreach与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%96%B9%E6%B3%95%E6%83%AF%E7%94%A8%E6%B3%95%E2%86%92%E7%A4%BA%E4%BE%8B%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">12.13.1.</span> <span class="toc-text">第11章-13-1 适配器方法惯用法→示例源码说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">12.14.</span> <span class="toc-text">第11章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">13.</span> <span class="toc-text">第12章 通过异常处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">13.1.</span> <span class="toc-text">第12章-1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-number">13.2.</span> <span class="toc-text">第12章-2 基本异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-1-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%8F%82%E6%95%B0"><span class="toc-number">13.2.1.</span> <span class="toc-text">第12章-2-1 捕获异常参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">13.3.</span> <span class="toc-text">第12章-3 捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-1-try%E5%9D%97"><span class="toc-number">13.3.1.</span> <span class="toc-text">第12章-3-1 try块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">13.3.2.</span> <span class="toc-text">第12章-3-2 异常处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">13.4.</span> <span class="toc-text">第12章-4 创建自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-1-%E5%BC%82%E5%B8%B8%E4%B8%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">13.4.1.</span> <span class="toc-text">第12章-4-1 异常与记录日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-5-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">13.5.</span> <span class="toc-text">第12章-5 异常说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-number">13.6.</span> <span class="toc-text">第12章-6 捕获所有异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-1-%E6%A0%88%E8%BD%A8%E8%BF%B9"><span class="toc-number">13.6.1.</span> <span class="toc-text">第12章-6-1 栈轨迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-2-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">13.6.2.</span> <span class="toc-text">第12章-6-2 重新抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-3-%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-number">13.6.3.</span> <span class="toc-text">第12章-6-3 异常链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-Java%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">13.7.</span> <span class="toc-text">第12章-7 Java标准异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-1-%E7%89%B9%E4%BE%8B%EF%BC%9ARuntimeException"><span class="toc-number">13.7.1.</span> <span class="toc-text">第12章-7-1 特例：RuntimeException</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-%E4%BD%BF%E7%94%A8finally%E8%BF%9B%E8%A1%8C%E6%B8%85%E7%90%86"><span class="toc-number">13.8.</span> <span class="toc-text">第12章-8 使用finally进行清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-1-finally%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">13.8.1.</span> <span class="toc-text">第12章-8-1 finally用来做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-2-%E5%9C%A8return%E4%B8%AD%E4%BD%BF%E7%94%A8finally"><span class="toc-number">13.8.2.</span> <span class="toc-text">第12章-8-2 在return中使用finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-3-%E7%BC%BA%E6%86%BE%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BC%BA%E5%A4%B1"><span class="toc-number">13.8.3.</span> <span class="toc-text">第12章-8-3 缺憾：异常缺失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-9-%E5%BC%82%E5%B8%B8%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">13.9.</span> <span class="toc-text">第12章-9 异常的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-10-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">13.10.</span> <span class="toc-text">第12章-10 构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%8C%B9%E9%85%8D"><span class="toc-number">13.11.</span> <span class="toc-text">第12章-11 异常匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89%E6%96%B9%E5%BC%8F"><span class="toc-number">13.12.</span> <span class="toc-text">第12章-12 其他可选方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-1-%E5%8E%86%E5%8F%B2"><span class="toc-number">13.12.1.</span> <span class="toc-text">第12章-12-1 历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-2-%E8%A7%82%E7%82%B9"><span class="toc-number">13.12.2.</span> <span class="toc-text">第12章-12-2 观点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-3-%E6%8A%8A%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92%E7%BB%99%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">13.12.3.</span> <span class="toc-text">第12章-12-3 把异常传递给控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-4-%E6%8A%8A%E2%80%9C%E8%A2%AB%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E2%80%9C%E4%B8%8D%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D"><span class="toc-number">13.12.4.</span> <span class="toc-text">第12章-12-4 把“被检查的异常”转换为“不检查的异常”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-13-%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-number">13.13.</span> <span class="toc-text">第12章-13 异常使用指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">13.14.</span> <span class="toc-text">第12章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">14.</span> <span class="toc-text">第13章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-1-%E4%B8%8D%E5%8F%AF%E5%8F%98String"><span class="toc-number">14.1.</span> <span class="toc-text">第13章-1 不可变String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-2-%E9%87%8D%E8%BD%BD%E2%80%9C-%E2%80%9D%E4%B8%8EStringBuilder"><span class="toc-number">14.2.</span> <span class="toc-text">第13章-2 重载“+”与StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-3-%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">14.3.</span> <span class="toc-text">第13章-3 无意识的递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-4-String%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">14.4.</span> <span class="toc-text">第13章-4 String上的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">14.5.</span> <span class="toc-text">第13章-5 格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">14.5.1.</span> <span class="toc-text">第13章-5-4 格式化说明符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.6.</span> <span class="toc-text">第13章-6 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-7-%E6%89%AB%E6%8F%8F%E8%BE%93%E5%85%A5"><span class="toc-number">14.7.</span> <span class="toc-text">第13章-7 扫描输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-8-StringTokenizer%EF%BC%88%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="toc-number">14.8.</span> <span class="toc-text">第13章-8 StringTokenizer（已废弃）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-9-%E6%80%BB%E7%BB%93"><span class="toc-number">14.9.</span> <span class="toc-text">第13章-9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%88RTTI%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">第14章 类型信息（RTTI）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81RTTI"><span class="toc-number">15.1.</span> <span class="toc-text">第14章-1 为什么需要RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.2.</span> <span class="toc-text">第14章-2 Class对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-1-%E7%B1%BB%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">15.2.1.</span> <span class="toc-text">第14章-2-1 类字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-2-%E6%B3%9B%E5%8C%96%E7%9A%84Class%E5%BC%95%E7%94%A8"><span class="toc-number">15.2.2.</span> <span class="toc-text">第14章-2-2 泛化的Class引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-3-%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%8E%9F%EF%BC%9A%E6%96%B0%E7%9A%84%E8%BD%AC%E5%9E%8B%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-number">15.2.3.</span> <span class="toc-text">第14章-2-3 类的转换（原：新的转型语法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%8D%E5%85%88%E5%81%9A%E6%A3%80%E6%9F%A5"><span class="toc-number">15.3.</span> <span class="toc-text">第14章-3 类型转换前先做检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-4-%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82"><span class="toc-number">15.4.</span> <span class="toc-text">第14章-4 注册工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-5-instanceof%E4%B8%8EClass%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">15.5.</span> <span class="toc-text">第14章-5 instanceof与Class的等价性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-%E5%8F%8D%E5%B0%84%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">15.6.</span> <span class="toc-text">第14章-6 反射：运行时的类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-1-%E7%B1%BB%E6%96%B9%E6%B3%95%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-number">15.6.1.</span> <span class="toc-text">第14章-6-1 类方法提取器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-7-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">15.7.</span> <span class="toc-text">第14章-7 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.8.</span> <span class="toc-text">第14章-8 空对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-1-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A1%A9"><span class="toc-number">15.8.1.</span> <span class="toc-text">第14章-8-1 模拟对象与桩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">15.9.</span> <span class="toc-text">第14章-9 接口与类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">15.10.</span> <span class="toc-text">第14章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">第15章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-1-%E4%B8%8EC-%E6%AF%94%E8%BE%83"><span class="toc-number">16.1.</span> <span class="toc-text">第15章-1 与C++比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.2.</span> <span class="toc-text">第15章-2 简单泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-1-%E4%B8%80%E4%B8%AA%E5%85%83%E7%A5%96%E7%B1%BB%E5%BA%93"><span class="toc-number">16.2.1.</span> <span class="toc-text">第15章-2-1 一个元祖类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-2-%E4%B8%80%E4%B8%AA%E5%A0%86%E6%A0%88%E7%B1%BB"><span class="toc-number">16.2.2.</span> <span class="toc-text">第15章-2-2 一个堆栈类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-3-RandomList"><span class="toc-number">16.2.3.</span> <span class="toc-text">第15章-2-3 RandomList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-3-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.3.</span> <span class="toc-text">第15章-3 泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.</span> <span class="toc-text">第15章-4 泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-1-%E6%9D%A0%E6%9D%86%E5%88%A9%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%88%A4%E6%96%AD"><span class="toc-number">16.4.1.</span> <span class="toc-text">第15章-4-1 杠杆利用类型参数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.2.</span> <span class="toc-text">第15章-4-2 可变参数与泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-3-%E7%94%A8%E4%BA%8EGenerator%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.3.</span> <span class="toc-text">第15章-4-3 用于Generator的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-4-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Generator"><span class="toc-number">16.4.4.</span> <span class="toc-text">第15章-4-4 一个通用的Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-5-%E7%AE%80%E5%8C%96%E5%85%83%E7%A5%96%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.4.5.</span> <span class="toc-text">第15章-4-5 简化元祖的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-6-%E4%B8%80%E4%B8%AASet%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">16.4.6.</span> <span class="toc-text">第15章-4-6 一个Set实用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">16.5.</span> <span class="toc-text">第15章-5 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">16.6.</span> <span class="toc-text">第15章-6 构建复杂模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-%E6%93%A6%E9%99%A4%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-number">16.7.</span> <span class="toc-text">第15章-7 擦除的神秘之处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-1-C-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">16.7.1.</span> <span class="toc-text">第15章-7-1 C++的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-2-%E8%BF%81%E7%A7%BB%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">16.7.2.</span> <span class="toc-text">第15章-7-2 迁移兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-3-%E6%93%A6%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">16.7.3.</span> <span class="toc-text">第15章-7-3 擦除的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-4-%E8%BE%B9%E7%95%8C%E5%A4%84%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-number">16.7.4.</span> <span class="toc-text">第15章-7-4 边界处的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-%E6%93%A6%E9%99%A4%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">16.8.</span> <span class="toc-text">第15章-8 擦除的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-1-%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="toc-number">16.8.1.</span> <span class="toc-text">第15章-8-1 创建类型实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-2-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">16.8.2.</span> <span class="toc-text">第15章-8-2 泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-9-%E8%BE%B9%E7%95%8C"><span class="toc-number">16.9.</span> <span class="toc-text">第15章-9 边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">16.10.</span> <span class="toc-text">第15章-10 通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-1-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E5%A4%9A%E8%81%AA%E6%98%8E"><span class="toc-number">16.10.1.</span> <span class="toc-text">第15章-10-1 编译器有多聪明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-2-%E9%80%86%E5%8F%98"><span class="toc-number">16.10.2.</span> <span class="toc-text">第15章-10-2 逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-3-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">16.10.3.</span> <span class="toc-text">第15章-10-3 无界通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-4-%E6%8D%95%E8%8E%B7%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7%EF%BC%89"><span class="toc-number">16.10.4.</span> <span class="toc-text">第15章-10-4 捕获转换（通配符捕获）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-%E9%97%AE%E9%A2%98"><span class="toc-number">16.11.</span> <span class="toc-text">第15章-11 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-1-%E4%BB%BB%E4%BD%95%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E9%83%BD%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.11.1.</span> <span class="toc-text">第15章-11-1 任何基本类型都不能作为类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-2-%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.11.2.</span> <span class="toc-text">第15章-11-2 实现参数化接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-3-%E8%BD%AC%E5%9E%8B%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="toc-number">16.11.3.</span> <span class="toc-text">第15章-11-3 转型和警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-4-%E9%87%8D%E8%BD%BD"><span class="toc-number">16.11.4.</span> <span class="toc-text">第15章-11-4 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-5-%E5%9F%BA%E7%B1%BB%E5%8A%AB%E6%8C%81%E4%BA%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.11.5.</span> <span class="toc-text">第15章-11-5 基类劫持了接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-%E8%87%AA%E9%99%90%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.12.</span> <span class="toc-text">第15章-12 自限定的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-1-%E5%8F%A4%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.12.1.</span> <span class="toc-text">第15章-12-1 古怪的循环泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-2-%E8%87%AA%E9%99%90%E5%AE%9A"><span class="toc-number">16.12.2.</span> <span class="toc-text">第15章-12-2 自限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-3-%E5%8F%82%E6%95%B0%E5%8D%8F%E5%8F%98"><span class="toc-number">16.12.3.</span> <span class="toc-text">第15章-12-3 参数协变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-13-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">16.13.</span> <span class="toc-text">第15章-13 动态类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-14-%E5%BC%82%E5%B8%B8"><span class="toc-number">16.14.</span> <span class="toc-text">第15章-14 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-%E6%B7%B7%E5%9E%8B"><span class="toc-number">16.15.</span> <span class="toc-text">第15章-15 混型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-1-C-%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%9E%8B"><span class="toc-number">16.15.1.</span> <span class="toc-text">第15章-15-1 C++中的混型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-2-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B7%E5%90%88"><span class="toc-number">16.15.2.</span> <span class="toc-text">第15章-15-2 与接口混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-3-%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.15.3.</span> <span class="toc-text">第15章-15-3 使用装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-4-%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%B7%B7%E5%90%88"><span class="toc-number">16.15.4.</span> <span class="toc-text">第15章-15-4 与动态代理混合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-16-%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">16.16.</span> <span class="toc-text">第15章-16 潜在类型机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-%E5%AF%B9%E7%BC%BA%E4%B9%8F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">16.17.</span> <span class="toc-text">第15章-17 对缺乏潜在类型机制的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-1-%E5%8F%8D%E5%B0%84"><span class="toc-number">16.17.1.</span> <span class="toc-text">第15章-17-1 反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-2-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E4%BA%8E%E5%BA%8F%E5%88%97"><span class="toc-number">16.17.2.</span> <span class="toc-text">第15章-17-2 将一个方法应用于序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-3-%E5%BD%93%E4%BD%A0%E5%B9%B6%E4%B8%BA%E7%A2%B0%E5%B7%A7%E6%8B%A5%E6%9C%89%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6"><span class="toc-number">16.17.3.</span> <span class="toc-text">第15章-17-3 当你并为碰巧拥有正确的接口时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-4-%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%BB%BF%E7%9C%9F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">16.17.4.</span> <span class="toc-text">第15章-17-4 用适配器仿真潜在类型机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-18-%E5%B0%86%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="toc-number">16.18.</span> <span class="toc-text">第15章-18 将函数对象用作策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-%E6%80%BB%E7%BB%93%EF%BC%9A%E8%BD%AC%E5%9E%8B%E7%9C%9F%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%B3%9F%E5%90%97%EF%BC%9F"><span class="toc-number">16.19.</span> <span class="toc-text">第15章-19 总结：转型真的如此之糟吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-1-%E8%BF%9B%E9%98%B6%E8%AF%BB%E7%89%A9"><span class="toc-number">16.19.1.</span> <span class="toc-text">第15章-19-1 进阶读物</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">17.</span> <span class="toc-text">第16章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-1-%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E6%AE%8A"><span class="toc-number">17.1.</span> <span class="toc-text">第16章-1 数组为什么特殊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-2-%E6%95%B0%E7%BB%84%E6%98%AF%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.2.</span> <span class="toc-text">第16章-2 数组是第一级对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-3-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">17.3.</span> <span class="toc-text">第16章-3 返回一个数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">17.4.</span> <span class="toc-text">第16章-4 多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-5-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">17.5.</span> <span class="toc-text">第16章-5 数组与泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">17.6.</span> <span class="toc-text">第16章-6 创建测试数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-1-Arrays-fill"><span class="toc-number">17.6.1.</span> <span class="toc-text">第16章-6-1 Arrays.fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-2-%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">17.6.2.</span> <span class="toc-text">第16章-6-2 数据生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-3-%E4%BB%8EGenerator%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">17.6.3.</span> <span class="toc-text">第16章-6-3 从Generator中创建数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-Arrays%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">17.7.</span> <span class="toc-text">第16章-7 Arrays实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-1-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-number">17.7.1.</span> <span class="toc-text">第16章-7-1 复制数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-2-%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">17.7.2.</span> <span class="toc-text">第16章-7-2 数组的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-3-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">17.7.3.</span> <span class="toc-text">第16章-7-3 数组元素的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-4-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">17.7.4.</span> <span class="toc-text">第16章-7-4 数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-5-%E5%9C%A8%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">17.7.5.</span> <span class="toc-text">第16章-7-5 在已排序的数组中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-8-%E6%80%BB%E7%BB%93"><span class="toc-number">17.8.</span> <span class="toc-text">第16章-8 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="toc-number">18.</span> <span class="toc-text">第17章 容器深入研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-1-%E5%AE%8C%E6%95%B4%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-number">18.1.</span> <span class="toc-text">第17章-1 完整容器分类法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-%E5%A1%AB%E5%85%85%E5%AE%B9%E5%99%A8"><span class="toc-number">18.2.</span> <span class="toc-text">第17章-2 填充容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-1-%E4%B8%80%E7%A7%8DGenerator%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">18.2.1.</span> <span class="toc-text">第17章-2-1 一种Generator解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-2-Map%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">18.2.2.</span> <span class="toc-text">第17章-2-2 Map生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-3-%E4%BD%BF%E7%94%A8Abstract%E7%B1%BB"><span class="toc-number">18.2.3.</span> <span class="toc-text">第17章-2-3 使用Abstract类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-3-Collection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">18.3.</span> <span class="toc-text">第17章-3 Collection的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C"><span class="toc-number">18.4.</span> <span class="toc-text">第17章-4 可选操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-1-%E6%9C%AA%E8%8E%B7%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">18.4.1.</span> <span class="toc-text">第17章-4-1 未获支持的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-5-List%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.</span> <span class="toc-text">第17章-5 List的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-Set%E5%92%8C%E5%AD%98%E5%82%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">18.6.</span> <span class="toc-text">第17章-6 Set和存储排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-1-SortedSet"><span class="toc-number">18.6.1.</span> <span class="toc-text">第17章-6-1 SortedSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-%E9%98%9F%E5%88%97"><span class="toc-number">18.7.</span> <span class="toc-text">第17章-7 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-1-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">18.7.1.</span> <span class="toc-text">第17章-7-1 优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-2-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-number">18.7.2.</span> <span class="toc-text">第17章-7-2 双向队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-%E7%90%86%E8%A7%A3Map"><span class="toc-number">18.8.</span> <span class="toc-text">第17章-8 理解Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-1-%E6%80%A7%E8%83%BD"><span class="toc-number">18.8.1.</span> <span class="toc-text">第17章-8-1 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-2-SortedMap"><span class="toc-number">18.8.2.</span> <span class="toc-text">第17章-8-2 SortedMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-3-LinkedHashMap"><span class="toc-number">18.8.3.</span> <span class="toc-text">第17章-8-3 LinkedHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-%E6%95%A3%E5%88%97%E4%B8%8E%E6%95%A3%E5%88%97%E7%A0%81"><span class="toc-number">18.9.</span> <span class="toc-text">第17章-9 散列与散列码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-1-%E7%90%86%E8%A7%A3hashCode"><span class="toc-number">18.9.1.</span> <span class="toc-text">第17章-9-1 理解hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-2-%E4%B8%BA%E9%80%9F%E5%BA%A6%E8%80%8C%E6%95%A3%E5%88%97"><span class="toc-number">18.9.2.</span> <span class="toc-text">第17章-9-2 为速度而散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-3-%E8%A6%86%E7%9B%96hashCode"><span class="toc-number">18.9.3.</span> <span class="toc-text">第17章-9-3 覆盖hashCode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.10.</span> <span class="toc-text">第17章-10 选择接口的不同实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-1-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">18.10.1.</span> <span class="toc-text">第17章-10-1 性能测试框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-2-%E5%AF%B9List%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">18.10.2.</span> <span class="toc-text">第17章-10-2 对List的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-3-%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-number">18.10.3.</span> <span class="toc-text">第17章-10-3 微基准测试的危险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-4-%E5%AF%B9Set%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">18.10.4.</span> <span class="toc-text">第17章-10-4 对Set的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-5-%E5%AF%B9Map%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">18.10.5.</span> <span class="toc-text">第17章-10-5 对Map的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.11.</span> <span class="toc-text">第17章-11 实用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-1-List%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">18.11.1.</span> <span class="toc-text">第17章-11.1 List的排序和查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-2-%E8%AE%BE%E5%AE%9ACollection%E6%88%96Map%E4%B8%BA%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-number">18.11.2.</span> <span class="toc-text">第17章-11.2 设定Collection或Map为不可修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-3-Collection%E6%88%96Map%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">18.11.3.</span> <span class="toc-text">第17章-11.3 Collection或Map的同步控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-%E6%8C%81%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-number">18.12.</span> <span class="toc-text">第17章-12 持有引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-1-WeakHashMap"><span class="toc-number">18.12.1.</span> <span class="toc-text">第17章-12.1 WeakHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-Java-1-0-1-1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">18.13.</span> <span class="toc-text">第17章-13 Java 1.0-1.1的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-1-Vector%E5%92%8CEnumeration"><span class="toc-number">18.13.1.</span> <span class="toc-text">第17章-13.1 Vector和Enumeration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-2-Hashtable"><span class="toc-number">18.13.2.</span> <span class="toc-text">第17章-13.2 Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-3-Stack"><span class="toc-number">18.13.3.</span> <span class="toc-text">第17章-13.3 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-4-BitSet"><span class="toc-number">18.13.4.</span> <span class="toc-text">第17章-13.4 BitSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">18.14.</span> <span class="toc-text">第17章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.</span> <span class="toc-text">第18章 Java IO系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-File%E7%B1%BB"><span class="toc-number">19.1.</span> <span class="toc-text">第18章-1 File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-1-%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E5%99%A8"><span class="toc-number">19.1.1.</span> <span class="toc-text">第18章-1-1 目录列表器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-2-%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">19.1.2.</span> <span class="toc-text">第18章-1-2 目录实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-3-%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E6%9F%A5%E5%8F%8A%E5%88%9B%E5%BB%BA"><span class="toc-number">19.1.3.</span> <span class="toc-text">第18章-1-3 目录的检查及创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-%E8%BE%93%E5%85%A5%EF%BC%88Input%EF%BC%89%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88Output%EF%BC%89"><span class="toc-number">19.2.</span> <span class="toc-text">第18章-2 输入（Input）和输出（Output）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-1-InputStream%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.2.1.</span> <span class="toc-text">第18章-2-1 InputStream类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-2-OutputStream%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.2.2.</span> <span class="toc-text">第18章-2-2 OutputStream类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">19.3.</span> <span class="toc-text">第18章-3 添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-1-%E9%80%9A%E8%BF%87FilterInputStream%E4%BB%8EInputStream%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">19.3.1.</span> <span class="toc-text">第18章-3-1 通过FilterInputStream从InputStream读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-2-%E9%80%9A%E8%BF%87FilterOutputStream%E4%BB%8EOutputStream%E5%86%99%E5%85%A5"><span class="toc-number">19.3.2.</span> <span class="toc-text">第18章-3-2 通过FilterOutputStream从OutputStream写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-Reader%E5%92%8CWriter"><span class="toc-number">19.4.</span> <span class="toc-text">第18章-4 Reader和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9D%A5%E6%BA%90%E5%92%8C%E5%8E%BB%E5%A4%84%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%89"><span class="toc-number">19.4.1.</span> <span class="toc-text">第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-2-%E6%9B%B4%E6%94%B9%E6%B5%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">19.4.2.</span> <span class="toc-text">第18章-4-2 更改流的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-3-%E6%9C%AA%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E7%B1%BB"><span class="toc-number">19.4.3.</span> <span class="toc-text">第18章-4-3 未发生变化的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-5-%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="toc-number">19.5.</span> <span class="toc-text">第18章-5 自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-IO%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">19.6.</span> <span class="toc-text">第18章-6 IO流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-1-%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">19.6.1.</span> <span class="toc-text">第18章-6-1 缓冲输入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-2-%E4%BB%8E%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-number">19.6.2.</span> <span class="toc-text">第18章-6-2 从内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-number">19.6.3.</span> <span class="toc-text">第18章-6-3 格式化的内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">19.6.4.</span> <span class="toc-text">第18章-6-4 基本的文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-5-%E5%AD%98%E5%82%A8%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">19.6.5.</span> <span class="toc-text">第18章-6-5 存储和恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-6-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">19.6.6.</span> <span class="toc-text">第18章-6-6 随机读写访问文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-7-%E7%AE%A1%E9%81%93%E6%B5%81"><span class="toc-number">19.6.7.</span> <span class="toc-text">第18章-6-7 管道流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">19.7.</span> <span class="toc-text">第18章-7 文件读写的实用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-1-%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">19.7.1.</span> <span class="toc-text">第18章-7-1 读取二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-%E6%A0%87%E5%87%86IO"><span class="toc-number">19.8.</span> <span class="toc-text">第18章-8 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-1-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-number">19.8.1.</span> <span class="toc-text">第18章-8-1 从标准输入中读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-2-%E5%B0%86System-out%E8%BD%AC%E6%8D%A2%E6%88%90PrintWriter"><span class="toc-number">19.8.2.</span> <span class="toc-text">第18章-8-2 将System.out转换成PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-3-%E6%A0%87%E5%87%86IO%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">19.8.3.</span> <span class="toc-text">第18章-8-3 标准IO重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-9-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">19.9.</span> <span class="toc-text">第18章-9 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-%E6%96%B0IO"><span class="toc-number">19.10.</span> <span class="toc-text">第18章-10 新IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-1-%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">19.10.1.</span> <span class="toc-text">第18章-10-1 转换数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-2-%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.10.2.</span> <span class="toc-text">第18章-10-2 获取基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-3-%E8%A7%86%E5%9B%BE%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-number">19.10.3.</span> <span class="toc-text">第18章-10-3 视图缓冲器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-4-%E7%94%A8%E7%BC%93%E5%86%B2%E5%99%A8%E6%93%8D%E7%BA%B5%E6%95%B0%E6%8D%AE"><span class="toc-number">19.10.4.</span> <span class="toc-text">第18章-10-4 用缓冲器操纵数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-5-%E7%BC%93%E5%86%B2%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">19.10.5.</span> <span class="toc-text">第18章-10-5 缓冲器的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">19.10.6.</span> <span class="toc-text">第18章-10-6 内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-7-%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-number">19.10.7.</span> <span class="toc-text">第18章-10-7 文件加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-%E5%8E%8B%E7%BC%A9"><span class="toc-number">19.11.</span> <span class="toc-text">第18章-11 压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-1-%E7%94%A8GZIP%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%8E%8B%E7%BC%A9"><span class="toc-number">19.11.1.</span> <span class="toc-text">第18章-11-1 用GZIP进行简单压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-2-%E7%94%A8Zip%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98"><span class="toc-number">19.11.2.</span> <span class="toc-text">第18章-11-2 用Zip进行多文件保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-3-Java%E6%A1%A3%E6%A1%88%E6%96%87%E4%BB%B6"><span class="toc-number">19.11.3.</span> <span class="toc-text">第18章-11-3 Java档案文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">19.12.</span> <span class="toc-text">第18章-12 对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-1-%E5%AF%BB%E6%89%BE%E7%B1%BB"><span class="toc-number">19.12.1.</span> <span class="toc-text">第18章-12-1 寻找类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-2-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">19.12.2.</span> <span class="toc-text">第18章-12-2 序列化的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-3-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%8C%81%E4%B9%85%E6%80%A7%E2%80%9D"><span class="toc-number">19.12.3.</span> <span class="toc-text">第18章-12-3 使用“持久性”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-13-XML"><span class="toc-number">19.13.</span> <span class="toc-text">第18章-13 XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-14-Preferences"><span class="toc-number">19.14.</span> <span class="toc-text">第18章-14 Preferences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-15-%E6%80%BB%E7%BB%93"><span class="toc-number">19.15.</span> <span class="toc-text">第18章-15 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.</span> <span class="toc-text">第19章 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-%E5%9F%BA%E6%9C%ACenum%E7%89%B9%E6%80%A7"><span class="toc-number">20.1.</span> <span class="toc-text">第19章-1 基本enum特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-1-%E5%B0%86%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E7%94%A8%E4%BA%8Eenum"><span class="toc-number">20.1.1.</span> <span class="toc-text">第19章-1-1 将静态导入用于enum</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-%E5%90%91enum%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">20.2.</span> <span class="toc-text">第19章-2 向enum中添加新方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-1-%E8%A6%86%E7%9B%96enum%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">20.2.1.</span> <span class="toc-text">第19章-2-1 覆盖enum的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-3-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84enum"><span class="toc-number">20.3.</span> <span class="toc-text">第19章-3 switch语句中的enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-4-values-%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-number">20.4.</span> <span class="toc-text">第19章-4 values()的神秘之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-5-%E5%AE%9E%E7%8E%B0%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-number">20.5.</span> <span class="toc-text">第19章-5 实现而非继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-6-%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96"><span class="toc-number">20.6.</span> <span class="toc-text">第19章-6 随机选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-7-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE"><span class="toc-number">20.7.</span> <span class="toc-text">第19章-7 使用接口组织枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-8-%E4%BD%BF%E7%94%A8EnumSet%E6%9B%BF%E4%BB%A3%E6%A0%87%E5%BF%97"><span class="toc-number">20.8.</span> <span class="toc-text">第19章-8 使用EnumSet替代标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-9-%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-number">20.9.</span> <span class="toc-text">第19章-9 使用EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">20.10.</span> <span class="toc-text">第19章-10 常量相关的方法（枚举类的抽象方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-1-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE"><span class="toc-number">20.10.1.</span> <span class="toc-text">第19章-10-1 使用enum的职责链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-2-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">20.10.2.</span> <span class="toc-text">第19章-10-2 使用enum的状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91"><span class="toc-number">20.11.</span> <span class="toc-text">第19章-11 多路分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-1-%E4%BD%BF%E7%94%A8enum%E5%88%86%E5%8F%91"><span class="toc-number">20.11.1.</span> <span class="toc-text">第19章-11-1 使用enum分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-2-%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">20.11.2.</span> <span class="toc-text">第19章-11-2 使用常量相关的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-3-%E4%BD%BF%E7%94%A8EnumMap%E5%88%86%E5%8F%91"><span class="toc-number">20.11.3.</span> <span class="toc-text">第19章-11-3 使用EnumMap分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-4-%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">20.11.4.</span> <span class="toc-text">第19章-11-4 使用二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-12-%E6%80%BB%E7%BB%93"><span class="toc-number">20.12.</span> <span class="toc-text">第19章-12 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.</span> <span class="toc-text">第20章 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">21.1.</span> <span class="toc-text">第20章-1 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-1-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.1.1.</span> <span class="toc-text">第20章-1-1 定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-2-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.1.2.</span> <span class="toc-text">第20章-1-2 元注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-%E7%BC%96%E5%86%99%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">21.2.</span> <span class="toc-text">第20章-2 编写注解处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-1-%E6%B3%A8%E8%A7%A3%E5%85%83%E7%B4%A0"><span class="toc-number">21.2.1.</span> <span class="toc-text">第20章-2-1 注解元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-2-%E9%BB%98%E8%AE%A4%E5%80%BC%E9%99%90%E5%88%B6"><span class="toc-number">21.2.2.</span> <span class="toc-text">第20章-2-2 默认值限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-3-%E7%94%9F%E6%88%90%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="toc-number">21.2.3.</span> <span class="toc-text">第20章-2-3 生成外部文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-4-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF"><span class="toc-number">21.2.4.</span> <span class="toc-text">第20章-2-4 注解不支持继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-5-%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">21.2.5.</span> <span class="toc-text">第20章-2-5 实现处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-3-%E4%BD%BF%E7%94%A8apt%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.3.</span> <span class="toc-text">第20章-3 使用apt处理注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-4-%E5%B0%86%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BA%8Eapt"><span class="toc-number">21.4.</span> <span class="toc-text">第20章-4 将观察者模式用于apt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">21.5.</span> <span class="toc-text">第20章-5 基于注解的单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-1-%E5%B0%86-Unit%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">21.5.1.</span> <span class="toc-text">第20章-5-1 将@Unit用于泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-2-%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BB%BB%E4%BD%95%E2%80%9C%E5%A5%97%E4%BB%B6%E2%80%9D"><span class="toc-number">21.5.2.</span> <span class="toc-text">第20章-5-2 不需要任何“套件”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-3-%E5%AE%9E%E7%8E%B0-Unit"><span class="toc-number">21.5.3.</span> <span class="toc-text">第20章-5-3 实现@Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-4-%E7%A7%BB%E9%99%A4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">21.5.4.</span> <span class="toc-text">第20章-5-4 移除测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-number">21.6.</span> <span class="toc-text">第20章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-number">22.</span> <span class="toc-text">第21章 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-1-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%80%A7"><span class="toc-number">22.1.</span> <span class="toc-text">第21章-1 并发的多面性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">22.2.</span> <span class="toc-text">第21章-2 基本的线程机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-3-%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90"><span class="toc-number">22.3.</span> <span class="toc-text">第21章-3 共享受限资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-4-%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="toc-number">22.4.</span> <span class="toc-text">第21章-4 终结任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-5-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">22.5.</span> <span class="toc-text">第21章-5 线程之间的协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-6-%E6%AD%BB%E9%94%81"><span class="toc-number">22.6.</span> <span class="toc-text">第21章-6 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-7-%E6%96%B0%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="toc-number">22.7.</span> <span class="toc-text">第21章-7 新类库中的构件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-8-%E4%BB%BF%E7%9C%9F"><span class="toc-number">22.8.</span> <span class="toc-text">第21章-8 仿真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-9-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">22.9.</span> <span class="toc-text">第21章-9 性能调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-10-%E6%B4%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.10.</span> <span class="toc-text">第21章-10 活动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-11-%E6%80%BB%E7%BB%93"><span class="toc-number">22.11.</span> <span class="toc-text">第21章-11 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC22%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">23.</span> <span class="toc-text">第22章 图形化用户界面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%96%E5%8F%82%E7%9C%8B"><span class="toc-number">24.</span> <span class="toc-text">📖参看</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%BB%E5%8F%82%E8%80%83%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">25.</span> <span class="toc-text">※参考和引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%97%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">26.</span> <span class="toc-text">🔗外部链接</span></a></li></ol>
                    </div>
                
                <hr />
                <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><p><a id="index_1" href="#第1章-面向对象导论" aria-label="跳转到章节" title="跳转到章节">第1章 面向对象导论</a></p>
<ul>
<li><a id="index_1-1" href="#第1章-1-抽象过程" aria-label="跳转到章节" title="跳转到章节">1.1 抽象过程</a></li>
<li><a id="index_1-2" href="#第1章-2-每个对象都有一个接口" aria-label="跳转到章节" title="跳转到章节">1.2 每个对象都有一个接口</a></li>
<li><a id="index_1-3" href="#第1章-3-每个对象都提供服务" aria-label="跳转到章节" title="跳转到章节">1.3 每个对象都提供服务</a></li>
<li><a id="index_1-4" href="#第1章-4-被隐藏的具体实现" aria-label="跳转到章节" title="跳转到章节">1.4 被隐藏的具体实现</a></li>
<li><a id="index_1-5" href="#第1章-5-复用具体实现" aria-label="跳转到章节" title="跳转到章节">1.5 复用具体实现</a></li>
<li><a id="index_1-6" href="#第1章-6-继承" aria-label="跳转到章节" title="跳转到章节">1.6 继承</a><ul>
<li><a id="index_1-6-1" href="#第1章-6-1-“是一个”与“像是一个”的关系" aria-label="跳转到章节" title="跳转到章节">1.6.1 “是一个”与“像是一个”的关系</a></li>
</ul>
</li>
<li><a id="index_1-7" href="#第1章-7-伴随多态的可互换对象" aria-label="跳转到章节" title="跳转到章节">1.7 伴随多态的可互换对象</a></li>
<li><a id="index_1-8" href="#第1章-8-单根继承结构" aria-label="跳转到章节" title="跳转到章节">1.8 单根继承结构</a></li>
<li><a id="index_1-9" href="#第1章-9-容器" aria-label="跳转到章节" title="跳转到章节">1.9 容器</a><ul>
<li><a id="index_1-9-1" href="#第1章-9-1-参数化类型" aria-label="跳转到章节" title="跳转到章节">1.9.1 参数化类型</a></li>
</ul>
</li>
<li><a id="index_1-10" href="#第1章-10-对象的创建和生命周期" aria-label="跳转到章节" title="跳转到章节">1.10 对象的创建和生命周期</a></li>
<li><a id="index_1-11" href="#第1章-11-异常处理：错误处理" aria-label="跳转到章节" title="跳转到章节">1.11 异常处理：错误处理</a></li>
<li><a id="index_1-12" href="#第1章-12-并发编程" aria-label="跳转到章节" title="跳转到章节">1.12 并发编程</a></li>
<li><a id="index_1-13" href="#第1章-13-Java与Internet" aria-label="跳转到章节" title="跳转到章节">1.13 Java与Internet</a><ul>
<li><a id="index_1-13-1" href="#第1章-13-1-Web是什么" aria-label="跳转到章节" title="跳转到章节">1.13.1 Web是什么</a></li>
<li><a id="index_1-13-2" href="#第1章-13-2-客户端编程" aria-label="跳转到章节" title="跳转到章节">1.13.2 客户端编程</a></li>
<li><a id="index_1-13-3" href="#第1章-13-3-服务器端编程" aria-label="跳转到章节" title="跳转到章节">1.13.3 服务器端编程</a></li>
</ul>
</li>
<li><a id="index_1-14" href="#第1章-14-总结" aria-label="跳转到章节" title="跳转到章节">1.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_2" href="#第2章-一切都是对象" aria-label="跳转到章节" title="跳转到章节">第2章 一切都是对象</a></p>
<ul>
<li><a id="index_2-1" href="#第2章-1-用引用操纵对象" aria-label="跳转到章节" title="跳转到章节">2.1 用引用操纵对象</a></li>
<li><a id="index_2-2" href="#第2章-2-必须由你创建所有对象【底层存储】" aria-label="跳转到章节" title="跳转到章节">2.2 必须由你创建所有对象【底层存储】</a><ul>
<li><a id="index_2-2-1" href="#第2章-2-1-存储到什么地方【对象的存储】" aria-label="跳转到章节" title="跳转到章节">2.2.1 存储到什么地方【对象的存储】</a></li>
<li><a id="index_2-2-2" href="#第2章-2-2-特例：基本类型" aria-label="跳转到章节" title="跳转到章节">2.2.2 特例：基本类型</a></li>
<li><a id="index_2-2-3" href="#第2章-2-3-Java中的数组" aria-label="跳转到章节" title="跳转到章节">2.2.3 Java中的数组</a></li>
</ul>
</li>
<li><a id="index_2-3" href="#第2章-3-永远不需要销毁对象" aria-label="跳转到章节" title="跳转到章节">2.3 永远不需要销毁对象</a></li>
<li><a id="index_2-4" href="#第2章-4-创建新的数据类型" aria-label="跳转到章节" title="跳转到章节">2.4 创建新的数据类型</a></li>
<li><a id="index_2-5" href="#第2章-5-方法、参数和返回值" aria-label="跳转到章节" title="跳转到章节">2.5 方法、参数和返回值</a></li>
<li><a id="index_2-6" href="#第2章-6-构建一个Java程序" aria-label="跳转到章节" title="跳转到章节">2.6 构建一个Java程序</a></li>
<li><a id="index_2-7" href="#第2章-7-你的第一个Java程序" aria-label="跳转到章节" title="跳转到章节">2.7 你的第一个Java程序</a></li>
<li><a id="index_2-8" href="#第2章-8-注释和嵌入式文档" aria-label="跳转到章节" title="跳转到章节">2.8 注释和嵌入式文档</a></li>
<li><a id="index_2-9" href="#第2章-9-编码风格" aria-label="跳转到章节" title="跳转到章节">2.9 编码风格</a></li>
<li><a id="index_2-10" href="#第2章-10-总结" aria-label="跳转到章节" title="跳转到章节">2.10 总结</a></li>
<li><a id="index_2-11" href="#第2章-11-练习" aria-label="跳转到章节" title="跳转到章节">2.11 练习</a></li>
</ul>
</li>
<li><p><a id="index_3" href="#第3章-操作符" aria-label="跳转到章节" title="跳转到章节">第3章 操作符</a></p>
<ul>
<li><a id="index_3-1" href="#第3章-1-更简单的打印语句" aria-label="跳转到章节" title="跳转到章节">3.1 更简单的打印语句</a></li>
<li><a id="index_3-2" href="#第3章-2-使用Java操作符" aria-label="跳转到章节" title="跳转到章节">3.2 使用Java操作符</a></li>
<li><a id="index_3-3" href="#第3章-3-优先级" aria-label="跳转到章节" title="跳转到章节">3.3 优先级</a></li>
<li><a id="index_3-4" href="#第3章-4-赋值" aria-label="跳转到章节" title="跳转到章节">3.4 赋值</a><ul>
<li><a id="index_3-4-1" href="#第3章-4-1-方法调用中的别名问题" aria-label="跳转到章节" title="跳转到章节">3.4.1 方法调用中的别名问题</a></li>
</ul>
</li>
<li><a id="index_3-5" href="#第3章-5-算数操作符" aria-label="跳转到章节" title="跳转到章节">3.5 算数操作符</a><ul>
<li><a id="index_3-5-1" href="#第3章-5-1-一元加减操作符" aria-label="跳转到章节" title="跳转到章节">3.5.1 一元加减操作符</a></li>
</ul>
</li>
<li><a id="index_3-6" href="#第3章-6-自动递增和递减" aria-label="跳转到章节" title="跳转到章节">3.6 自动递增和递减</a></li>
<li><a id="index_3-7" href="#第3章-7-关系操作符" aria-label="跳转到章节" title="跳转到章节">3.7 关系操作符</a><ul>
<li><a id="index_3-7-1" href="#第3章-7-1-测试对象的等价性" aria-label="跳转到章节" title="跳转到章节">3.7.1 测试对象的等价性</a></li>
</ul>
</li>
<li><a id="index_3-8" href="#第3章-8-逻辑操作符" aria-label="跳转到章节" title="跳转到章节">3.8 逻辑操作符</a><ul>
<li><a id="index_3-8-1" href="#第3章-8-1-短路" aria-label="跳转到章节" title="跳转到章节">3.8.1 短路</a></li>
</ul>
</li>
<li><a id="index_3-9" href="#第3章-9-直接常量" aria-label="跳转到章节" title="跳转到章节">3.9 直接常量</a><ul>
<li><a id="index_3-9-1" href="#第3章-9-1-指数记数法" aria-label="跳转到章节" title="跳转到章节">3.9.1 指数记数法</a></li>
</ul>
</li>
<li><a id="index_3-10" href="#第3章-10-按位操作符" aria-label="跳转到章节" title="跳转到章节">3.10 按位操作符</a></li>
<li><a id="index_3-11" href="#第3章-11-移位操作符" aria-label="跳转到章节" title="跳转到章节">3.11 移位操作符</a></li>
<li><a id="index_3-12" href="#第3章-12-三元操作符if-else" aria-label="跳转到章节" title="跳转到章节">3.12 三元操作符if-else</a></li>
<li><a id="index_3-13" href="#第3章-13-字符串操作符+和=" aria-label="跳转到章节" title="跳转到章节">3.13 字符串操作符+和=</a></li>
<li><a id="index_3-14" href="#第3章-14-使用操作符时常犯的错误" aria-label="跳转到章节" title="跳转到章节">3.14 使用操作符时常犯的错误</a></li>
<li><a id="index_3-15" href="#第3章-15-类型转换操作符" aria-label="跳转到章节" title="跳转到章节">3.15 类型转换操作符</a><ul>
<li><a id="index_3-15-1" href="#第3章-15-1-截尾和舍入" aria-label="跳转到章节" title="跳转到章节">3.15.1 截尾和舍入</a></li>
<li><a id="index_3-15-2" href="#第3章-15-2-提升" aria-label="跳转到章节" title="跳转到章节">3.15.2 提升</a></li>
</ul>
</li>
<li><a id="index_3-16" href="#第3章-16-Java没有sizeof" aria-label="跳转到章节" title="跳转到章节">3.16 Java没有sizeof</a></li>
<li><a id="index_3-17" href="#第3章-17-操作符小结" aria-label="跳转到章节" title="跳转到章节">3.17 操作符小结</a></li>
<li><a id="index_3-18" href="#第3章-18-总结" aria-label="跳转到章节" title="跳转到章节">3.18 总结</a></li>
</ul>
</li>
<li><p><a id="index_4" href="#第4章-控制执行流程" aria-label="跳转到章节" title="跳转到章节">第4章 控制执行流程</a></p>
</li>
<li><p><a id="index_5" href="#第5章-初始化与清理" aria-label="跳转到章节" title="跳转到章节">第5章 初始化与清理</a></p>
<ul>
<li><a id="index_5-1" href="#第5章-1-用构造器确保初始化" aria-label="跳转到章节" title="跳转到章节">5.1 用构造器确保初始化</a></li>
<li><a id="index_5-2" href="#第5章-2-方法重载" aria-label="跳转到章节" title="跳转到章节">5.2 方法重载</a></li>
<li><a id="index_5-3" href="#第5章-3-默认构造器" aria-label="跳转到章节" title="跳转到章节">5.3 默认构造器</a></li>
<li><a id="index_5-4" href="#第5章-4-this关键字" aria-label="跳转到章节" title="跳转到章节">5.4 this关键字</a><ul>
<li><a id="index_5-4-1" href="#第5章-4-1-在构造器中调用构造器" aria-label="跳转到章节" title="跳转到章节">5.4.1 在构造器中调用构造器</a></li>
<li><a id="index_5-4-2" href="#第5章-4-2-static的含义" aria-label="跳转到章节" title="跳转到章节">5.4.2 static的含义</a></li>
</ul>
</li>
<li><a id="index_5-5" href="#第5章-5-清理：终结处理和垃圾回收" aria-label="跳转到章节" title="跳转到章节">5.5 清理：终结处理和垃圾回收</a></li>
<li><a id="index_5-6" href="#第5章-6-成员初始化" aria-label="跳转到章节" title="跳转到章节">5.6 成员初始化</a><ul>
<li><a id="index_5-6-1" href="#第5章-6-1-指定初始化" aria-label="跳转到章节" title="跳转到章节">5.6.1 指定初始化</a></li>
</ul>
</li>
<li><a id="index_5-7" href="#第5章-7-构造器初始化" aria-label="跳转到章节" title="跳转到章节">5.7 构造器初始化</a><ul>
<li><a id="index_5-7-1" href="#第5章-7-1-初始化顺序" aria-label="跳转到章节" title="跳转到章节">5.7.1 初始化顺序</a></li>
<li><a id="index_5-7-2" href="#第5章-7-2-静态数据的初始化" aria-label="跳转到章节" title="跳转到章节">5.7.2 静态数据的初始化</a></li>
<li><a id="index_5-7-3" href="#第5章-7-3-显式的静态初始化" aria-label="跳转到章节" title="跳转到章节">5.7.3 显式的静态初始化</a></li>
<li><a id="index_5-7-4" href="#第5章-7-4-非静态实例初始化" aria-label="跳转到章节" title="跳转到章节">5.7.4 非静态实例初始化</a></li>
</ul>
</li>
<li><a id="index_5-8" href="#第5章-8-数组初始化" aria-label="跳转到章节" title="跳转到章节">5.8 数组初始化</a><ul>
<li><a id="index_5-8-1" href="#第5章-8-1-可变参数列表" aria-label="跳转到章节" title="跳转到章节">5.8.1 可变参数列表</a></li>
</ul>
</li>
<li><a id="index_5-9" href="#第5章-9-枚举类型" aria-label="跳转到章节" title="跳转到章节">5.9 枚举类型</a><ul>
<li><a id="index_5-9-1" href="#第5章-9-1-枚举类（enum）——基本概念" aria-label="跳转到章节" title="跳转到章节">5.9.1 枚举类（enum）——基本概念</a></li>
<li><a id="index_5-9-2" href="#第5章-9-2-枚举类的使用" aria-label="跳转到章节" title="跳转到章节">5.9.2 枚举类的使用</a></li>
</ul>
</li>
<li><a id="index_5-10" href="#第5章-10-总结" aria-label="跳转到章节" title="跳转到章节">5.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_6" href="#第6章-访问权限控制" aria-label="跳转到章节" title="跳转到章节">第6章 访问权限控制</a></p>
<ul>
<li><a id="index_6-1" href="#第6章-1-包：库单元" aria-label="跳转到章节" title="跳转到章节">6.1 包：库单元</a><ul>
<li><a id="index_6-1-1" href="#第6章-1-1-代码组织" aria-label="跳转到章节" title="跳转到章节">6.1.1 代码组织</a></li>
<li><a id="index_6-1-2" href="#第6章-1-2-创建独一无二的包名" aria-label="跳转到章节" title="跳转到章节">6.1.2 创建独一无二的包名</a></li>
<li><a id="index_6-1-3" href="#第6章-1-3-定制工具库" aria-label="跳转到章节" title="跳转到章节">6.1.3 定制工具库</a></li>
<li><a id="index_6-1-4" href="#第6章-1-4-用import改变行为" aria-label="跳转到章节" title="跳转到章节">6.1.4 用import改变行为</a></li>
<li><a id="index_6-1-5" href="#第6章-1-5-对使用包的忠告" aria-label="跳转到章节" title="跳转到章节">6.1.5 对使用包的忠告</a></li>
</ul>
</li>
<li><a id="index_6-2" href="#第6章-2-Java访问权限修饰词" aria-label="跳转到章节" title="跳转到章节">6.2 Java访问权限修饰词</a></li>
<li><a id="index_6-3" href="#第6章-3-接口和实现" aria-label="跳转到章节" title="跳转到章节">6.3 接口和实现</a></li>
<li><a id="index_6-4" href="#第6章-4-类的访问权限" aria-label="跳转到章节" title="跳转到章节">6.4 类的访问权限</a></li>
<li><a id="index_6-5" href="#第6章-5-总结" aria-label="跳转到章节" title="跳转到章节">6.5 总结</a></li>
</ul>
</li>
<li><p><a id="index_7" href="#第7章-复用类" aria-label="跳转到章节" title="跳转到章节">第7章 复用类</a></p>
<ul>
<li><a id="index_7-1" href="#第7章-1-组合语法" aria-label="跳转到章节" title="跳转到章节">7.1 组合语法</a></li>
<li><a id="index_7-2" href="#第7章-2-继承语法" aria-label="跳转到章节" title="跳转到章节">7.2 继承语法</a><ul>
<li><a id="index_7-2-1" href="#第7章-2-1-初始化基类" aria-label="跳转到章节" title="跳转到章节">7.2.1 初始化基类</a></li>
<li><a id="index_7-2-2" href="#第7章-2-2-重写" aria-label="跳转到章节" title="跳转到章节">【拓展】7.2.2 重写</a></li>
</ul>
</li>
<li><a id="index_7-3" href="#第7章-3-代理" aria-label="跳转到章节" title="跳转到章节">7.3 代理</a></li>
<li><a id="index_7-4" href="#第7章-4-结合使用组合和继承" aria-label="跳转到章节" title="跳转到章节">7.4 结合使用组合和继承</a></li>
<li><a id="index_7-5" href="#第7章-5-在组合与继承之间选择" aria-label="跳转到章节" title="跳转到章节">7.5 在组合与继承之间选择</a></li>
<li><a id="index_7-6" href="#第7章-6-protected关键字" aria-label="跳转到章节" title="跳转到章节">7.6 protected关键字</a></li>
<li><a id="index_7-7" href="#第7章-7-向上转型" aria-label="跳转到章节" title="跳转到章节">7.7 向上转型</a></li>
<li><a id="index_7-8" href="#第7章-8-final关键字" aria-label="跳转到章节" title="跳转到章节">7.8 final关键字</a><ul>
<li><a id="index_7-8-1" href="#第7章-8-1-final数据" aria-label="跳转到章节" title="跳转到章节">7.8.1 final数据</a></li>
<li><a id="index_7-8-2" href="#第7章-8-2-final方法" aria-label="跳转到章节" title="跳转到章节">7.8.2 final方法</a></li>
<li><a id="index_7-8-3" href="#第7章-8-3-final类" aria-label="跳转到章节" title="跳转到章节">7.8.3 final类</a></li>
<li><a id="index_7-8-4" href="#第7章-8-4-有关final的忠告" aria-label="跳转到章节" title="跳转到章节">7.8.4 有关final的忠告</a></li>
</ul>
</li>
<li><a id="index_7-9" href="#第7章-9-初始化类及类的加载" aria-label="跳转到章节" title="跳转到章节">7.9 初始化类及类的加载</a></li>
<li><a id="index_7-10" href="#第7章-10-总结" aria-label="跳转到章节" title="跳转到章节">7.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_8" href="#第8章-多态" aria-label="跳转到章节" title="跳转到章节">第8章 多态</a></p>
<ul>
<li><a id="index_8-1" href="#第8章-1-再论向上转型" aria-label="跳转到章节" title="跳转到章节">8.1 再论向上转型</a></li>
<li><a id="index_8-2" href="#第8章-2-转机" aria-label="跳转到章节" title="跳转到章节">8.2 转机</a></li>
<li><a id="index_8-3" href="#第8章-3-构造器和多态" aria-label="跳转到章节" title="跳转到章节">8.3 构造器和多态</a></li>
<li><a id="index_8-4" href="#第8章-4-协变返回类型" aria-label="跳转到章节" title="跳转到章节">8.4 协变返回类型</a></li>
<li><a id="index_8-5" href="#第8章-5-用继承进行设计" aria-label="跳转到章节" title="跳转到章节">8.5 用继承进行设计</a><ul>
<li><a id="index_8-5-1" href="#第8章-5-1-纯继承与拓展" aria-label="跳转到章节" title="跳转到章节">8.5.1 纯继承与拓展</a></li>
<li><a id="index_8-5-2" href="#第8章-5-2-向下转型与运行时类型识别" aria-label="跳转到章节" title="跳转到章节">8.5.2 向下转型与运行时类型识别</a></li>
</ul>
</li>
<li><a id="index_8-6" href="#第8章-6-总结" aria-label="跳转到章节" title="跳转到章节">8.6 总结</a></li>
</ul>
</li>
<li><p><a id="index_9" href="#第9章-接口" aria-label="跳转到章节" title="跳转到章节">第9章 接口</a></p>
<ul>
<li><a id="index_9-1" href="#第8章-1-抽象类和抽象方法" aria-label="跳转到章节" title="跳转到章节">9.1 抽象类和抽象方法</a></li>
<li><a id="index_9-2" href="#第8章-2-接口" aria-label="跳转到章节" title="跳转到章节">9.2 接口</a></li>
<li><a id="index_9-3" href="#第8章-3-完全解耦" aria-label="跳转到章节" title="跳转到章节">9.3 完全解耦</a></li>
<li><a id="index_9-4" href="#第8章-4-Java中的多重继承" aria-label="跳转到章节" title="跳转到章节">9.4 Java中的多重继承</a></li>
<li><a id="index_9-5" href="#第8章-5-通过继承来拓展接口" aria-label="跳转到章节" title="跳转到章节">9.5 通过继承来拓展接口</a></li>
<li><a id="index_9-6" href="#第8章-6-适配接口" aria-label="跳转到章节" title="跳转到章节">9.6 适配接口</a></li>
<li><a id="index_9-7" href="#第8章-7-接口中的域" aria-label="跳转到章节" title="跳转到章节">9.7 接口中的域</a></li>
<li><a id="index_9-8" href="#第8章-8-嵌套接口" aria-label="跳转到章节" title="跳转到章节">9.8 嵌套接口</a></li>
<li><a id="index_9-9" href="#第8章-9-接口与工厂" aria-label="跳转到章节" title="跳转到章节">9.9 接口与工厂</a></li>
<li><a id="index_9-10" href="#第8章-10-总结" aria-label="跳转到章节" title="跳转到章节">9.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_10" href="#第10章-内部类" aria-label="跳转到章节" title="跳转到章节">第10章 内部类</a></p>
<ul>
<li><a id="index_10-1" href="#第10章-1-创建内部类" aria-label="跳转到章节" title="跳转到章节">10.1 创建内部类</a></li>
<li><a id="index_10-2" href="#第10章-2-链接到外部类" aria-label="跳转到章节" title="跳转到章节">10.2 链接到外部类</a></li>
<li><a id="index_10-3" href="#第10章-3-使用.this与.new" aria-label="跳转到章节" title="跳转到章节">10.3 使用.this与.new</a></li>
<li><a id="index_10-4" href="#第10章-4-内部类与向上转型" aria-label="跳转到章节" title="跳转到章节">10.4 内部类与向上转型</a></li>
<li><a id="index_10-5" href="#第10章-5-在方法和作用域内的内部类" aria-label="跳转到章节" title="跳转到章节">10.5 在方法和作用域内的内部类</a></li>
<li><a id="index_10-6" href="#第10章-6-匿名内部类" aria-label="跳转到章节" title="跳转到章节">10.6 匿名内部类</a></li>
<li><a id="index_10-7" href="#第10章-7-嵌套类" aria-label="跳转到章节" title="跳转到章节">10.7 嵌套类</a></li>
<li><a id="index_10-8" href="#第10章-8-为什么需要内部类" aria-label="跳转到章节" title="跳转到章节">10.8 为什么需要内部类</a></li>
<li><a id="index_10-9" href="#第10章-9-内部类的继承" aria-label="跳转到章节" title="跳转到章节">10.9 内部类的继承</a></li>
<li><a id="index_10-10" href="#第10章-10-内部类可以被覆盖吗" aria-label="跳转到章节" title="跳转到章节">10.10 内部类可以被覆盖吗</a></li>
<li><a id="index_10-11" href="#第10章-11-局部内部类" aria-label="跳转到章节" title="跳转到章节">10.11 局部内部类</a></li>
<li><a id="index_10-12" href="#第10章-12-内部类标识符" aria-label="跳转到章节" title="跳转到章节">10.12 内部类标识符</a></li>
<li><a id="index_10-13" href="#第10章-13-总结" aria-label="跳转到章节" title="跳转到章节">10.13 总结</a></li>
</ul>
</li>
<li><p><a id="index_11" href="#第11章-持有对象" aria-label="跳转到章节" title="跳转到章节">第11章 持有对象</a></p>
<ul>
<li><a id="index_11-1" href="#第11章-1-泛型和类型安全的容器" aria-label="跳转到章节" title="跳转到章节">11.1 泛型和类型安全的容器</a></li>
<li><a id="index_11-2" href="#第11章-2-基本概念" aria-label="跳转到章节" title="跳转到章节">11.2 基本概念</a></li>
<li><a id="index_11-3" href="#第11章-3-添加一组元素" aria-label="跳转到章节" title="跳转到章节">11.3 添加一组元素</a></li>
<li><a id="index_11-4" href="#第11章-4-容器的打印" aria-label="跳转到章节" title="跳转到章节">11.4 容器的打印</a></li>
<li><a id="index_11-5" href="#第11章-5-List（原理-amp-简介）" aria-label="跳转到章节" title="跳转到章节">11.5 List（原理 &amp; 简介）</a></li>
<li><a id="index_11-6" href="#第11章-6-迭代器" aria-label="跳转到章节" title="跳转到章节">11.6 迭代器</a></li>
<li><a id="index_11-7" href="#第11章-7-LinkedList" aria-label="跳转到章节" title="跳转到章节">11.7 LinkedList</a></li>
<li><a id="index_11-8" href="#第11章-8-Stack" aria-label="跳转到章节" title="跳转到章节">11.8 Stack</a></li>
<li><a id="index_11-9" href="#第11章-9-Set" aria-label="跳转到章节" title="跳转到章节">11.9 Set</a></li>
<li><a id="index_11-10" href="#第11章-10-Map" aria-label="跳转到章节" title="跳转到章节">11.10 Map</a></li>
<li><a id="index_11-11" href="#第11章-11-Queue" aria-label="跳转到章节" title="跳转到章节">11.11 Queue</a></li>
<li><a id="index_11-12" href="#第11章-12-Collection和Iterator" aria-label="跳转到章节" title="跳转到章节">11.12 Collection和Iterator</a></li>
<li><a id="index_11-13" href="#第11章-13-Foreach与迭代器" aria-label="跳转到章节" title="跳转到章节">11.13 Foreach与迭代器</a><ul>
<li><a id="index_11-13-1" href="#第11章-13-1-适配器方法惯用法→示例源码说明" aria-label="跳转到章节" title="跳转到章节">11.13.1 适配器方法惯用法→示例源码说明</a></li>
</ul>
</li>
<li><a id="index_11-14" href="#第11章-14-总结" aria-label="跳转到章节" title="跳转到章节">11.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_12" href="#第12章-通过异常处理错误" aria-label="跳转到章节" title="跳转到章节">第12章 通过异常处理错误</a></p>
<ul>
<li><a id="index_12-1" href="#第12章-1-概念" aria-label="跳转到章节" title="跳转到章节">12.1 概念</a></li>
<li><a id="index_12-2" href="#第12章-2-基本异常" aria-label="跳转到章节" title="跳转到章节">12.2 基本异常</a><ul>
<li><a id="index_12-2-1" href="#第12章-2-1-捕获异常参数" aria-label="跳转到章节" title="跳转到章节">12.2.1 捕获异常参数</a></li>
</ul>
</li>
<li><a id="index_12-3" href="#第12章-3-捕获异常" aria-label="跳转到章节" title="跳转到章节">12.3 捕获异常</a><ul>
<li><a id="index_12-3-1" href="#第12章-3-1-try块" aria-label="跳转到章节" title="跳转到章节">12.3.1 try块</a></li>
<li><a id="index_12-3-2" href="#第12章-3-2-异常处理程序" aria-label="跳转到章节" title="跳转到章节">12.3.2 异常处理程序</a></li>
</ul>
</li>
<li><a id="index_12-4" href="#第12章-4-创建自定义异常" aria-label="跳转到章节" title="跳转到章节">12.4 创建自定义异常</a><ul>
<li><a id="index_12-4-1" href="#第12章-4-1-异常与记录日志" aria-label="跳转到章节" title="跳转到章节">12.4.1 异常与记录日志</a></li>
</ul>
</li>
<li><a id="index_12-5" href="#第12章-5-异常说明" aria-label="跳转到章节" title="跳转到章节">12.5 异常说明</a></li>
<li><a id="index_12-6" href="#第12章-6-捕获所有异常" aria-label="跳转到章节" title="跳转到章节">12.6 捕获所有异常</a><ul>
<li><a id="index_12-6-1" href="#第12章-6-1-栈轨迹" aria-label="跳转到章节" title="跳转到章节">12.6.1 栈轨迹</a></li>
<li><a id="index_12-6-2" href="#第12章-6-2-重新抛出异常" aria-label="跳转到章节" title="跳转到章节">12.6.2 重新抛出异常</a></li>
<li><a id="index_12-6-3" href="#第12章-6-3-异常链" aria-label="跳转到章节" title="跳转到章节">12.6.3 异常链</a></li>
</ul>
</li>
<li><a id="index_12-7" href="#第12章-7-Java标准异常" aria-label="跳转到章节" title="跳转到章节">12.7 Java标准异常</a><ul>
<li><a id="index_12-7-1" href="#第12章-7-1-特例：RuntimeException" aria-label="跳转到章节" title="跳转到章节">12.7.1 特例：RuntimeException</a></li>
</ul>
</li>
<li><a id="index_12-8" href="#第12章-8-使用finally进行清理" aria-label="跳转到章节" title="跳转到章节">12.8 使用finally进行清理</a><ul>
<li><a id="index_12-8-1" href="#第12章-8-1-finally用来做什么" aria-label="跳转到章节" title="跳转到章节">12.8.1 finally用来做什么</a></li>
<li><a id="index_12-8-2" href="#第12章-8-2-在return中使用finally" aria-label="跳转到章节" title="跳转到章节">12.8.2 在return中使用finally</a></li>
<li><a id="index_12-8-3" href="#第12章-8-3-缺憾：异常缺失" aria-label="跳转到章节" title="跳转到章节">12.8.3 缺憾：异常缺失</a></li>
</ul>
</li>
<li><a id="index_12-9" href="#第12章-9-异常的限制" aria-label="跳转到章节" title="跳转到章节">12.9 异常的限制</a></li>
<li><a id="index_12-10" href="#第12章-10-构造器" aria-label="跳转到章节" title="跳转到章节">12.10 构造器</a></li>
<li><a id="index_12-11" href="#第12章-11-异常匹配" aria-label="跳转到章节" title="跳转到章节">12.11 异常匹配</a></li>
<li><a id="index_12-12" href="#第12章-12-其他可选方式" aria-label="跳转到章节" title="跳转到章节">12.12 其他可选方式</a><ul>
<li><a id="index_12-12-1" href="#第12章-12-1-历史" aria-label="跳转到章节" title="跳转到章节">12.12.1 历史</a></li>
<li><a id="index_12-12-2" href="#第12章-12-2-观点" aria-label="跳转到章节" title="跳转到章节">12.12.2 观点</a></li>
<li><a id="index_12-12-3" href="#第12章-12-3-把异常传递给控制台" aria-label="跳转到章节" title="跳转到章节">12.12.3 把异常传递给控制台</a></li>
<li><a id="index_12-12-4" href="#第12章-12-4-把“被检查的异常”转换为“不检查的异常”" aria-label="跳转到章节" title="跳转到章节">12.12.4 把“被检查的异常”转换为“不检查的异常”</a></li>
</ul>
</li>
<li><a id="index_12-13" href="#第12章-13-异常使用指南" aria-label="跳转到章节" title="跳转到章节">12.13 异常使用指南</a></li>
<li><a id="index_12-14" href="#第12章-14-总结" aria-label="跳转到章节" title="跳转到章节">12.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_13" href="#第13章-字符串" aria-label="跳转到章节" title="跳转到章节">第13章 字符串</a></p>
<ul>
<li><a id="index_13-1" href="#第13章-1-不可变String" aria-label="跳转到章节" title="跳转到章节">13.1 不可变String</a></li>
<li><a id="index_13-2" href="#第13章-2-重载“-”与StringBuilder" aria-label="跳转到章节" title="跳转到章节">13.2 重载“+”与StringBuilder</a></li>
<li><a id="index_13-3" href="#第13章-3-无意识的递归" aria-label="跳转到章节" title="跳转到章节">13.3 无意识的递归</a></li>
<li><a id="index_13-4" href="#第13章-4-String上的操作" aria-label="跳转到章节" title="跳转到章节">13.4 String上的操作</a></li>
<li><a id="index_13-5" href="#第13章-5-格式化输出" aria-label="跳转到章节" title="跳转到章节">13.5 格式化输出</a><ul>
<li><a id="index_13-5-4" href="#第13章-5-4 格式化说明符" aria-label="跳转到章节" title="跳转到章节">13.5.4 格式化说明符</a></li>
</ul>
</li>
<li><a id="index_13-6" href="#第13章-6-正则表达式" aria-label="跳转到章节" title="跳转到章节">13.6 正则表达式</a></li>
<li><a id="index_13-7" href="#第13章-7-扫描输入" aria-label="跳转到章节" title="跳转到章节">13.7 扫描输入</a></li>
<li><a id="index_13-8" href="#第13章-8-StringTokenizer（已废弃）" aria-label="跳转到章节" title="跳转到章节">13.8 StringTokenizer（已废弃）</a></li>
<li><a id="index_13-9" href="#第13章-9-总结" aria-label="跳转到章节" title="跳转到章节">13.9 总结</a></li>
</ul>
</li>
<li><p><a id="index_14" href="#第14章-类型信息（RTTI）" aria-label="跳转到章节" title="跳转到章节">第14章 类型信息（RTTI）</a></p>
<ul>
<li><a id="index_14-1" href="#第14章-1-为什么需要RTTI" aria-label="跳转到章节" title="跳转到章节">14.1 为什么需要RTTI</a></li>
<li><a id="index_14-2" href="#第14章-2-Class对象" aria-label="跳转到章节" title="跳转到章节">14.2 Class对象</a><ul>
<li><a id="index_14-2-1" href="#第14章-2-1-类字面量" aria-label="跳转到章节" title="跳转到章节">14.2.1 类字面量</a></li>
<li><a id="index_14-2-2" href="#第14章-2-2-泛化的Class引用" aria-label="跳转到章节" title="跳转到章节">14.2.2 泛化的Class引用</a></li>
<li><a id="index_14-2-3" href="#第14章-2-3-类的转换（原：新的转型语法）" aria-label="跳转到章节" title="跳转到章节">14.2.3 类的转换（原：新的转型语法）</a></li>
</ul>
</li>
<li><a id="index_14-3" href="#第14章-3-类型转换前先做检查" aria-label="跳转到章节" title="跳转到章节">14.3 类型转换前先做检查</a></li>
<li><a id="index_14-4" href="#第14章-4-注册工厂" aria-label="跳转到章节" title="跳转到章节">14.4 注册工厂</a></li>
<li><a id="index_14-5" href="#第14章-5-instanceof与Class的等价性" aria-label="跳转到章节" title="跳转到章节">14.5 instanceof与Class的等价性</a></li>
<li><a id="index_14-6" href="#第14章-6-反射：运行时的类信息" aria-label="跳转到章节" title="跳转到章节">14.6 反射：运行时的类信息</a><ul>
<li><a id="index_14-6-1" href="#第14章-6-1-类方法提取器" aria-label="跳转到章节" title="跳转到章节">14.6.1 类方法提取器</a></li>
</ul>
</li>
<li><a id="index_14-7" href="#第14章-7-动态代理" aria-label="跳转到章节" title="跳转到章节">14.7 动态代理</a></li>
<li><a id="index_14-8" href="#第14章-8-空对象" aria-label="跳转到章节" title="跳转到章节">14.8 空对象</a><ul>
<li><a id="index_14-8-1" href="#第14章-8-1-模拟对象与桩" aria-label="跳转到章节" title="跳转到章节">14.8.1 模拟对象与桩</a></li>
</ul>
</li>
<li><a id="index_14-9" href="#第14章-9-接口与类型信息" aria-label="跳转到章节" title="跳转到章节">14.9 接口与类型信息</a></li>
<li><a id="index_14-10" href="#第14章-10-总结" aria-label="跳转到章节" title="跳转到章节">14.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_15" href="#第15章-泛型" aria-label="跳转到章节" title="跳转到章节">第15章 泛型</a></p>
<ul>
<li><a id="index_15-1" href="#第15章-1-与C-比较" aria-label="跳转到章节" title="跳转到章节">15.1 与C++比较</a></li>
<li><a id="index_15-2" href="#第15章-2-简单泛型" aria-label="跳转到章节" title="跳转到章节">15.2 简单泛型</a><ul>
<li><a id="index_15-2-1" href="#第15章-2-1-一个元祖类库" aria-label="跳转到章节" title="跳转到章节">15.2.1 一个元祖类库</a></li>
<li><a id="index_15-2-2" href="#第15章-2-2-一个堆栈类" aria-label="跳转到章节" title="跳转到章节">15.2.2 一个堆栈类</a></li>
<li><a id="index_15-2-3" href="#第15章-2-3-RandomList" aria-label="跳转到章节" title="跳转到章节">15.2.3 RandomList</a></li>
</ul>
</li>
<li><a id="index_15-3" href="#第15章-3-泛型接口" aria-label="跳转到章节" title="跳转到章节">15.3 泛型接口</a></li>
<li><a id="index_15-4" href="#第15章-4-泛型方法" aria-label="跳转到章节" title="跳转到章节">15.4 泛型方法</a><ul>
<li><a id="index_15-4-1" href="#第15章-4-1-杠杆利用类型参数判断" aria-label="跳转到章节" title="跳转到章节">15.4.1 杠杆利用类型参数判断</a></li>
<li><a id="index_15-4-2" href="#第15章-4-2-可变参数与泛型方法" aria-label="跳转到章节" title="跳转到章节">15.4.2 可变参数与泛型方法</a></li>
<li><a id="index_15-4-3" href="#第15章-4-3-用于Generator的泛型方法" aria-label="跳转到章节" title="跳转到章节">15.4.3 用于Generator的泛型方法</a></li>
<li><a id="index_15-4-4" href="#第15章-4-4-一个通用的Generator" aria-label="跳转到章节" title="跳转到章节">15.4.4 一个通用的Generator</a></li>
<li><a id="index_15-4-5" href="#第15章-4-5-简化元祖的使用" aria-label="跳转到章节" title="跳转到章节">15.4.5 简化元祖的使用</a></li>
<li><a id="index_15-4-6" href="#第15章-4-6-一个Set实用工具" aria-label="跳转到章节" title="跳转到章节">15.4.6 一个Set实用工具</a></li>
</ul>
</li>
<li><a id="index_15-5" href="#第15章-5-匿名内部类" aria-label="跳转到章节" title="跳转到章节">15.5 匿名内部类</a></li>
<li><a id="index_15-6" href="#第15章-6-构建复杂模型" aria-label="跳转到章节" title="跳转到章节">15.6 构建复杂模型</a></li>
<li><a id="index_15-7" href="#第15章-7-擦除的神秘之处" aria-label="跳转到章节" title="跳转到章节">15.7 擦除的神秘之处</a><ul>
<li><a id="index_15-7-1" href="#第15章-7-1-C-的方式" aria-label="跳转到章节" title="跳转到章节">15.7.1 C++的方式</a></li>
<li><a id="index_15-7-2" href="#第15章-7-2-迁移兼容性" aria-label="跳转到章节" title="跳转到章节">15.7.2 迁移兼容性</a></li>
<li><a id="index_15-7-3" href="#第15章-7-3-擦除的问题" aria-label="跳转到章节" title="跳转到章节">15.7.3 擦除的问题</a></li>
<li><a id="index_15-7-4" href="#第15章-7-4-边界处的动作" aria-label="跳转到章节" title="跳转到章节">15.7.4 边界处的动作</a></li>
</ul>
</li>
<li><a id="index_15-8" href="#第15章-8-擦除的补偿" aria-label="跳转到章节" title="跳转到章节">15.8 擦除的补偿</a><ul>
<li><a id="index_15-8-1" href="#第15章-8-1-创建类型实例" aria-label="跳转到章节" title="跳转到章节">15.8.1 创建类型实例</a></li>
<li><a id="index_15-8-2" href="#第15章-8-2-泛型数组" aria-label="跳转到章节" title="跳转到章节">15.8.2 泛型数组</a></li>
</ul>
</li>
<li><a id="index_15-9" href="#第15章-9-边界" aria-label="跳转到章节" title="跳转到章节">15.9 边界</a></li>
<li><a id="index_15-10" href="#第15章-10-通配符" aria-label="跳转到章节" title="跳转到章节">15.10 通配符</a><ul>
<li><a id="index_15-10-1" href="#第15章-10-1-编译器有多聪明" aria-label="跳转到章节" title="跳转到章节">15.10.1 编译器有多聪明</a></li>
<li><a id="index_15-10-2" href="#第15章-10-2-逆变" aria-label="跳转到章节" title="跳转到章节">15.10.2 逆变</a></li>
<li><a id="index_15-10-3" href="#第15章-10-3-无界通配符" aria-label="跳转到章节" title="跳转到章节">15.10.3 无界通配符</a></li>
<li><a id="index_15-10-4" href="#第15章-10-4-捕获转换（通配符捕获）" aria-label="跳转到章节" title="跳转到章节">15.10.4 捕获转换（通配符捕获）</a></li>
</ul>
</li>
<li><a id="index_15-11" href="#第15章-11-问题" aria-label="跳转到章节" title="跳转到章节">15.11 问题</a><ul>
<li><a id="index_15-11-1" href="#第15章-11-1-任何基本类型都不能作为类型" aria-label="跳转到章节" title="跳转到章节">15.11.1 任何基本类型都不能作为类型</a></li>
<li><a id="index_15-11-2" href="#第15章-11-2-实现参数化接口" aria-label="跳转到章节" title="跳转到章节">15.11.2 实现参数化接口</a></li>
<li><a id="index_15-11-3" href="#第15章-11-3-转型和警告" aria-label="跳转到章节" title="跳转到章节">15.11.3 转型和警告</a></li>
<li><a id="index_15-11-4" href="#第15章-11-4-重载" aria-label="跳转到章节" title="跳转到章节">15.11.4 重载</a></li>
<li><a id="index_15-11-5" href="#第15章-11-5-基类劫持了接口" aria-label="跳转到章节" title="跳转到章节">15.11.5 基类劫持了接口</a></li>
</ul>
</li>
<li><a id="index_15-12" href="#第15章-12-自限定的类型" aria-label="跳转到章节" title="跳转到章节">15.12 自限定的类型</a><ul>
<li><a id="index_15-12-1" href="#第15章-12-1-古怪的循环泛型" aria-label="跳转到章节" title="跳转到章节">15.12.1 古怪的循环泛型</a></li>
<li><a id="index_15-12-2" href="#第15章-12-2-自限定" aria-label="跳转到章节" title="跳转到章节">15.12.2 自限定</a></li>
<li><a id="index_15-12-3" href="#第15章-12-3-参数协变" aria-label="跳转到章节" title="跳转到章节">15.12.3 参数协变</a></li>
</ul>
</li>
<li><a id="index_15-13" href="#第15章-13-动态类型安全" aria-label="跳转到章节" title="跳转到章节">15.13 动态类型安全</a></li>
<li><a id="index_15-14" href="#第15章-14-异常" aria-label="跳转到章节" title="跳转到章节">15.14 异常</a></li>
<li><a id="index_15-15" href="#第15章-15-混型" aria-label="跳转到章节" title="跳转到章节">15.15 混型</a><ul>
<li><a id="index_15-15-1" href="#第15章-15-1-C-中的混型" aria-label="跳转到章节" title="跳转到章节">15.15.1 C++中的混型</a></li>
<li><a id="index_15-15-2" href="#第15章-15-2-与接口混合" aria-label="跳转到章节" title="跳转到章节">15.15.2 与接口混合</a></li>
<li><a id="index_15-15-3" href="#第15章-15-3-使用装饰器模式" aria-label="跳转到章节" title="跳转到章节">15.15.3 使用装饰器模式</a></li>
<li><a id="index_15-15-4" href="#第15章-15-4-与动态代理混合" aria-label="跳转到章节" title="跳转到章节">15.15.4 与动态代理混合</a></li>
</ul>
</li>
<li><a id="index_15-16" href="#第15章-16-潜在类型机制" aria-label="跳转到章节" title="跳转到章节">15.16 潜在类型机制</a></li>
<li><a id="index_15-17" href="#第15章-17-对缺乏潜在类型机制的补偿" aria-label="跳转到章节" title="跳转到章节">15.17 对缺乏潜在类型机制的补偿</a><ul>
<li><a id="index_15-17-1" href="#第15章-17-1-反射" aria-label="跳转到章节" title="跳转到章节">15.17.1 反射</a></li>
<li><a id="index_15-17-2" href="#第15章-17-2-将一个方法应用于序列" aria-label="跳转到章节" title="跳转到章节">15.17.2 将一个方法应用于序列</a></li>
<li><a id="index_15-17-3" href="#第15章-17-3-当你并为碰巧拥有正确的接口时" aria-label="跳转到章节" title="跳转到章节">15.17.3 当你并为碰巧拥有正确的接口时</a></li>
<li><a id="index_15-17-4" href="#第15章-17-4-用适配器仿真潜在类型机制" aria-label="跳转到章节" title="跳转到章节">15.17.4 用适配器仿真潜在类型机制</a></li>
</ul>
</li>
<li><a id="index_15-18" href="#第15章-18-将函数对象用作策略" aria-label="跳转到章节" title="跳转到章节">15.18 将函数对象用作策略</a></li>
<li><a id="index_15-19" href="#第15章-19-总结：转型真的如此之糟吗？" aria-label="跳转到章节" title="跳转到章节">15.19 总结：转型真的如此之糟吗？</a><ul>
<li><a id="index_15-19-1" href="#第15章-19-1-进阶读物" aria-label="跳转到章节" title="跳转到章节">15.19.1 进阶读物</a></li>
</ul>
</li>
</ul>
</li>
<li><p><a id="index_16" href="#第16章-数组" aria-label="跳转到章节" title="跳转到章节">第16章 数组</a></p>
<ul>
<li><a id="index_16-1" href="#第16章-1-数组为什么特殊" aria-label="跳转到章节" title="跳转到章节">16.1 数组为什么特殊</a></li>
<li><a id="index_16-2" href="#第16章-2-数组是第一级对象" aria-label="跳转到章节" title="跳转到章节">16.2 数组是第一级对象</a></li>
<li><a id="index_16-3" href="#第16章-3-返回一个数组" aria-label="跳转到章节" title="跳转到章节">16.3 返回一个数组</a></li>
<li><a id="index_16-4" href="#第16章-4-多维数组" aria-label="跳转到章节" title="跳转到章节">16.4 多维数组</a></li>
<li><a id="index_16-5" href="#第16章-5-数组与泛型" aria-label="跳转到章节" title="跳转到章节">16.5 数组与泛型</a></li>
<li><a id="index_16-6" href="#第16章-6-创建测试数据" aria-label="跳转到章节" title="跳转到章节">16.6 创建测试数据</a><ul>
<li><a id="index_16-6-1" href="#第16章-6-1-Arrays-fill" aria-label="跳转到章节" title="跳转到章节">16.6.1 Arrays.fill()</a></li>
<li><a id="index_16-6-2" href="#第16章-6-2-数据生成器" aria-label="跳转到章节" title="跳转到章节">16.6.2 数据生成器</a></li>
<li><a id="index_16-6-3" href="#第16章-6-3-从Generator中创建数组" aria-label="跳转到章节" title="跳转到章节">16.6.3 从Generator中创建数组</a></li>
</ul>
</li>
<li><a id="index_16-7" href="#第16章-7-Arrays实用功能" aria-label="跳转到章节" title="跳转到章节">16.7 Arrays实用功能</a><ul>
<li><a id="index_16-7-1" href="#第16章-7-1-复制数组" aria-label="跳转到章节" title="跳转到章节">16.7.1 复制数组</a></li>
<li><a id="index_16-7-2" href="#第16章-7-2-数组的比较" aria-label="跳转到章节" title="跳转到章节">16.7.2 数组的比较</a></li>
<li><a id="index_16-7-3" href="#第16章-7-3-数组元素的比较" aria-label="跳转到章节" title="跳转到章节">16.7.3 数组元素的比较</a></li>
<li><a id="index_16-7-4" href="#第16章-7-4-数组排序" aria-label="跳转到章节" title="跳转到章节">16.7.4 数组排序</a></li>
<li><a id="index_16-7-5" href="#第16章-7-5-在已排序的数组中查找" aria-label="跳转到章节" title="跳转到章节">16.7.5 在已排序的数组中查找</a></li>
</ul>
</li>
<li><a id="index_16-8" href="#第16章-8-总结" aria-label="跳转到章节" title="跳转到章节">16.8 总结</a></li>
</ul>
</li>
<li><p><a id="index_17" href="#第17章-容器深入研究" aria-label="跳转到章节" title="跳转到章节">第17章 容器深入研究</a></p>
<ul>
<li><a id="index_17-1" href="#第17章-1-完整容器分类法" aria-label="跳转到章节" title="跳转到章节">17.1 完整容器分类法</a></li>
<li><a id="index_17-2" href="#第17章-2-填充容器" aria-label="跳转到章节" title="跳转到章节">17.2 填充容器</a><ul>
<li><a id="index_17-2-1" href="#第17章-2-1-一种Generator解决方案" aria-label="跳转到章节" title="跳转到章节">17.2.1 一种Generator解决方案</a></li>
<li><a id="index_17-2-2" href="#第17章-2-2-Map生成器" aria-label="跳转到章节" title="跳转到章节">17.2.2 Map生成器</a></li>
<li><a id="index_17-2-3" href="#第17章-2-3-使用Abstract类" aria-label="跳转到章节" title="跳转到章节">17.2.3 使用Abstract类</a></li>
</ul>
</li>
<li><a id="index_17-3" href="#第17章-3-Collection的功能方法" aria-label="跳转到章节" title="跳转到章节">17.3 Collection的功能方法</a></li>
<li><a id="index_17-4" href="#第17章-4-可选操作" aria-label="跳转到章节" title="跳转到章节">17.4 可选操作</a><ul>
<li><a id="index_17-4-1" href="#第17章-4-1-未获支持的操作" aria-label="跳转到章节" title="跳转到章节">17.4.1 未获支持的操作</a></li>
</ul>
</li>
<li><a id="index_17-5" href="#第17章-5-List的功能方法" aria-label="跳转到章节" title="跳转到章节">17.5 List的功能方法</a></li>
<li><a id="index_17-6" href="#第17章-6-Set和存储排序" aria-label="跳转到章节" title="跳转到章节">17.6 Set和存储排序</a><ul>
<li><a id="index_17-6-1" href="#第17章-6-1-SortedSet" aria-label="跳转到章节" title="跳转到章节">17.6.1 SortedSet</a></li>
</ul>
</li>
<li><a id="index_17-7" href="#第17章-7-队列" aria-label="跳转到章节" title="跳转到章节">17.7 队列</a><ul>
<li><a id="index_17-7-1" href="#第17章-7-1-优先级队列" aria-label="跳转到章节" title="跳转到章节">17.7.1 优先级队列</a></li>
<li><a id="index_17-7-2" href="#第17章-7-2-双向队列" aria-label="跳转到章节" title="跳转到章节">17.7.2 双向队列</a></li>
</ul>
</li>
<li><a id="index_17-8" href="#第17章-8-理解Map" aria-label="跳转到章节" title="跳转到章节">17.8 理解Map</a><ul>
<li><a id="index_17-8-1" href="#第17章-8-1-性能" aria-label="跳转到章节" title="跳转到章节">17.8.1 性能</a></li>
<li><a id="index_17-8-2" href="#第17章-8-2-SortedMap" aria-label="跳转到章节" title="跳转到章节">17.8.2 SortedMap</a></li>
<li><a id="index_17-8-3" href="#第17章-8-3-LinkedHashMap" aria-label="跳转到章节" title="跳转到章节">17.8.3 LinkedHashMap</a></li>
</ul>
</li>
<li><a id="index_17-9" href="#第17章-9-散列与散列码" aria-label="跳转到章节" title="跳转到章节">17.9 散列与散列码</a><ul>
<li><a id="index_17-9-1" href="#第17章-9-1-理解hashCode" aria-label="跳转到章节" title="跳转到章节">17.9.1 理解hashCode()</a></li>
<li><a id="index_17-9-2" href="#第17章-9-2-为速度而散列" aria-label="跳转到章节" title="跳转到章节">17.9.2 为速度而散列</a></li>
<li><a id="index_17-9-3" href="#第17章-9-3-覆盖hashCode" aria-label="跳转到章节" title="跳转到章节">17.9.3 覆盖hashCode()</a></li>
</ul>
</li>
<li><a id="index_17-10" href="#第17章-10-选择接口的不同实现" aria-label="跳转到章节" title="跳转到章节">17.10 选择接口的不同实现</a><ul>
<li><a id="index_17-10-1" href="#第17章-10-1-性能测试框架" aria-label="跳转到章节" title="跳转到章节">17.10.1 性能测试框架</a></li>
<li><a id="index_17-10-2" href="#第17章-10-2-对List的选择" aria-label="跳转到章节" title="跳转到章节">17.10.2 对List的选择</a></li>
<li><a id="index_17-10-3" href="#第17章-10-3-微基准测试的危险" aria-label="跳转到章节" title="跳转到章节">17.10.3 微基准测试的危险</a></li>
<li><a id="index_17-10-4" href="#第17章-10-4-对Set的选择" aria-label="跳转到章节" title="跳转到章节">17.10.4 对Set的选择</a></li>
<li><a id="index_17-10-5" href="#第17章-10-5-对Map的选择" aria-label="跳转到章节" title="跳转到章节">17.10.5 对Map的选择</a></li>
</ul>
</li>
<li><a id="index_17-11" href="#第17章-11-实用方法" aria-label="跳转到章节" title="跳转到章节">17.11 实用方法</a><ul>
<li><a id="index_17-11-1" href="#第17章-11-1-List的排序和查询" aria-label="跳转到章节" title="跳转到章节">17.11.1 List的排序和查询</a></li>
<li><a id="index_17-11-2" href="#第17章-11-2-设定Collection或Map为不可修改" aria-label="跳转到章节" title="跳转到章节">17.11.2 设定Collection或Map为不可修改</a></li>
<li><a id="index_17-11-3" href="#第17章-11-3-Collection或Map的同步控制" aria-label="跳转到章节" title="跳转到章节">17.11.3 Collection或Map的同步控制</a></li>
</ul>
</li>
<li><a id="index_17-12" href="#第17章-12-持有引用" aria-label="跳转到章节" title="跳转到章节">17.12 持有引用</a><ul>
<li><a id="index_17-12-1" href="#第17章-12-1-WeakHashMap" aria-label="跳转到章节" title="跳转到章节">17.12.1 WeakHashMap</a></li>
</ul>
</li>
<li><a id="index_17-13" href="#第17章-13-Java 1.0-1.1的容器" aria-label="跳转到章节" title="跳转到章节">17.13 Java 1.0-1.1的容器</a><ul>
<li><a id="index_17-13-1" href="#第17章-13-1-Vector和Enumeration" aria-label="跳转到章节" title="跳转到章节">17.13.1 Vector和Enumeration</a></li>
<li><a id="index_17-13-2" href="#第17章-13-2-Hashtable" aria-label="跳转到章节" title="跳转到章节">17.13.2 Hashtable</a></li>
<li><a id="index_17-13-3" href="#第17章-13-3-Stack" aria-label="跳转到章节" title="跳转到章节">17.13.3 Stack</a></li>
<li><a id="index_17-13-4" href="#第17章-13-4-BitSet" aria-label="跳转到章节" title="跳转到章节">17.13.4 BitSet</a></li>
</ul>
</li>
<li><a id="index_17-14" href="#第17章-14-总结" aria-label="跳转到章节" title="跳转到章节">17.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_18" href="#第18章-Java-IO系统" aria-label="跳转到章节" title="跳转到章节">第18章 Java IO系统</a></p>
<ul>
<li><a id="index_18-1" href="#第18章-1-File类" aria-label="跳转到章节" title="跳转到章节">18.1 File类</a><ul>
<li><a id="index_18-1-1" href="#第18章-1-1-目录列表器" aria-label="跳转到章节" title="跳转到章节">18.1.1 目录列表器</a></li>
<li><a id="index_18-1-2" href="#第18章-1-2-目录实用工具" aria-label="跳转到章节" title="跳转到章节">18.1.2 目录实用工具</a></li>
<li><a id="index_18-1-3" href="#第18章-1-3-目录的检查及创建" aria-label="跳转到章节" title="跳转到章节">18.1.3 目录的检查及创建</a></li>
</ul>
</li>
<li><a id="index_18-2" href="#第18章-2-输入（Input）和输出（Output）" aria-label="跳转到章节" title="跳转到章节">18.2 输入（Input）和输出（Output）</a><ul>
<li><a id="index_18-2-1" href="#第18章-2-1-InputStream类型" aria-label="跳转到章节" title="跳转到章节">18.2.1 InputStream类型</a></li>
<li><a id="index_18-2-2" href="#第18章-2-2-OutputStream类型" aria-label="跳转到章节" title="跳转到章节">18.2.2 OutputStream类型</a></li>
</ul>
</li>
<li><a id="index_18-3" href="#第18章-3-添加属性和有用的接口" aria-label="跳转到章节" title="跳转到章节">18.3 添加属性和有用的接口</a><ul>
<li><a id="index_18-3-1" href="#第18章-3-1-通过FilterInputStream从InputStream读取数据" aria-label="跳转到章节" title="跳转到章节">18.3.1 通过FilterInputStream从InputStream读取数据</a></li>
<li><a id="index_18-3-2" href="#第18章-3-2-通过FilterOutputStream从OutputStream写入" aria-label="跳转到章节" title="跳转到章节">18.3.2 通过FilterOutputStream从OutputStream写入</a></li>
</ul>
</li>
<li><a id="index_18-4" href="#第18章-4-Reader和Writer" aria-label="跳转到章节" title="跳转到章节">18.4 Reader和Writer</a><ul>
<li><a id="index_18-4-1" href="#第18章-4-1-数据的来源和去处（字节流和字符流类库的关联）" aria-label="跳转到章节" title="跳转到章节">18.4.1 数据的来源和去处（字节流和字符流类库的关联）</a></li>
<li><a id="index_18-4-2" href="#第18章-4-2-更改流的行为" aria-label="跳转到章节" title="跳转到章节">18.4.2 更改流的行为</a></li>
<li><a id="index_18-4-3" href="#第18章-4-3-未发生变化的类" aria-label="跳转到章节" title="跳转到章节">18.4.3 未发生变化的类</a></li>
</ul>
</li>
<li><a id="index_18-5" href="#第18章-5-自我独立的类：RandomAccessFile" aria-label="跳转到章节" title="跳转到章节">18.5 自我独立的类：RandomAccessFile</a></li>
<li><a id="index_18-6" href="#第18章-6-IO流的典型使用方式" aria-label="跳转到章节" title="跳转到章节">18.6 IO流的典型使用方式</a><ul>
<li><a id="index_18-6-1" href="#第18章-6-1-缓冲输入文件" aria-label="跳转到章节" title="跳转到章节">18.6.1 缓冲输入文件</a></li>
<li><a id="index_18-6-2" href="#第18章-6-2-从内存输入" aria-label="跳转到章节" title="跳转到章节">18.6.2 从内存输入</a></li>
<li><a id="index_18-6-3" href="#第18章-6-3-格式化的内存输入" aria-label="跳转到章节" title="跳转到章节">18.6.3 格式化的内存输入</a></li>
<li><a id="index_18-6-4" href="#第18章-6-4-基本的文件输出" aria-label="跳转到章节" title="跳转到章节">18.6.4 基本的文件输出</a></li>
<li><a id="index_18-6-5" href="#第18章-6-5-存储和恢复数据" aria-label="跳转到章节" title="跳转到章节">18.6.5 存储和恢复数据</a></li>
<li><a id="index_18-6-6" href="#第18章-6-6-随机读写访问文件" aria-label="跳转到章节" title="跳转到章节">18.6.6 随机读写访问文件</a></li>
<li><a id="index_18-6-7" href="#第18章-6-7-管道流" aria-label="跳转到章节" title="跳转到章节">18.6.7 管道流</a></li>
</ul>
</li>
<li><a id="index_18-7" href="#第18章-7-文件读写的实用工具" aria-label="跳转到章节" title="跳转到章节">18.7 文件读写的实用工具</a><ul>
<li><a id="index_18-7-1" href="#第18章-7-1-读取二进制文件" aria-label="跳转到章节" title="跳转到章节">18.7.1 读取二进制文件</a></li>
</ul>
</li>
<li><a id="index_18-8" href="#第18章-8-标准IO" aria-label="跳转到章节" title="跳转到章节">18.8 标准IO</a><ul>
<li><a id="index_18-8-1" href="#第18章-8-1-从标准输入中读取" aria-label="跳转到章节" title="跳转到章节">18.8.1 从标准输入中读取</a></li>
<li><a id="index_18-8-2" href="#第18章-8-2-将System.out转换成PrintWriter" aria-label="跳转到章节" title="跳转到章节">18.8.2 将System.out转换成PrintWriter</a></li>
<li><a id="index_18-8-3" href="#第18章-8-3-标准IO重定向" aria-label="跳转到章节" title="跳转到章节">18.8.3 标准IO重定向</a></li>
</ul>
</li>
<li><a id="index_18-9" href="#第18章-9-进程控制" aria-label="跳转到章节" title="跳转到章节">18.9 进程控制</a></li>
<li><a id="index_18-10" href="#第18章-10-新IO" aria-label="跳转到章节" title="跳转到章节">18.10 新IO</a><ul>
<li><a id="index_18" href="#第18章-10-1-转换数据" aria-label="跳转到章节" title="跳转到章节">18.10.1 转换数据</a></li>
<li><a id="index_18-10-2" href="#第18章-10-2-获取基本类型" aria-label="跳转到章节" title="跳转到章节">18.10.2 获取基本类型</a></li>
<li><a id="index_18-10-3" href="#第18章-10-3-视图缓冲器" aria-label="跳转到章节" title="跳转到章节">18.10.3 视图缓冲器</a></li>
<li><a id="index_18-10-4" href="#第18章-10-4-用缓冲器操纵数据" aria-label="跳转到章节" title="跳转到章节">18.10.4 用缓冲器操纵数据</a></li>
<li><a id="index_18-10-5" href="#第18章-10-5-缓冲器的细节" aria-label="跳转到章节" title="跳转到章节">18.10.5 缓冲器的细节</a></li>
<li><a id="index_18-10-6" href="#第18章-10-6-内存映射文件" aria-label="跳转到章节" title="跳转到章节">18.10.6 内存映射文件</a></li>
<li><a id="index_18-10-7" href="#第18章-10-7-文件加锁" aria-label="跳转到章节" title="跳转到章节">18.10.7 文件加锁</a></li>
</ul>
</li>
<li><a id="index_18-11" href="#第18章-11-压缩" aria-label="跳转到章节" title="跳转到章节">18.11 压缩</a><ul>
<li><a id="index_18-11-1" href="#第18章-11-1-用GZIP进行简单压缩" aria-label="跳转到章节" title="跳转到章节">18.11.1 用GZIP进行简单压缩</a></li>
<li><a id="index_18-11-2" href="#第18章-11-2-用Zip进行多文件保存" aria-label="跳转到章节" title="跳转到章节">18.11.2 用Zip进行多文件保存</a></li>
<li><a id="index_18-11-3" href="#第18章-11-3-Java档案文件" aria-label="跳转到章节" title="跳转到章节">18.11.3 Java档案文件</a></li>
</ul>
</li>
<li><a id="index_18-12" href="#第18章-12-对象序列化" aria-label="跳转到章节" title="跳转到章节">18.12 对象序列化</a><ul>
<li><a id="index_18-12-1" href="#第18章-12-1-寻找类" aria-label="跳转到章节" title="跳转到章节">18.12.1 寻找类</a></li>
<li><a id="index_18-12-2" href="#第18章-12-2-序列化的控制" aria-label="跳转到章节" title="跳转到章节">18.12.2 序列化的控制</a></li>
<li><a id="index_18-12-3" href="#第18章-12-3-使用“持久性”" aria-label="跳转到章节" title="跳转到章节">18.12.3 使用“持久性”</a></li>
</ul>
</li>
<li><a id="index_18-13" href="#第18章-13-XML" aria-label="跳转到章节" title="跳转到章节">18.13 XML</a></li>
<li><a id="index_18-14" href="#第18章-14-Preferences" aria-label="跳转到章节" title="跳转到章节">18.14 Preferences</a></li>
<li><a id="index_18-15" href="#第18章-15-总结" aria-label="跳转到章节" title="跳转到章节">18.15 总结</a></li>
</ul>
</li>
<li><p><a id="index_19" href="#第19章-枚举类型" aria-label="跳转到章节" title="跳转到章节">第19章 枚举类型</a></p>
<ul>
<li><a id="index_19-1" href="#第19章-1-基本enum特性" aria-label="跳转到章节" title="跳转到章节">19.1 基本enum特性</a><ul>
<li><a id="index_19-1-1" href="#第19章-1-1-将静态导入用于enum" aria-label="跳转到章节" title="跳转到章节">19.1.1 将静态导入用于enum</a></li>
</ul>
</li>
<li><a id="index_19-2" href="#第19章-2-向enum中添加新方法" aria-label="跳转到章节" title="跳转到章节">19.2 向enum中添加新方法</a><ul>
<li><a id="index_19-2-1" href="#第19章-2-1-覆盖enum的方法" aria-label="跳转到章节" title="跳转到章节">19.2.1 覆盖enum的方法</a></li>
</ul>
</li>
<li><a id="index_19-3" href="#第19章-3-switch语句中的enum" aria-label="跳转到章节" title="跳转到章节">19.3 switch语句中的enum</a></li>
<li><a id="index_19-4" href="#第19章-4-values-的神秘之处" aria-label="跳转到章节" title="跳转到章节">19.4 values()的神秘之处</a></li>
<li><a id="index_19-5" href="#第19章-5-实现而非继承" aria-label="跳转到章节" title="跳转到章节">19.5 实现而非继承</a></li>
<li><a id="index_19-6" href="#第19章-6-随机选取" aria-label="跳转到章节" title="跳转到章节">19.6 随机选取</a></li>
<li><a id="index_19-7" href="#第19章-7-使用接口组织枚举" aria-label="跳转到章节" title="跳转到章节">19.7 使用接口组织枚举</a></li>
<li><a id="index_19-8" href="#第19章-8-使用EnumSet替代标志" aria-label="跳转到章节" title="跳转到章节">19.8 使用EnumSet替代标志</a></li>
<li><a id="index_19-9" href="#第19章-9-使用EnumMap" aria-label="跳转到章节" title="跳转到章节">19.9 使用EnumMap</a></li>
<li><a id="index_19-10" href="#第19章-10-常量相关的方法（枚举类的抽象方法）" aria-label="跳转到章节" title="跳转到章节">19.10 常量相关的方法（枚举类的抽象方法）</a><ul>
<li><a id="index_19-10-1" href="#第19章-10-1-使用enum的职责链" aria-label="跳转到章节" title="跳转到章节">19.10.1 使用enum的职责链</a></li>
<li><a id="index_19-10-2" href="#第19章-10-2-使用enum的状态机" aria-label="跳转到章节" title="跳转到章节">19.10.2 使用enum的状态机</a></li>
</ul>
</li>
<li><a id="index_19-11" href="#第19章-11-多路分发" aria-label="跳转到章节" title="跳转到章节">19.11 多路分发</a><ul>
<li><a id="index_19-11-1" href="#第19章-11-1-使用enum分发" aria-label="跳转到章节" title="跳转到章节">19.11.1 使用enum分发</a></li>
<li><a id="index_19-11-2" href="#第19章-11-2-使用常量相关的方法" aria-label="跳转到章节" title="跳转到章节">19.11.2 使用常量相关的方法</a></li>
<li><a id="index_19-11-3" href="#第19章-11-3-使用EnumMap分发" aria-label="跳转到章节" title="跳转到章节">19.11.3 使用EnumMap分发</a></li>
<li><a id="index_19-11-4" href="#第19章-11-4-使用二维数组" aria-label="跳转到章节" title="跳转到章节">19.11.4 使用二维数组</a></li>
</ul>
</li>
<li><a id="index_19-12" href="#第19章-12-总结" aria-label="跳转到章节" title="跳转到章节">19.12 总结</a></li>
</ul>
</li>
<li><p><a id="index_20" href="#第20章-注解" aria-label="跳转到章节" title="跳转到章节">第20章 注解</a></p>
<ul>
<li><a id="index_20-1" href="#第20章-1-基本语法" aria-label="跳转到章节" title="跳转到章节">20.1 基本语法</a><ul>
<li><a id="index_20-1-1" href="#第20章-1-1-定义注解" aria-label="跳转到章节" title="跳转到章节">20.1.1 定义注解</a></li>
<li><a id="index_20-1-2" href="#第20章-1-2-元注解" aria-label="跳转到章节" title="跳转到章节">20.1.2 元注解</a></li>
</ul>
</li>
<li><a id="index_20-2" href="#第20章-2-编写注解处理器" aria-label="跳转到章节" title="跳转到章节">20.2 编写注解处理器</a><ul>
<li><a id="index_20-2-1" href="#第20章-2-1-注解元素" aria-label="跳转到章节" title="跳转到章节">20.2.1 注解元素</a></li>
<li><a id="index_20-2-2" href="#第20章-2-2-默认值限制" aria-label="跳转到章节" title="跳转到章节">20.2.2 默认值限制</a></li>
<li><a id="index_20-2-3" href="#第20章-2-3-生成外部文件" aria-label="跳转到章节" title="跳转到章节">20.2.3 生成外部文件</a></li>
<li><a id="index_20-2-4" href="#第20章-2-4-注解不支持继承" aria-label="跳转到章节" title="跳转到章节">20.2.4 注解不支持继承</a></li>
<li><a id="index_20-2-5" href="#第20章-2-5-实现处理器" aria-label="跳转到章节" title="跳转到章节">20.2.5 实现处理器</a></li>
</ul>
</li>
<li><a id="index_20-3" href="#第20章-3-使用apt处理注解" aria-label="跳转到章节" title="跳转到章节">20.3 使用apt处理注解</a></li>
<li><a id="index_20-4" href="#第20章-4-将观察者模式用于apt" aria-label="跳转到章节" title="跳转到章节">20.4 将观察者模式用于apt</a></li>
<li><a id="index_20-5" href="#第20章-5-基于注解的单元测试" aria-label="跳转到章节" title="跳转到章节">20.5 基于注解的单元测试</a><ul>
<li><a id="index_20-5-1" href="#第20章-5-1-将-Unit用于泛型" aria-label="跳转到章节" title="跳转到章节">20.5.1 将@Unit用于泛型</a></li>
<li><a id="index_20-5-2" href="#第20章-5-2-不需要任何“套件”" aria-label="跳转到章节" title="跳转到章节">20.5.2 不需要任何“套件”</a></li>
<li><a id="index_20-5-3" href="#第20章-5-3-实现-Unit" aria-label="跳转到章节" title="跳转到章节">20.5.3 实现@Unit</a></li>
<li><a id="index_20-5-4" href="#第20章-5-4-移除测试代码" aria-label="跳转到章节" title="跳转到章节">20.5.4 移除测试代码</a></li>
</ul>
</li>
<li><a id="index_20-6" href="#第20章-6-总结" aria-label="跳转到章节" title="跳转到章节">20.6 总结</a></li>
</ul>
</li>
<li><p><a id="index_21" href="#第21章-并发" aria-label="跳转到章节" title="跳转到章节">第21章 并发</a></p>
<ul>
<li><a id="index_21-1" href="#第21章-1-并发的多面性" aria-label="跳转到章节" title="跳转到章节">21.1 并发的多面性</a></li>
<li><a id="index_21-2" href="#第21章-2-基本的线程机制" aria-label="跳转到章节" title="跳转到章节">21.2 基本的线程机制</a></li>
<li><a id="index_21-3" href="#第21章-3-共享受限资源" aria-label="跳转到章节" title="跳转到章节">21.3 共享受限资源</a></li>
<li><a id="index_21-4" href="#第21章-4-终结任务" aria-label="跳转到章节" title="跳转到章节">21.4 终结任务</a></li>
<li><a id="index_21-5" href="#第21章-5-线程之间的协作" aria-label="跳转到章节" title="跳转到章节">21.5 线程之间的协作</a></li>
<li><a id="index_21-6" href="#第21章-6-死锁" aria-label="跳转到章节" title="跳转到章节">21.6 死锁</a></li>
<li><a id="index_21-7" href="#第21章-7-新类库中的构件" aria-label="跳转到章节" title="跳转到章节">21.7 新类库中的构件</a></li>
<li><a id="index_21-8" href="#第21章-8-仿真" aria-label="跳转到章节" title="跳转到章节">21.8 仿真</a></li>
<li><a id="index_21-9" href="#第21章-9-性能调优" aria-label="跳转到章节" title="跳转到章节">21.9 性能调优</a></li>
<li><a id="index_21-10" href="#第21章-10-活动对象" aria-label="跳转到章节" title="跳转到章节">21.10 活动对象</a></li>
<li><a id="index_21-11" href="#第21章-11-总结" aria-label="跳转到章节" title="跳转到章节">21.11 总结</a></li>
</ul>
</li>
<li><p><a id="index_22" href="#第22章-图形化用户界面" aria-label="跳转到章节" title="跳转到章节">第22章 图形化用户界面</a></p>
</li>
</ol>
<hr>
<h1 id="第1章-面向对象导论"><a href="#第1章-面向对象导论" class="headerlink" title="第1章 面向对象导论"></a><a href="#index_1">第1章 面向对象导论</a></h1><h2 id="面向对象程序设计（Object-oriend-Programming，OOP）。"><a href="#面向对象程序设计（Object-oriend-Programming，OOP）。" class="headerlink" title="面向对象程序设计（Object-oriend Programming，OOP）。"></a><strong>面向对象程序设计</strong>（Object-oriend Programming，<strong>OOP</strong>）。</h2><p>本章将介绍包括开发方法概述在内的&thinsp;OOP&thinsp;的基本概念。</p>
<p>相关资料：🗎<sup id="cite_ref-1"><em><font color="#808080">[</font><a href="#cite_note-1">1</a><font color="#808080">]</font></em></sup>🗎<sup id="cite_ref-2"><em><font color="#808080">[</font><a href="#cite_note-2">2</a><font color="#808080">]</font></em></sup></p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>面向对象程序设计（OOP）是一种具有<strong>对象</strong>概念的<u>程序编程规范</u>，同时也是一种程序开发的<strong>抽象</strong>方针。</p>
<ul>
<li>它可以包含<strong>数据</strong>、<strong>属性</strong>、<strong>代码</strong>&thinsp;与&thinsp;<strong>方法</strong>。</li>
<li>在面向对象程序设计（OOP）中，计算机程序会被设计成彼此相关的&thinsp;<strong>对象</strong>。</li>
<li>这种在程序中包含各种独立而又相互调用的对象的思想，与传统编程思想正好相反：传统的程序设计主张把程序看成一系列函数的集合，或者直接对计算机下达的指令。</li>
<li>OOP&thinsp;中的每个对象都应该能接受和处理数据，并且能将数据传达给其他对象。</li>
<li>OOP = <strong>对象</strong> + <strong>类</strong> + <strong>继承</strong> + <strong>多态</strong> + <strong>消息</strong>，其中的核心概念是类和对象。<ul>
<li>其中，<strong>对象</strong>&thinsp;指的是&thinsp;<strong>类的实例</strong>。</li>
<li>对象是程序的基本单元，将程序的数据封装在其中，以提高软件的重用性、灵活性和拓展性。对象里的程序可以访问和修改该对象相关联的数据。</li>
</ul>
</li>
</ul>
<h3 id="主要特征：封装性、继承性、多态性"><a href="#主要特征：封装性、继承性、多态性" class="headerlink" title="主要特征：封装性、继承性、多态性"></a>主要特征：封装性、继承性、多态性</h3><ol>
<li><p><strong>封装性</strong>：封装是指将计算机程序的数据，以及此数据相关的一切操作语言（即描述对象的属性和行为的代码）组装到一起，一并封装到一个有机实体（也就是“类”）中。</p>
<ul>
<li>封装的最基本单位是对象。</li>
<li>封装增强了软件结构的模块性，是软件在结构上实现“<strong>高内聚</strong>，<strong>低耦合</strong>”的基础。</li>
<li>封装的原则：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li>
<li>封装的好处：<ul>
<li>（1）<strong>高内聚</strong>：将变化隔离，提高安全性；</li>
<li>（2）<strong>低耦合</strong>：便于使用，提高重用性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>继承性</strong>：继承是一种多种类之间的联系和区别关系。在面向对象中，继承是指一类对象针对另一类对象的某些特点和能力进行复制或者延续。</p>
<ul>
<li>父类又称为基类、超类；子类又称为派生类。子类可以直接访问父类中的非私有的属性和行为。关键字为<code>extends</code>。</li>
<li>按照继承源进行划分，继承可以分为单继承和多继承。</li>
<li>按照继承中包含的内容进行划分，继承可以分为4类，分别为取代继承、包含继承、受限继承、特化继承。</li>
<li>继承的好处：</li>
</ul>
</li>
<li><p><strong>多态性</strong>：在面向对象技术中——</p>
<ul>
<li>从宏观角度来讲，多态是指当不同的对象同时接收到同一个完全相同的消息时，所表现出来的动作是各不相同的，具有多种形态。</li>
<li>从微观角度来讲，多态是指在一个类中，调用同一个函数名，使用不同的参数（注：参数列表，包括参数数量和参数类型），得到不同的执行效果。</li>
<li>多态实现的前提条件：<ul>
<li>（1）有<strong>继承</strong>关系；</li>
<li>（2）有方法<strong>重写</strong>；</li>
<li>（3）有<strong>父类引用指向子类对象</strong>。</li>
</ul>
</li>
<li>多态有三种体现形式：<ul>
<li>（1）类多态；</li>
<li>（2）抽象类多态；</li>
<li>（3）接口多态。</li>
</ul>
</li>
<li>多态的优点：提高软件的<u>拓展性</u>和<u>可维护性</u>。</li>
<li>多态的缺点（？）：父类引用不能使用子类特有的功能。</li>
<li>多态在类型转换中的体现：<ul>
<li>（1）<u>基本类型：隐式转换（小到大），强制转换（大到小）</u>；</li>
<li>（2）<u>引用类型：向上转型（小到大），向下转型（大到小）</u>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h3><p>面向对象出现以前，结构化程序设计是程序设计的主流，结构化程序设计又称为<u>面向过程</u>的程序设计。在面向过程程序设计中，问题被看作一系列需要完成的任务，函数（在此泛指例程、函数、过程）用于完成这些任务，解决问题的焦点集中于函数。其中函数是面向过程的，即它关注如何根据规定的条件完成指定的任务。</p>
<p>比较面向对象程序设计和面向过程程序设计，还可以得到面向对象程序设计的其他优点：</p>
<ol>
<li>数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少甚至避免对外界的干扰；</li>
<li>通过继承大幅减少冗余的代码，并可以方便地扩展现有代码，提高编码效率，也减低了出错概率，降低软件维护的难度；</li>
<li>结合面向对象分析、面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中中间环节的转换过程；</li>
<li>通过对对象的辨别、划分可以将软件系统分割为若干相对为独立的部分，在一定程度上更便于控制<u>软件复杂度</u>；</li>
<li>以对象为中心的设计可以帮助开发人员从静态（属性）和动态（方法）两个方面把握问题，从而更好地实现系统；</li>
<li>通过对象的聚合、联合可以在保证封装与抽象的原则下实现对象在内在结构以及外在功能上的扩充，从而实现对象由低到高的升级。</li>
</ol>
<h3 id="设计缺陷"><a href="#设计缺陷" class="headerlink" title="设计缺陷"></a>设计缺陷</h3><ol>
<li><p>运行效率较低。</p>
<blockquote>
<p>类的大量加载会牺牲系统性能，降低运行速度。虽然CPU速度在提高，内存容量在增加，但这一问题仍会随着系统规模变大而逐渐显示出来，变得越发严重。</p>
</blockquote>
</li>
<li><p>类库庞大。</p>
<blockquote>
<p>由于类库都过于庞大，程序员对它们的掌握需要一段时间，从普及、推广的角度来看，类库应在保证其功能完备的基础上进行相应的缩减。</p>
</blockquote>
</li>
<li><p>类库可靠性。</p>
<blockquote>
<p>越庞大的系统必会存在我们无法预知的问题隐患，程序员无法完全保证类库中的每个类在各种环境中百分之百的正确，当使用的类发生了问题，就会影响后续工作，程序员也有可能推翻原来的全部工作。</p>
</blockquote>
</li>
</ol>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p>面向对象程序设计中的概念主要包括：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递。通过这些概念面向对象的思想得到了具体的体现。</p>
<ul>
<li><p>（1）对象（Object）：</p>
<blockquote>
<p>可以对其做事情的一些东西。对象有3种属性：状态、行为、标识。</p>
</blockquote>
</li>
<li><p>（2）类（Class）：</p>
<blockquote>
<p>一个共享相同结构和行为的对象的集合。类（Class）定义了一件事物的抽象特点。通常来说，类定义了事物的属性和它可以做到的（它的行为）。举例来说，“狗”这个类会包含狗的一切基础特征，例如它的孕育、毛皮颜色和吠叫的能力。类可以为程序提供模版和结构。一个类的方法和属性被称为“成员”。</p>
</blockquote>
</li>
<li><p>（3）封装（Encapsulation）：</p>
<blockquote>
<p>第一层意思：将数据和操作捆绑在一起，创造出一个新的类型的过程。第二层意思：将接口与实现分离的过程。</p>
</blockquote>
</li>
<li><p>（4）继承：</p>
<blockquote>
<p>类之间的关系，在这种关系中，一个类共享了一个或多个其他类定义的结构和行为。继承描述了类之间的“是一种”关系。子类可以对基类的行为进行扩展、覆盖、重定义。</p>
</blockquote>
</li>
<li><p>（5）组合：</p>
<blockquote>
<p>既是类之间的关系也是对象之间的关系。在这种关系中一个对象或者类包含了其他的对象和类。</p>
</blockquote>
</li>
<li><p>（6）多态：</p>
<blockquote>
<p>类型理论中的一个概念，一个名称可以表示很多不同类的对象，这些类和一个共同超类有关。因此，这个名称表示的任何对象可以以不同的方式响应一些共同的操作集合。</p>
</blockquote>
</li>
<li><p>（7）动态绑定：</p>
<blockquote>
<p>也称动态类型，指的是一个对象或者表达式的类型直到运行时才确定。通常由编译器插入特殊代码来实现。与之对立的是静态类型。</p>
</blockquote>
</li>
<li><p>（8）静态绑定：</p>
<blockquote>
<p>也称静态类型，指的是一个对象或者表达式的类型在编译时确定。</p>
</blockquote>
</li>
<li><p>（9）消息传递：</p>
<blockquote>
<p>指的是一个对象调用了另一个对象的方法（或者称为成员函数）。</p>
</blockquote>
</li>
<li><p>（10）方法：</p>
<blockquote>
<p>也称为成员函数，是指对象上的操作，作为类声明的一部分来定义。方法定义了可以对一个对象执行那些操作。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="第1章-1-抽象过程"><a href="#第1章-1-抽象过程" class="headerlink" title="第1章-1 抽象过程"></a><a href="#index_1-1">第1章-1 抽象过程</a></h2><p>所有编程语言都提供抽象机制。可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。所谓的“类型”指的是“所抽象的是什么”。</p>
<p>汇编语言是对底层机器的轻微抽象。接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。……</p>
<p>另一种对机器建模的方式就是只针对待解决问题建模。……</p>
<p>面向对象方式通过向程序员提供表示问题空间中的元素的工具而更近了一步。……</p>
<p>Alan Kay&thinsp;曾经总结了第一个[成功的面向对象语言、同时也是&thinsp;Java&thinsp;所基于的语言之一的&thinsp;Smalltalk&thinsp;的]五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：</p>
<ul>
<li>(1)&ensp;<strong>万物皆为对象</strong>。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件（示例：狗、建筑物、服务等），将其表示为程序中的对象。</li>
<li>(2)&ensp;<strong>程序是对象的集合，它们通过发送消息来告知彼此所要做的</strong>。……</li>
<li>(3)&ensp;<strong>每个对象都有自己的由其他对象所构成的存储</strong>。……</li>
<li>(4)&ensp;<strong>每个对象都拥有其类型</strong>。……</li>
<li>(5)&ensp;<strong>某一特定类型的所有对象都可以接收同样的消息</strong>。……</li>
</ul>
<p>Booch&thinsp;对&thinsp;对象&thinsp;提供了一个更加简洁的描述：<font color="#2b72ee"><strong>对象具有状态、行为和标识</strong></font>。<br>这意味着每一个对象都可以拥有<strong>内部数据</strong>（它们给出了该&thinsp;<strong>对象的状态</strong>）和<strong>方法</strong>（它们产生&thinsp;<strong>对象的行为</strong>），并且每一个对象都可以唯一地与其他对象区分开来（<strong>标识</strong>），具体说来，就是<span class="hint--info hint--rounded hint--top" data-hint="狭义说法；广义来说，
因为对象可以存在于不同的机器和地址空间中，它们还可以被存储在硬盘上。
在这些情况下，对象的标识就必须由内存之外的某些东西来确定。" ontouchstart>每一个对象在其内存中都有一个唯一的地址</span>。</p>
<h2 id="第1章-2-每个对象都有一个接口"><a href="#第1章-2-每个对象都有一个接口" class="headerlink" title="第1章-2 每个对象都有一个接口"></a><a href="#index_1-2">第1章-2 每个对象都有一个接口</a></h2><p>亚里士多德是第一个深入研究类型（type）的哲学家，他曾提出过鱼类和鸟类这样的概念。<u>所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所属的类的一部分</u>。这种思想被直接应用于第一个面向对象语言&thinsp;Simula-67，它在程序中使用基本关键字<code>class</code>来引入新的类型。</p>
<p>Simula，就像其名字一样，是为了开发诸如经典的“银行出纳员问题”（bank teller problem）这样的仿真程序而创建的。……</p>
<p>所以，尽管我们在面向对象程序设计中实际上进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用<code>class</code>这个关键词来表示数据类型。……<br>因为<u>类（class）描述了相同特性（数据元素）和行为（功能）的对象集合</u>，所以一个类（class）实际上就是一个数据类型，例如所有的浮点型数字都具有相同的特性和行为集合。……<br>……</p>
<p>UML（Unified Modelling Language，统一建模语言）形式的图，……</p>
<h2 id="第1章-3-每个对象都提供服务"><a href="#第1章-3-每个对象都提供服务" class="headerlink" title="第1章-3 每个对象都提供服务"></a><a href="#index_1-3">第1章-3 每个对象都提供服务</a></h2><p>……</p>
<h2 id="第1章-4-被隐藏的具体实现"><a href="#第1章-4-被隐藏的具体实现" class="headerlink" title="第1章-4 被隐藏的具体实现"></a><a href="#index_1-4">第1章-4 被隐藏的具体实现</a></h2><p>将程序开发人员按照角色分为类创建者（创建新数据类型的程序员）和<span class="hint--info hint--rounded hint--top" data-hint="This description is from Scott Meyers" ontouchstart>客户端程序员</span>（在应用程序中使用数据类型的类消费者）是大有裨益的。客户端程序员的目标，是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，同时隐藏其他部分。构建类的只向客户端程序员暴露必需部分而隐藏其他部分的设计，能保证类的稳定安全，避免人为攻击，减少程序&thinsp;Bug。</p>
<p>明确边界：在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。……</p>
<p>因此，访问控制的存在原因：</p>
<ul>
<li>（1）让客户端程序员无法触及他们不应该接触的部分&thinsp;——&thinsp;这部分对数据类型的内部操作是必需的，但是对于解决问题所需的接口的一部分。</li>
<li>（2）允许库设计者可以改变&thinsp;<u>类内部</u>&thinsp;的工作方式，同时不用担心会影响到客户端程序员。<blockquote>
<p>Java&thinsp;用3个关键字在类的内部设定边界：<font color="#2b72ee"><strong>public</strong></font>，<font color="#2b72ee"><strong>private</strong></font>，<font color="#2b72ee"><strong>protected</strong></font>。这些<strong>访问指定词</strong>（access specifier）决定了紧跟其后被定义的东西可以被谁使用。……<br>Java&thinsp;还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为&thinsp;<strong>包访问权限</strong>，在这种权限下，类可以访问在同一个包中的其他类的成员。</p>
</blockquote>
</li>
</ul>
<h2 id="第1章-5-复用具体实现"><a href="#第1章-5-复用具体实现" class="headerlink" title="第1章-5 复用具体实现"></a><a href="#index_1-5">第1章-5 复用具体实现</a></h2><p>一旦类被设计创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。……。<strong>代码复用</strong>是面向对象程序设计语言提供的最了不起的优点之一。</p>
<p>最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为“创建一个成员对象”。新的类可以由任意数量、任意类型的其他对象，以任意可以实现新的类中想要的功能的方式所组成。……</p>
<p>……</p>
<h2 id="第1章-6-继承"><a href="#第1章-6-继承" class="headerlink" title="第1章-6 继承"></a><a href="#index_1-6">第1章-6 继承</a></h2><p>对象这种概念，本身就是十分方便的工具，方便你通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于&thinsp;必须使用底层机器语言。这些概念用关键字<code>class</code>来表示，它们形成了编程语言中的基本单位。</p>
<p>当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括&thinsp;<strong>现有类型的所有成员</strong>（尽管<code>private</code>成员被隐藏了起来，并且不可被访问），而且更重要的是它复制了&thinsp;<strong>基类的接口</strong>。也就是说，所有可以发送给基类对象的消息同时也能发送给派生类对象。由于通过发送给类的消息类型可以判断类的类型，所以派生类与基类具有相同的类型。</p>
<p>……</p>
<h3 id="第1章-6-1-“是一个”与“像是一个”的关系"><a href="#第1章-6-1-“是一个”与“像是一个”的关系" class="headerlink" title="第1章-6-1 “是一个”与“像是一个”的关系"></a><a href="#index_1-6-1">第1章-6-1 “是一个”与“像是一个”的关系</a></h3><p>对于继承可能会引发某些争论：继承是否应该只覆盖基类的方法，而并不添加在基类中没有的新方法？</p>
<p>略<del>（原文此处论述太过智障）</del>。</p>
<h2 id="第1章-7-伴随多态的可互换对象"><a href="#第1章-7-伴随多态的可互换对象" class="headerlink" title="第1章-7 伴随多态的可互换对象"></a><a href="#index_1-7">第1章-7 伴随多态的可互换对象</a></h2><p>在处理类型的层次结构时，经常想把一个对象不当作的它所属的特定类型来看待，而是将其当作其基类的对象来处理。这使得程序员可以编写出不依赖于特定类型的代码。</p>
<p><strong>泛化</strong>（<strong>generic</strong>），涉及到<strong>向上转型</strong>。<br>泛化处理的负面作用是导致编译器无法明确实际执行的代码，而代码的执行只能在编译完成后运行时才能确定。</p>
<p>因为面向对象程序设计语言使用了&thinsp;<strong>后期绑定</strong>&thinsp;的概念——当向对象发送消息时，被调用的代码直到运行时才能确定：编译器确保被调用的方法的存在，并对调用参数和返回值执行类型检查（<u>无法提供此类语言保证的语言</u>被称为&thinsp;<strong>弱类型语言</strong>），但是不能确定将被执行的确切代码。</p>
<p>为了执行&thinsp;<strong>后期绑定</strong>，Java&thinsp;使用一小段特殊的代码来<u>替代绝对地址调用</u>。这段代码<u>使用在对象中存储的信息来计算方法体的地址</u>（这个过程将在第八章中体现）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道通过这条消息应该做什么。</p>
<p>在某些语言中，必须明确地声明某个方法具备后期绑定属性所带来的灵活性（C++是使用virtual关键字来实现的）。在这些语言中，方法在默认情况下不是<strong>动态绑定</strong>的。而<u>在&thinsp;Java&thinsp;中，动态绑定是默认行为</u>，不需要添加额外的关键字来实现多态。</p>
<p>示例：多态的表现 - 示例</p>
<h2 id="第1章-8-单根继承结构"><a href="#第1章-8-单根继承结构" class="headerlink" title="第1章-8 单根继承结构"></a><a href="#index_1-8">第1章-8 单根继承结构</a></h2><blockquote>
<p>在&thinsp;OOP（面向对象编程）中，自&thinsp;C++&thinsp;面世以来就令人关注的一个问题：是否所有的类最终都继承自同一个基类。<br>在&thinsp;Java&thinsp;中（事实上还包括&thinsp;C++&thinsp;以外的所有&thinsp;OOP&thinsp;语言），答案是&thinsp;yes<div style="display:inline-block;margin-bottom:-18px;"> <img src="/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/Chapter1-8__All_classes_derived_from_java-lang-Object.jpg" class="" width="190" height="60" title="String也属于Object"> </div>&ensp;<div style="display:inline-block;margin-bottom:-18px;"> <img src="/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/Chapter1-8__String_belongTo_Object.jpg" class="" width="130" height="60" title="String也属于Object"> </div>，这个终极基类是&thinsp;<code>Object</code>。</p>
</blockquote>
<p>事实证明，<font color="#009100">单根继承结构</font>&thinsp;带来了很多好处。</p>
<p>在&thinsp;<font color="#009100">单根继承结构</font>&thinsp;中，所有对象都具有一个共用接口，所以它们归根结底都是相同的基本类型。</p>
<ul>
<li><p><font color="#009100"><strong>单根继承结构</strong></font>&thinsp;保证<u>所有对象都具备某些功能</u>，可以在每个对象上执行基本操作。所有对象<u>都很容易地在[&thinsp;堆（Heap）]上创建</u>，同时&thinsp;<strong>参数的传递</strong>&thinsp;也被极大地简化。</p>
</li>
<li><p><font color="#009100"><strong>单根继承结构</strong></font>&thinsp;使得<u>垃圾回收器的实现变得容易很多</u>，而垃圾回收器正是&thinsp;Java&thinsp;相对&thinsp;C++&thinsp;的重要改进之一。由于<u>所有对象都保证具有其自身的类型信息</u>，因此不会因为无法确定对象的类型而陷入僵局；这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。</p>
</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>在另一种（C++所提供的）非单根继承结构中……</span></div>
    <div class="xContent"><div class="inner">
        <p>在另一种（C++所提供的）<strong>非单根继承结构</strong>中，无法确保所有的对象都属于同一个基本类型，从向后兼容的角度来看，这么做能够更好地适应C模型，且受限较少；除此以外不值得……</p>
 
    </div></div>
    </div>

<h2 id="第1章-9-容器"><a href="#第1章-9-容器" class="headerlink" title="第1章-9 容器"></a><a href="#index_1-9">第1章-9 容器</a></h2><h3 id="第1章-9-1-参数化类型"><a href="#第1章-9-1-参数化类型" class="headerlink" title="第1章-9-1 参数化类型"></a><a href="#index_1-9-1">第1章-9-1 参数化类型</a></h3><h2 id="第1章-10-对象的创建和生命周期"><a href="#第1章-10-对象的创建和生命周期" class="headerlink" title="第1章-10 对象的创建和生命周期"></a><a href="#index_1-10">第1章-10 对象的创建和生命周期</a></h2><h2 id="第1章-11-异常处理：错误处理"><a href="#第1章-11-异常处理：错误处理" class="headerlink" title="第1章-11 异常处理：错误处理"></a><a href="#index_1-11">第1章-11 异常处理：错误处理</a></h2><h2 id="第1章-12-并发编程"><a href="#第1章-12-并发编程" class="headerlink" title="第1章-12 并发编程"></a><a href="#index_1-12">第1章-12 并发编程</a></h2><h2 id="第1章-13-Java与Internet"><a href="#第1章-13-Java与Internet" class="headerlink" title="第1章-13 Java与Internet"></a><a href="#index_1-13">第1章-13 Java与Internet</a></h2><h3 id="第1章-13-1-Web是什么"><a href="#第1章-13-1-Web是什么" class="headerlink" title="第1章-13-1 Web是什么"></a><a href="#index_1-13-1">第1章-13-1 Web是什么</a></h3><h3 id="第1章-13-2-客户端编程"><a href="#第1章-13-2-客户端编程" class="headerlink" title="第1章-13-2 客户端编程"></a><a href="#index_1-13-2">第1章-13-2 客户端编程</a></h3><h3 id="第1章-13-3-服务器端编程"><a href="#第1章-13-3-服务器端编程" class="headerlink" title="第1章-13-3 服务器端编程"></a><a href="#index_1-13-3">第1章-13-3 服务器端编程</a></h3><h2 id="第1章-14-总结"><a href="#第1章-14-总结" class="headerlink" title="第1章-14 总结"></a><a href="#index_1-14">第1章-14 总结</a></h2><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a><a href="#index_2">第2章 一切都是对象</a></h1><h2 id="第2章-1-用引用操纵对象"><a href="#第2章-1-用引用操纵对象" class="headerlink" title="第2章-1 用引用操纵对象"></a><a href="#index_2-1">第2章-1 用引用操纵对象</a></h2><blockquote>
<p>每种编程语言都会有自己的操纵内存中元素的方式。很多时候，程序员必须注意将要处理的数据是什么类型。是选择直接操纵元素，还是用某种基于特殊语法的间接表示（）来操纵对象？</p>
<p>所有这一切在&thinsp;Java&thinsp;里得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操纵的标识符实际上是对象的一个“引用”（<code>reference</code>）</p>
</blockquote>
<h2 id="第2章-2-必须由你创建所有对象【底层存储】"><a href="#第2章-2-必须由你创建所有对象【底层存储】" class="headerlink" title="第2章-2 必须由你创建所有对象【底层存储】"></a><a href="#index_2-2">第2章-2 必须由你创建所有对象【底层存储】</a></h2><p>一旦创建了一个引用，我们通常希望它能够与一个新的对象关联。<br>通常使用<code>new</code>操作符来实现这一目的。<code>new</code>关键字的意思是“分配一个新对象”。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(“abcdef”);</span><br></pre></td></tr></table></figure>

<p>上述代码不仅表示“分配一个新的字符串”，还通过给构造方法提供的初始字符串，确定了如何构建这个<code>String</code>对象的信息。</p>
<p>这是&thinsp;Java&thinsp;程序设计中的一项基本行为。</p>
</blockquote>
<h3 id="第2章-2-1-存储到什么地方【对象的存储】"><a href="#第2章-2-1-存储到什么地方【对象的存储】" class="headerlink" title="第2章-2-1 存储到什么地方【对象的存储】"></a><a href="#index_2-2-1">第2章-2-1 存储到什么地方【对象的存储】</a></h3><div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>程序运行时……</span></div>
    <div class="xContent"><div class="inner">
        <p>程序运行时，对象是怎么进行存放安排的呢？特别是内存是怎样分配的呢？<br>对这些方面的了解对程序员会有很大的帮助。</p>
 
    </div></div>
    </div>

<p>有五个不同的地方可以存储数据：</p>
<ol>
<li><h4 id="寄存器。"><a href="#寄存器。" class="headerlink" title="寄存器。"></a><font color="#ff3333"><strong>寄存器</strong></font>。</h4><p>位于处理器内部。</p>
<blockquote>
<p>这是最快的存储区。因为它位于不同于其他存储区的地方&thinsp;——&thinsp;<strong>处理器内部</strong>。但是寄存器的数量极其有限，所以寄存器根据需求进行分配，且&thinsp;Java&thinsp;不允许程序员直接或间接地控制寄存器，甚至屏蔽寄存器的存在概念。（另一方面，C&thinsp;和&thinsp;C++&thinsp;允许程序员向编译器建议寄存器的分配方式）</p>
</blockquote>
</li>
<li><h4 id="堆栈（Heap）。"><a href="#堆栈（Heap）。" class="headerlink" title="堆栈（Heap）。"></a><font color="#ff3333"><strong>堆栈</strong></font>（<font color="#ff3333"><strong>Heap</strong></font>）。</h4><p>位于通用&thinsp;<u><strong>RAM</strong>（随机访问存储器）</u>&thinsp;中。</p>
<blockquote>
<ul>
<li>通过&thinsp;<font color="#2121FF"><strong>堆栈指针</strong></font>&thinsp;可以从处理器那里获得直接支持。<strong>堆栈指针</strong>，若向下移动，则<u>分配</u>新的内存；若向上移动，则<u>释放</u>已分配的内存。</li>
<li><font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）是一个快速存储区域，存取效率仅次于寄存器。</li>
<li><strong><font color="#6AA84F">堆栈</font>（<font color="#6AA84F"><strong>Heap</strong></font>）中存放的数据</strong>&thinsp;必须明确其&thinsp;<strong>数据大小</strong>&thinsp;和&thinsp;<strong>生命周期</strong>&thinsp;，导致&thinsp;堆栈（Heap）区&thinsp;的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作<u>不灵活</u>。</li>
<li>在&thinsp;Java&thinsp;中，<font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）用来存放&thinsp;<font color="#2121FF"><strong>基本类型数据</strong></font>&thinsp;和&thinsp;<font color="#2121FF"><strong>对象的引用</strong></font>（对象句柄）。</li>
</ul>
</blockquote>
</li>
<li><h4 id="堆（Stack）。"><a href="#堆（Stack）。" class="headerlink" title="堆（Stack）。"></a><strong><font color="#ff3333">堆</font>（<font color="#ff3333">Stack</font>）</strong>。</h4><p>位于&thinsp;<strong>RAM</strong>&thinsp;中；是一种&thinsp;通用内存池。</p>
<blockquote>
<ul>
<li><font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Stack</strong></font>）中的数据不需要明确&thinsp;<strong>数据大小</strong>&thinsp;和&thinsp;<strong>生命周期</strong>，相比于&thinsp;<font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）&thinsp;具有很好的<u>灵活性</u>。</li>
<li>但相应的代价是：<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Stack</strong></font>）的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作，相比于&thinsp;<font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>），速度慢很多。</li>
<li>在&thinsp;Java&thinsp;中，<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Stack</strong></font>）用于存放&thinsp;<u><strong>所有的&thinsp;Java&thinsp;对象</strong></u>。</li>
</ul>
</blockquote>
</li>
<li><h4 id="常量存储（常量池）。"><a href="#常量存储（常量池）。" class="headerlink" title="常量存储（常量池）。"></a><strong><font color="#ff3333">常量存储</font>（<font color="#ff3333">常量池</font>）</strong>。</h4></li>
</ol>
<p>通常位于&thinsp;<u><strong>程序代码内部</strong></u>，随着&thinsp;JDK&thinsp;的迭代而存在不同的设计。（另外在嵌入式系统中，常量会和其他部分隔离，此时可以选择&thinsp;ROM&thinsp;作为常量存储区）</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>JDK&thinsp;7&thinsp;之前的版本</span></div>
    <div class="xContent"><div class="inner">
        <p><font color="#6AA84F"><strong>运行时常量池</strong></font>&thinsp;是&thinsp;<strong>方法区</strong>&thinsp;的一部分。Class文件中除了有&thinsp;类的版本、字段、方法、接口&thinsp;等描述信息外，还有&thinsp;常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然&thinsp;<font color="#6AA84F"><strong>运行时常量池</strong></font>&thinsp;是&thinsp;<strong>方法区</strong>&thinsp;的一部分，自然受到&thinsp;方法区内存&thinsp;的限制，当&thinsp;<strong>常量池</strong>&thinsp;无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p>
 
    </div></div>
    </div>

<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>JDK&thinsp;7&thinsp;及之后的版本</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>JDK&thinsp;7&thinsp;及之后的版本中，JVM&thinsp;已经将&thinsp;<font color="#6AA84F"><strong>运行时常量池</strong></font>&thinsp;从&thinsp;方法区&thinsp;中移了出来，并在&thinsp;<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）&thinsp;中开辟了一块区域存放&thinsp;<font color="#6AA84F"><strong>运行时常量池</strong></font>。</p>
 
    </div></div>
    </div>

<p><font color="#6AA84F"><strong>常量存储</strong></font>（<font color="#6AA84F"><strong>常量池</strong></font>）&thinsp;用于存储常量。因为常量是永远不会被改变的，所以&thinsp;Java&thinsp;中将&thinsp;常量池&thinsp;设置在&thinsp;<strong>程序内部</strong>&thinsp;的设计是安全的。</p>
<ol start="5">
<li><h4 id="非RAM存储。"><a href="#非RAM存储。" class="headerlink" title="非RAM存储。"></a><font color="#ff3333"><strong>非RAM存储</strong></font>。</h4></li>
</ol>
<p>在&thinsp;<font color="#6AA84F"><strong>非&thinsp;RAM&thinsp;存储</strong></font>&thinsp;中，存储的数据的生命周期不受程序本身的生命周期影响。其中两个基本的例子是流对象和持久化对象。</p>
<blockquote>
<ul>
<li>在&thinsp;<font color="#3333FF"><strong>流对象</strong></font>&thinsp;中，对象被转化为<font color="#3333FF"><strong>字节流</strong></font><strong>（Bit Stream）</strong>；通常被发送给另一台机器。</li>
<li>在&thinsp;<font color="#3333FF"><strong>持久化对象</strong></font>&thinsp;中，对象被存放于磁盘上，对象的存储形式与其存储媒介有关。<br>在需要时，可以将持久化对象从具体的存储形式恢复成常规的、基于 RAM 的对象。</li>
</ul>
</blockquote>
<p>Java&thinsp;提供了对&thinsp;<u><strong>轻量级持久化</strong></u>&thinsp;的支持。诸如&thinsp;JDBC&thinsp;和&thinsp;Hibernate&thinsp;这样的机制，提供了更加复杂的对数据库中的对象信息的存取支持。</p>
<h3 id="第2章-2-2-特例：基本类型"><a href="#第2章-2-2-特例：基本类型" class="headerlink" title="第2章-2-2 特例：基本类型"></a><a href="#index_2-2-2">第2章-2-2 特例：基本类型</a></h3><p>基本类型对象&thinsp;直接存储“值”，而不是引用；基本类型对象直接存储于&thinsp;堆栈（Heap）&thinsp;中，所以其所占空间大小是确定的。</p>
<blockquote>
<p>Java&thinsp;要确定每种&thinsp;<strong>基本类型</strong>&thinsp;所占空间大小。它们的大小不会随着机器硬件架构的变化而变化，这种&thinsp;所占存储空间大小的不变性&thinsp;是&thinsp;Java&thinsp;<strong>可移植性</strong>&thinsp;好的原因之一。</p>
</blockquote>


<table class="wikitable" style="margin-top:18px;margin-left:0;margin-right:0;">
  <tbody>
    <tr align="center">
      <th style="width:15%;min-width:75px;">基本类型</th>
      <th style="width:15%;min-width:75px;">中文名称</th>
      <th style="width:16%;min-width:75px;">数据大小(单位：位)</th>
      <th style="width:16%;min-width:75px;">最小值</th>
      <th style="width:16%;min-width:75px;">最大值</th>
      <th style="width:15%;min-width:75px;">对应包装器类型</th>
    </tr>
    <tr>
      <td>boolean</td>
      <td>布尔型</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td>Boolean</td>
    </tr>
    <tr>
      <td>char</td>
      <td>字符型</td>
      <td>16 bit</td>
      <td>Unicode 0</td>
      <td>Unicode 2^16-1</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>byte</td>
      <td>字节型</td>
      <td>8 bit</td>
      <td>-2^7（-128）</td>
      <td>+2^7-1（127）</td>
      <td>Byte</td>
    </tr>

    <tr>
      <td>short</td>
      <td>短整型</td>
      <td>16 bit</td>
      <td>-2^15</td>
      <td>+2^15-1</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>int</td>
      <td>整型</td>
      <td>32 bit</td>
      <td>-2^31</td>
      <td>+2^31-1</td>
      <td>Integer</td>
    </tr>
    <tr>
      <td>long</td>
      <td>长整型</td>
      <td>64 bit</td>
      <td>-2^63</td>
      <td>+2^63-1</td>
      <td>Long</td>
    </tr>
    <tr>
      <td>float</td>
      <td>浮点型</td>
      <td>32 bit</td>
      <td>IEEE754</td>
      <td>IEEE754</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>double</td>
      <td>双精度浮点型</td>
      <td>64 bit</td>
      <td>IEEE754</td>
      <td>IEEE754</td>
      <td>Double</td>
    </tr>
    <tr>
      <td>void</td>
      <td>字符型</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td>Void</td>
    </tr>
  </tbody>
</table>



<blockquote>
<p>boolean&thinsp;类型所占空间大小没有明确地指定，仅定义为能够取字面值<code>true</code>或<code>false</code>。</p>
</blockquote>
<p>所有的&thinsp;<strong>数值类型</strong>&thinsp;都有&thinsp;<strong>符号</strong>，所以不要去寻找无符号的&thinsp;数值类型。</p>
<h3 id="第2章-2-3-Java中的数组"><a href="#第2章-2-3-Java中的数组" class="headerlink" title="第2章-2-3 Java中的数组"></a><a href="#index_2-2-3">第2章-2-3 Java中的数组</a></h3><h3 id="第2章-3-永远不需要销毁对象"><a href="#第2章-3-永远不需要销毁对象" class="headerlink" title="第2章-3 永远不需要销毁对象"></a><a href="#index_2-3">第2章-3 永远不需要销毁对象</a></h3><h3 id="第2章-4-创建新的数据类型"><a href="#第2章-4-创建新的数据类型" class="headerlink" title="第2章-4 创建新的数据类型"></a><a href="#index_2-4">第2章-4 创建新的数据类型</a></h3><h3 id="第2章-5-方法、参数和返回值"><a href="#第2章-5-方法、参数和返回值" class="headerlink" title="第2章-5 方法、参数和返回值"></a><a href="#index_2-5">第2章-5 方法、参数和返回值</a></h3><h3 id="第2章-6-构建一个Java程序"><a href="#第2章-6-构建一个Java程序" class="headerlink" title="第2章-6 构建一个Java程序"></a><a href="#index_2-6">第2章-6 构建一个Java程序</a></h3><h3 id="第2章-7-你的第一个Java程序"><a href="#第2章-7-你的第一个Java程序" class="headerlink" title="第2章-7 你的第一个Java程序"></a><a href="#index_2-7">第2章-7 你的第一个Java程序</a></h3><h3 id="第2章-8-注释和嵌入式文档"><a href="#第2章-8-注释和嵌入式文档" class="headerlink" title="第2章-8 注释和嵌入式文档"></a><a href="#index_2-8">第2章-8 注释和嵌入式文档</a></h3><h3 id="第2章-9-编码风格"><a href="#第2章-9-编码风格" class="headerlink" title="第2章-9 编码风格"></a><a href="#index_2-9">第2章-9 编码风格</a></h3><h3 id="第2章-10-总结"><a href="#第2章-10-总结" class="headerlink" title="第2章-10 总结"></a><a href="#index_2-10">第2章-10 总结</a></h3><h3 id="第2章-11-练习"><a href="#第2章-11-练习" class="headerlink" title="第2章-11 练习"></a><a href="#index_2-11">第2章-11 练习</a></h3><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a><a href="#index_3">第3章 操作符</a></h1><p>在最底层，Java&thinsp;中的数据是通过使用&thinsp;<strong>操作符</strong>&thinsp;来操作的。</p>
<h2 id="第3章-1-更简单的打印语句"><a href="#第3章-1-更简单的打印语句" class="headerlink" title="第3章-1 更简单的打印语句"></a><a href="#index_3-1">第3章-1 更简单的打印语句</a></h2><h2 id="第3章-2-使用Java操作符"><a href="#第3章-2-使用Java操作符" class="headerlink" title="第3章-2 使用Java操作符"></a><a href="#index_3-2">第3章-2 使用Java操作符</a></h2><ul>
<li><p>操作符&thinsp;接受一个或多个&thinsp;<strong>参数</strong>，并生成一个新值。</p>
<blockquote>
<p>参数的形式&thinsp;与普通的&thinsp;方法调用&thinsp;不同，但效果是相同的。</p>
</blockquote>
</li>
<li><p>加号和一元的正号<code>+</code>、减号和一元的负号<code>-</code>、乘号<code>*</code>、除号<code>/</code>以及赋值号<code>=</code>的用法与其他编程语言类似。</p>
</li>
<li><p>操作符&thinsp;用于操作&thinsp;数，生成一个新值。</p>
<blockquote>
<p>另外，有些操作符可能会<u>改变&thinsp;操作数自身的值</u>，这被称为“<strong>副作用</strong>”。</p>
<p>那些能改变其操作数的操作符，最普遍的用途就是用来产生副作用；但要记住，使用此类操作符生成的值，与使用无副作用的操作符生成的值，没有什么区别。</p>
</blockquote>
</li>
<li><p>几乎所有的&thinsp;操作符&thinsp;都只能操作“<strong>基本类型</strong>”。</p>
<ul>
<li>例外的操作符是<code>=</code>、<code>==</code>和<code>!=</code>：这些操作符能操作所有的对象（这也是&thinsp;对象&thinsp;易令人糊涂的地方）。</li>
<li>除此之外，<code>String</code>类支持<code>+</code>和<code>+=</code>：操作<code>String</code>类的<code>+</code>和<code>+=</code>意味着字符串拼接，并且如果必要（被操作的对象不属于<code>String</code>类），编译器会先尝试将非<code>String</code>类型的对象转换为<code>String</code>类型对象，再进行字符串拼接的操作。<blockquote>
<p>注意：操作<code>String</code>类型对象的<code>+</code>和<code>+=</code>操作符，必须要小心使用（…），显式执行（？），杜绝在&thinsp;<strong>循环体</strong>&thinsp;中使用<code>+=</code>操作<code>String</code>造成内存的不可控使用（最坏结果：<u>内存溢出</u>）。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="第3章-3-优先级"><a href="#第3章-3-优先级" class="headerlink" title="第3章-3 优先级"></a><a href="#index_3-3">第3章-3 优先级</a></h2><ul>
<li>当一个&thinsp;<strong>表达式</strong>&thinsp;中存在多个&thinsp;<strong>操作符</strong>&thinsp;时，<strong>操作符的优先级</strong>&thinsp;就决定了各部分的计算顺序。<br>Java&thinsp;对&thinsp;计算顺序&thinsp;做了特别的规定。</li>
</ul>
<h2 id="第3章-4-赋值"><a href="#第3章-4-赋值" class="headerlink" title="第3章-4 赋值"></a><a href="#index_3-4">第3章-4 赋值</a></h2><h3 id="第3章-4-1-方法调用中的别名问题"><a href="#第3章-4-1-方法调用中的别名问题" class="headerlink" title="第3章-4.1 方法调用中的别名问题"></a><a href="#index_3-4-1">第3章-4.1 方法调用中的别名问题</a></h3><h2 id="第3章-5-算数操作符"><a href="#第3章-5-算数操作符" class="headerlink" title="第3章-5 算数操作符"></a><a href="#index_3-5">第3章-5 算数操作符</a></h2><h3 id="第3章-5-1-一元加减操作符"><a href="#第3章-5-1-一元加减操作符" class="headerlink" title="第3章-5-1 一元加减操作符"></a><a href="#index_3-5-1">第3章-5-1 一元加减操作符</a></h3><h2 id="第3章-6-自动递增和递减"><a href="#第3章-6-自动递增和递减" class="headerlink" title="第3章-6 自动递增和递减"></a><a href="#index_3-6">第3章-6 自动递增和递减</a></h2><h2 id="第3章-7-关系操作符"><a href="#第3章-7-关系操作符" class="headerlink" title="第3章-7 关系操作符"></a><a href="#index_3-7">第3章-7 关系操作符</a></h2><ul>
<li><p>关系操作符生成的是一个<code>boolean</code>（布尔）类型结果，计算的是&thinsp;操作数的值之间的关系。如果关系是真实的，则关系表达式会生成<code>true</code>（真），否则生成<code>false</code>（假）。</p>
</li>
<li><p>关系操作符包括：小于<code>&lt;</code>、大于<code>&gt;</code>、小于或等于<code>&lt;=</code>、大于或等于<code>&gt;=</code>、等于<code>==</code>、不等于<code>!=</code>。</p>
<blockquote>
<p>其中等于<code>==</code>、不等于<code>!=</code>适用于<u>所有的&thinsp;<strong>基本数据类型</strong></u>，而其他比较符适用于&thinsp;<u>除<code>boolean</code>类型以外的&thinsp;<strong>基本数据类型</strong></u>。</p>
<p>因为<code>boolean</code>值只能为<code>true</code>或<code>false</code>，对于&thinsp;大于&thinsp;和&thinsp;小于&thinsp;的逻辑来说没有实际意义。</p>
</blockquote>
</li>
</ul>
<h3 id="第3章-7-1-测试对象的等价性"><a href="#第3章-7-1-测试对象的等价性" class="headerlink" title="第3章-7-1 测试对象的等价性"></a><a href="#index_3-7-1">第3章-7-1 测试对象的等价性</a></h3><p>关系操作符<code>==</code>和<code>!=</code>适用于所有对象。</p>
<blockquote>
<p>注意：关系运算符&thinsp;比较的是&thinsp;<strong>对象的值</strong>。</p>
</blockquote>
<p>若要比较&thinsp;<strong>对象的引用</strong>，可以使用&thinsp;对象的<code>equals</code>方法（来自<code>Object</code>）实现。</p>
<h2 id="第3章-8-逻辑操作符"><a href="#第3章-8-逻辑操作符" class="headerlink" title="第3章-8 逻辑操作符"></a><a href="#index_3-8">第3章-8 逻辑操作符</a></h2><ul>
<li><p>逻辑操作符：与<code>&amp;&amp;</code>、或<code>||</code>、非<code>!</code>。</p>
</li>
<li><p>逻辑操作符&thinsp;能根据&thinsp;参数的逻辑关系，生成一个&thinsp;布尔值<code>boolean</code>（<code>true</code>或<code>false</code>）。</p>
</li>
<li><p>在&thinsp;Java&thinsp;中，逻辑操作符（与<code>&amp;&amp;</code>、或<code>||</code>、非<code>!</code>）只可应用于&thinsp;布尔值<code>boolean</code>。</p>
<blockquote>
<p>而在&thinsp;C&thinsp;和&thinsp;C++&thinsp;中，不可将一个&thinsp;布尔值&thinsp;当做&thinsp;非布尔值&thinsp;在&thinsp;<strong>逻辑表达式</strong>&thinsp;中使用。</p>
<p>注意：如果在使用<code>String</code>值的地方使用布尔值，该布尔值会自动转换为<code>String</code>形式。</p>
</blockquote>
</li>
</ul>
<h3 id="第3章-8-1-短路"><a href="#第3章-8-1-短路" class="headerlink" title="第3章-8-1 短路"></a><a href="#index_3-8-1">第3章-8-1 短路</a></h3><p>当使用逻辑运算符时，我们会遇到一种“短路”现象：一旦能够明确无误地确定&thinsp;<strong>整个表达式的值</strong>，就不再计算表达式的余下部分。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.8.1 短路 - “短路”现象示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Suite</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2019-02-23 13:10:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCircuitDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag2 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag3 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【逻辑运算符】&#x27;&amp;&amp;&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;【逻辑运算符】&#x27;&amp;&amp;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 &amp;&amp; (flag2 = <span class="keyword">false</span>) &amp;&amp; (flag3 = <span class="keyword">false</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;&amp;&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&#x27;&amp;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 &amp; (flag2 = ! flag2) &amp; (flag3 = ! flag3)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【逻辑运算符】&#x27;||&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;【逻辑运算符】&#x27;||&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 || (flag2 = <span class="keyword">false</span>) || (flag3 = <span class="keyword">false</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;|&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&#x27;|&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 | (flag2 = ! flag2) | (flag3 = ! flag3)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!output: 【逻辑运算符】&#x27;||&#x27;</span></span><br><span class="line">    <span class="comment">//!output: flag1 = true,flag2 = true,flag3 = false</span></span><br><span class="line">    <span class="comment">//!output: &#x27;|&#x27;</span></span><br><span class="line">    <span class="comment">//!output: flag1 = true,flag2 = false,flag3 = true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【应用】我们可以借助“短路”这种设计，节省不必要的代码，使业务逻辑的实现（在编码层面）更精简方便。</p>
</blockquote>
<h2 id="第3章-9-直接常量"><a href="#第3章-9-直接常量" class="headerlink" title="第3章-9 直接常量"></a><a href="#index_3-9">第3章-9 直接常量</a></h2><h3 id="第3章-9-1-指数记数法"><a href="#第3章-9-1-指数记数法" class="headerlink" title="第3章-9-1 指数记数法"></a><a href="#index_3-9-1">第3章-9-1 指数记数法</a></h3><h2 id="第3章-10-按位操作符"><a href="#第3章-10-按位操作符" class="headerlink" title="第3章-10 按位操作符"></a><a href="#index_3-10">第3章-10 按位操作符</a></h2><h2 id="第3章-11-移位操作符"><a href="#第3章-11-移位操作符" class="headerlink" title="第3章-11 移位操作符"></a><a href="#index_3-11">第3章-11 移位操作符</a></h2><h2 id="第3章-12-三元操作符if-else"><a href="#第3章-12-三元操作符if-else" class="headerlink" title="第3章-12 三元操作符if-else"></a><a href="#index_3-12">第3章-12 三元操作符if-else</a></h2><h2 id="第3章-13-字符串操作符-和"><a href="#第3章-13-字符串操作符-和" class="headerlink" title="第3章-13 字符串操作符+和="></a><a href="#index_3-13">第3章-13 字符串操作符+和=</a></h2><h2 id="第3章-14-使用操作符时常犯的错误"><a href="#第3章-14-使用操作符时常犯的错误" class="headerlink" title="第3章-14 使用操作符时常犯的错误"></a><a href="#index_3-14">第3章-14 使用操作符时常犯的错误</a></h2><h2 id="第3章-15-类型转换操作符"><a href="#第3章-15-类型转换操作符" class="headerlink" title="第3章-15 类型转换操作符"></a><a href="#index_3-15">第3章-15 类型转换操作符</a></h2><h3 id="第3章-15-1-截尾和舍入"><a href="#第3章-15-1-截尾和舍入" class="headerlink" title="第3章-15-1 截尾和舍入"></a><a href="#index_3-15-1">第3章-15-1 截尾和舍入</a></h3><h3 id="第3章-15-2-提升"><a href="#第3章-15-2-提升" class="headerlink" title="第3章-15-2 提升"></a><a href="#index_3-15-2">第3章-15-2 提升</a></h3><h2 id="第3章-16-Java没有sizeof"><a href="#第3章-16-Java没有sizeof" class="headerlink" title="第3章-16 Java没有sizeof"></a><a href="#index_3-16">第3章-16 Java没有sizeof</a></h2><h2 id="第3章-17-操作符小结"><a href="#第3章-17-操作符小结" class="headerlink" title="第3章-17 操作符小结"></a><a href="#index_3-17">第3章-17 操作符小结</a></h2><h2 id="第3章-18-总结"><a href="#第3章-18-总结" class="headerlink" title="第3章-18 总结"></a><a href="#index_3-18">第3章-18 总结</a></h2><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a><a href="#index_4">第4章 控制执行流程</a></h1><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a><a href="#index_5">第5章 初始化与清理</a></h1><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。<br><strong>初始化</strong>&thinsp;和&thinsp;<strong>清理</strong>（<strong>cleanup</strong>）&thinsp;正是涉及<strong>安全</strong>的两个问题。</p>
<blockquote>
<ul>
<li><p>许多&thinsp;C&thinsp;程序的错误都源于程序员忘记&thinsp;<strong>初始化</strong>变量。特别是在使用程序库，且用户不知道如何正确地初始化库的构件（或者是必须初始化的其他东西）时，更是如此。</p>
</li>
<li><p><strong>清理</strong>&thinsp;也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记，导致这个元素占用的资源一直得不到释放，最终结果是资源（尤其是内存）用尽。</p>
</li>
</ul>
</blockquote>
<p>C++&thinsp;引入了&thinsp;<strong>构造器</strong>（<strong>constructor</strong>）&thinsp;的概念，这是一个&thinsp;<u>在<strong>创建对象</strong>时&thinsp;被自动调用的<strong>特殊方法</strong></u>。Java&thinsp;中也采用了&thinsp;<strong>构造器</strong>，并额外提供了“<strong>垃圾回收器</strong>”。对于不再使用的内存资源，垃圾回收器能自动将其释放。</p>
<p>本章就讨论&thinsp;<strong>初始化</strong>&thinsp;和&thinsp;<strong>清理</strong>&thinsp;的相关问题，以及&thinsp;Java&thinsp;对它们的支持。</p>
<h2 id="第5章-1-用构造器确保初始化"><a href="#第5章-1-用构造器确保初始化" class="headerlink" title="第5章-1 用构造器确保初始化"></a><a href="#index_5-1">第5章-1 用构造器确保初始化</a></h2><blockquote>
<p>可以假想为编写的每个类都定义一个<code>initialize()</code>方法，该方法的名称提醒你在使用其对象之前，应首先调用<code>initialize()</code>。然而，这同时意味着用户必须记得自己去调用此方法。</p>
</blockquote>
<p>在&thinsp;Java&thinsp;中，<u>通过提供构造器，类的设计者可以确保每个对象都会得到初始化</u>。创建对象时，如果其类具有构造器，Java&thinsp;就会在用户能够操作对象之前自动调用相应的构造器，从而保证了初始化的顺利进行。</p>
<blockquote>
<p>接下来的问题就是如何命名这个方法，2个考虑点：<br>①&ensp;构造器按照方法命名规范所取的任何名字，都可能与类的某个成员名称冲突；<br>②&ensp;调用构造器是编译器的责任，所以必须让编译器知道构造器对应哪一个方法。</p>
</blockquote>
<p>C++&thinsp;中采用了的解决方案看起来是最简单且更符合逻辑的，所以&thinsp;Java&thinsp;中也采用了这种方案：<u>构造器采用与类相同的名称</u>（<u>符合类的命名规范，但不符合方法的命名规范</u>）。</p>
<blockquote>
<p>注意，由于构造器名称必须与类名完全一致，所以“每个方法首字母小写”的编码风格并不适用于构造器。</p>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>以下是一个带有构造器的简单类……</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>以下是一个带有构造器的简单类：<br>……<br>现在，在创建对象时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Rock()</span><br></pre></td></tr></table></figure>
<p>将会为对象分配存储空间，并调用相应的构造器。这就保证了在你能操作对象之前，它已经被恰当地初始化了。</p>
<ul>
<li><p><strong>默认构造器</strong>（<strong>无参构造器</strong>）：不接收形式参数的构造器。</p>
</li>
<li><p><strong>有参构造器</strong>。如果<code>Tree(int)</code>是<code>Tree</code>类中唯一的构造器，那么编译器将不会允许你以其他任何方式创建<code>Tree</code>对象。</p>
</li>
<li><p><strong>构造器</strong>&thinsp;有助于减少错误，并使代码更易阅读。从概念上讲，“<strong>初始化</strong>”与“<strong>创建</strong>”是彼此独立的，然而在上面的代码中，你却找不到对<code>initialize()</code>方法的明确调用。<u>在&thinsp;Java&thinsp;中，“<strong>初始化</strong>”和“<strong>创建</strong>”是捆绑在一起，不可分离的</u>。</p>
</li>
<li><p><u><strong>构造器</strong>&thinsp;是一种特殊类型的<strong>方法</strong>，因为它<strong>没有返回值</strong></u>。<br>这与&thinsp;<strong>返回值为空</strong>（<strong>void</strong>）&thinsp;明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西；<strong>构造器</strong>&thinsp;则不会返回任何东西，你别无选择（<strong>new</strong>&thinsp;表达式确实返回了对新建对象的引用，但<strong>构造器</strong>本身并没有返回任何值）。假如构造器具有返回值，并且允许程序员自行选择返回类型，那么势必得让编译器知道该如何处理此返回值。</p>
</li>
</ul>
 
    </div></div>
    </div>

<h2 id="第5章-2-方法重载"><a href="#第5章-2-方法重载" class="headerlink" title="第5章-2 方法重载"></a><a href="#index_5-2">第5章-2 方法重载</a></h2><blockquote>
<p>任何程序设计语言都具备一项重要特性，就是对<strong>名字</strong>的运用。</p>
<ul>
<li><u>当创建一个<strong>对象</strong>时，也就是给这个对象分配到的<strong>存储空间</strong>取了一个<strong>名字</strong></u>。</li>
<li><u>所谓<strong>方法</strong>就是给某个<strong>动作</strong>取的名字</u>。</li>
</ul>
<p>通过使用名字，你可以引用所有的对象和方法。</p>
<p>名字起的好可以更易于理解和修改。</p>
</blockquote>
<h2 id="第5章-3-默认构造器"><a href="#第5章-3-默认构造器" class="headerlink" title="第5章-3 默认构造器"></a><a href="#index_5-3">第5章-3 默认构造器</a></h2><p><font color="#6AA84F"><strong>默认构造器</strong></font>（又称&thinsp;<font color="#6AA84F"><strong>无参构造器</strong></font>）是没有形式参数的，<u>它的作用是<strong>创建</strong>一个默认对象</u>。</p>
<blockquote>
<p>如果一个类中没有构造器，则编译器会自动创建一个该类的默认构造器；而如果类中已经定义了构造器（无论是否有参数），则编译器不会再为该类创建默认构造器。</p>
</blockquote>
<h2 id="第5章-4-this关键字"><a href="#第5章-4-this关键字" class="headerlink" title="第5章-4 this关键字"></a><a href="#index_5-4">第5章-4 this关键字</a></h2><p><u>方法调用时，往往需要指定&thinsp;<strong>对象</strong></u>（<u><code>static</code>方法&thinsp;还可以直接指定&thinsp;<strong>类</strong><code>class</code></u>）。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
<p>同一个类型的对象，a&thinsp;和&thinsp;b，想要让它们都能调用同一个方法<code>peel()</code>，该如何实现？</p>
 
    </div></div>
    </div>

<p>在&thinsp;Java&thinsp;中，使用了简便且面向对象的语法来编写代码 —— 即“<strong>发送消息给对象</strong>”，编译器做了一些幕后处理 —— 它将“<strong>所操作对象的引用</strong>”作为第一个&thinsp;<strong>参数</strong>&thinsp;传递给&thinsp;<strong>方法</strong>。</p>
<blockquote>
<p>所以，示例中的方法调用代码可以如下解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.peel();</span><br><span class="line">a.peel(<span class="number">1</span>);</span><br><span class="line">b.peel();</span><br><span class="line">b.peel(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>↓ 以下是内部的表现形式（注意：不符合编码规范，编译会报错）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=== (不符合编码规范，编译会报错) ===//</span></span><br><span class="line">Banana.peel(a);</span><br><span class="line">Banana.peel(a,<span class="number">1</span>);</span><br><span class="line">Banana.peel(b);</span><br><span class="line">Banana.peel(b,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//======//</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><font color="#CC0000"><strong>this</strong></font>&thinsp;关键字为此而生，它表示<u><strong>对</strong>“<strong>调用方法的那个对象</strong>”<strong>的引用</strong></u>，且<u>只能在&thinsp;<font color="#2D2DFF"><strong>方法内部</strong></font>&thinsp;使用</u>（指代<u>发起方法调用时，该方法对应的对象</u>）。</p>
<blockquote>
<ul>
<li><p><strong>this</strong>&thinsp;的用法与其他对象引用并无不同。<br>注意，如果在方法内部调用同一个类的另一个方法，不必使用&thinsp;<strong>this</strong>，直接调用即可。</p>
</li>
<li><p>只有当需要明确指出<strong>对当前对象的引用时</strong>，才需要使用&thinsp;<strong>this</strong>&thinsp;关键字。例如，当需要返回对当前对象的引用时，就可以这样写：<br>……</p>
</li>
<li><p><strong>this</strong>&thinsp;引用对于将当前对象传递给其他方法也很有用。<br>……</p>
</li>
</ul>
</blockquote>
<h3 id="第5章-4-1-在构造器中调用构造器"><a href="#第5章-4-1-在构造器中调用构造器" class="headerlink" title="第5章-4-1 在构造器中调用构造器"></a><a href="#index_5-4-1">第5章-4-1 在构造器中调用构造器</a></h3><p>调用形式：<code>this(</code>参数类型列表<code>)</code></p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子：</span></div>
    <div class="xContent"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<ul>
<li><p><u>在&thinsp;<font color="#6AA84F"><strong>构造器</strong></font>&thinsp;中，<font color="#2D2DFF"><strong>最多只能调用一次&thinsp;构造器</strong></font></u>。（否则编译报错）</p>
</li>
<li><p><u>在&thinsp;<font color="#6AA84F"><strong>构造器</strong></font>&thinsp;中，[&thinsp;<font color="#2D2DFF"><strong>调用构造器&thinsp;的代码</strong></font>&thinsp;]&thinsp;必须在&thinsp;<font color="#2D2DFF"><strong>最开始的地方</strong></font></u>。（否则编译报错）</p>
</li>
<li><p>这个例子中也展示了&thinsp;<u><strong>this</strong>&thinsp;的另一种用法&ensp;——&ensp;<strong>避免歧义</strong></u>。</p>
<blockquote>
<p>由于参数<code>s</code>的名称和数据成员<code>s</code>的名称相同，同时使用会产生歧义；使用<code>this.s</code>来代表数据成员就能解决这个问题。</p>
</blockquote>
</li>
</ul>
<h3 id="第5章-4-2-static的含义"><a href="#第5章-4-2-static的含义" class="headerlink" title="第5章-4-2 static的含义"></a><a href="#index_5-4-2">第5章-4-2 static的含义</a></h3><p>了解<code>this</code>关键字以后，就能更好地理解<code>static</code>（<font color="#CC0000"><strong>静态</strong></font>）<font color="#CC0000"><strong>方法</strong></font>的含义。</p>
<ul>
<li><p><u><code>static</code><font color="#6AA84F"><strong>方法</strong></font>&thinsp;中不能使用&thinsp;<code>this</code></u>。</p>
<blockquote>
<p>使用<code>static</code>方法时，由于不存在<code>this</code>，所以它不是通过“向对象发送消息”来完成的。</p>
</blockquote>
</li>
<li><p><u><code>static</code><font color="#6AA84F"><strong>方法</strong></font>&thinsp;中不能（直接）调用&thinsp;<font color="#2F2FFF"><strong>非静态方法</strong></font>&thinsp;和&thinsp;<font color="#2F2FFF"><strong>非静态对象</strong></font></u>（涉及到底层加载顺序）；而&thinsp;非静态方法&thinsp;中可以调用&thinsp;静态方法&thinsp;和&thinsp;静态对象。</p>
</li>
<li><p><u><code>static</code><font color="#6AA84F"><strong>方法</strong></font>&thinsp;的&thinsp;<strong>加载</strong>&thinsp;是依附于&thinsp;<strong>类</strong><code>class</code>&thinsp;而不是&thinsp;<strong>类的对象</strong><code>Object</code></u>：可以在没有创建任何对象的前提下，通过&thinsp;<strong>类</strong>本身&thinsp;来调用<code>static</code>方法，这正是<u><code>static</code>方法&thinsp;的主要用途</u>。</p>
<blockquote>
<p><code>static</code>方法很像&thinsp;全局方法；Java&thinsp;中禁止使用全局方法，但你在<code>static</code>方法中就能访问其他<code>static</code>方法&thinsp;和&thinsp;<code>static</code>域。</p>
</blockquote>
</li>
</ul>
<h2 id="第5章-5-清理：终结处理和垃圾回收"><a href="#第5章-5-清理：终结处理和垃圾回收" class="headerlink" title="第5章-5 清理：终结处理和垃圾回收"></a><a href="#index_5-5">第5章-5 清理：终结处理和垃圾回收</a></h2><h2 id="第5章-6-成员初始化"><a href="#第5章-6-成员初始化" class="headerlink" title="第5章-6 成员初始化"></a><a href="#index_5-6">第5章-6 成员初始化</a></h2><h3 id="第5章-6-1-指定初始化"><a href="#第5章-6-1-指定初始化" class="headerlink" title="第5章-6-1 指定初始化"></a><a href="#index_5-6-1">第5章-6-1 指定初始化</a></h3><h2 id="第5章-7-构造器初始化"><a href="#第5章-7-构造器初始化" class="headerlink" title="第5章-7 构造器初始化"></a><a href="#index_5-7">第5章-7 构造器初始化</a></h2><h3 id="第5章-7-1-初始化顺序"><a href="#第5章-7-1-初始化顺序" class="headerlink" title="第5章-7-1 初始化顺序"></a><a href="#index_5-7-1">第5章-7-1 初始化顺序</a></h3><h3 id="第5章-7-2-静态数据的初始化"><a href="#第5章-7-2-静态数据的初始化" class="headerlink" title="第5章-7-2 静态数据的初始化"></a><a href="#index_5-7-2">第5章-7-2 静态数据的初始化</a></h3><h3 id="第5章-7-3-显式的静态初始化"><a href="#第5章-7-3-显式的静态初始化" class="headerlink" title="第5章-7-3 显式的静态初始化"></a><a href="#index_5-7-3">第5章-7-3 显式的静态初始化</a></h3><h3 id="第5章-7-4-非静态实例初始化"><a href="#第5章-7-4-非静态实例初始化" class="headerlink" title="第5章-7-4 非静态实例初始化"></a><a href="#index_5-7-4">第5章-7-4 非静态实例初始化</a></h3><h2 id="第5章-8-数组初始化"><a href="#第5章-8-数组初始化" class="headerlink" title="第5章-8 数组初始化"></a><a href="#index_5-8">第5章-8 数组初始化</a></h2><h3 id="第5章-8-1-可变参数列表"><a href="#第5章-8-1-可变参数列表" class="headerlink" title="第5章-8-1 可变参数列表"></a><a href="#index_5-8-1">第5章-8-1 可变参数列表</a></h3><h2 id="第5章-9-枚举类型"><a href="#第5章-9-枚举类型" class="headerlink" title="第5章-9 枚举类型"></a><a href="#index_5-9">第5章-9 枚举类型</a></h2><h3 id="第5章-9-1-枚举类（enum）——基本概念"><a href="#第5章-9-1-枚举类（enum）——基本概念" class="headerlink" title="第5章-9-1 枚举类（enum）——基本概念"></a><a href="#index_5-9-1">第5章-9-1 枚举类（enum）——基本概念</a></h3><h3 id="第5章-9-2-枚举类的使用"><a href="#第5章-9-2-枚举类的使用" class="headerlink" title="第5章-9-2 枚举类的使用"></a><a href="#index_5-9-2">第5章-9-2 枚举类的使用</a></h3><h2 id="第5章-10-总结"><a href="#第5章-10-总结" class="headerlink" title="第5章-10 总结"></a><a href="#index_5-10">第5章-10 总结</a></h2><h1 id="第6章-访问权限控制"><a href="#第6章-访问权限控制" class="headerlink" title="第6章 访问权限控制"></a><a href="#index_6">第6章 访问权限控制</a></h1><h2 id="第6章-1-包：库单元"><a href="#第6章-1-包：库单元" class="headerlink" title="第6章-1 包：库单元"></a><a href="#index_6-1">第6章-1 包：库单元</a></h2><h3 id="第6章-1-1-代码组织"><a href="#第6章-1-1-代码组织" class="headerlink" title="第6章-1-1 代码组织"></a><a href="#index_6-1-1">第6章-1-1 代码组织</a></h3><h3 id="第6章-1-2-创建独一无二的包名"><a href="#第6章-1-2-创建独一无二的包名" class="headerlink" title="第6章-1-2 创建独一无二的包名"></a><a href="#index_6-1-2">第6章-1-2 创建独一无二的包名</a></h3><h3 id="第6章-1-3-定制工具库"><a href="#第6章-1-3-定制工具库" class="headerlink" title="第6章-1-3 定制工具库"></a><a href="#index_6-1-3">第6章-1-3 定制工具库</a></h3><h3 id="第6章-1-4-用import改变行为"><a href="#第6章-1-4-用import改变行为" class="headerlink" title="第6章-1-4 用import改变行为"></a><a href="#index_6-1-4">第6章-1-4 用import改变行为</a></h3><h3 id="第6章-1-5-对使用包的忠告"><a href="#第6章-1-5-对使用包的忠告" class="headerlink" title="第6章-1-5 对使用包的忠告"></a><a href="#index_6-1-5">第6章-1-5 对使用包的忠告</a></h3><h2 id="第6章-2-Java访问权限修饰词"><a href="#第6章-2-Java访问权限修饰词" class="headerlink" title="第6章-2 Java访问权限修饰词"></a><a href="#index_6-2">第6章-2 Java访问权限修饰词</a></h2><h2 id="第6章-3-接口和实现"><a href="#第6章-3-接口和实现" class="headerlink" title="第6章-3 接口和实现"></a><a href="#index_6-3">第6章-3 接口和实现</a></h2><h2 id="第6章-4-类的访问权限"><a href="#第6章-4-类的访问权限" class="headerlink" title="第6章-4 类的访问权限"></a><a href="#index_6-4">第6章-4 类的访问权限</a></h2><h2 id="第6章-5-总结"><a href="#第6章-5-总结" class="headerlink" title="第6章-5 总结"></a><a href="#index_6-5">第6章-5 总结</a></h2><h1 id="第7章-复用类"><a href="#第7章-复用类" class="headerlink" title="第7章 复用类"></a><a href="#index_7">第7章 复用类</a></h1><h2 id="第7章-1-组合语法"><a href="#第7章-1-组合语法" class="headerlink" title="第7章-1 组合语法"></a><a href="#index_7-1">第7章-1 组合语法</a></h2><h2 id="第7章-2-继承语法"><a href="#第7章-2-继承语法" class="headerlink" title="第7章-2 继承语法"></a><a href="#index_7-2">第7章-2 继承语法</a></h2><h3 id="第7章-2-1-初始化基类"><a href="#第7章-2-1-初始化基类" class="headerlink" title="第7章-2-1 初始化基类"></a><a href="#index_7-2-1">第7章-2-1 初始化基类</a></h3><h3 id="【拓展】第7章-2-2-重写"><a href="#【拓展】第7章-2-2-重写" class="headerlink" title="【拓展】第7章-2-2 重写"></a><a href="#index_7-2-2">【拓展】第7章-2-2 重写</a></h3><h2 id="第7章-3-代理"><a href="#第7章-3-代理" class="headerlink" title="第7章-3 代理"></a><a href="#index_7-3">第7章-3 代理</a></h2><h2 id="第7章-4-结合使用组合和继承"><a href="#第7章-4-结合使用组合和继承" class="headerlink" title="第7章-4 结合使用组合和继承"></a><a href="#index_7-4">第7章-4 结合使用组合和继承</a></h2><h2 id="第7章-5-在组合与继承之间选择"><a href="#第7章-5-在组合与继承之间选择" class="headerlink" title="第7章-5 在组合与继承之间选择"></a><a href="#index_7-5">第7章-5 在组合与继承之间选择</a></h2><h2 id="第7章-6-protected关键字"><a href="#第7章-6-protected关键字" class="headerlink" title="第7章-6 protected关键字"></a><a href="#index_7-6">第7章-6 protected关键字</a></h2><h2 id="第7章-7-向上转型"><a href="#第7章-7-向上转型" class="headerlink" title="第7章-7 向上转型"></a><a href="#index_7-7">第7章-7 向上转型</a></h2><h2 id="第7章-8-final关键字"><a href="#第7章-8-final关键字" class="headerlink" title="第7章-8 final关键字"></a><a href="#index_7-8">第7章-8 final关键字</a></h2><h3 id="第7章-8-1-final数据"><a href="#第7章-8-1-final数据" class="headerlink" title="第7章-8-1 final数据"></a><a href="#index_7-8-1">第7章-8-1 final数据</a></h3><h3 id="第7章-8-2-final方法"><a href="#第7章-8-2-final方法" class="headerlink" title="第7章-8-2 final方法"></a><a href="#index_7-8-2">第7章-8-2 final方法</a></h3><h3 id="第7章-8-3-final类"><a href="#第7章-8-3-final类" class="headerlink" title="第7章-8-3 final类"></a><a href="#index_7-8-3">第7章-8-3 final类</a></h3><h3 id="第7章-8-4-有关final的忠告"><a href="#第7章-8-4-有关final的忠告" class="headerlink" title="第7章-8-4 有关final的忠告"></a><a href="#index_7-8-4">第7章-8-4 有关final的忠告</a></h3><h2 id="第7章-9-初始化类及类的加载"><a href="#第7章-9-初始化类及类的加载" class="headerlink" title="第7章-9 初始化类及类的加载"></a><a href="#index_7-9">第7章-9 初始化类及类的加载</a></h2><h2 id="第7章-10-总结"><a href="#第7章-10-总结" class="headerlink" title="第7章-10 总结"></a><a href="#index_7-10">第7章-10 总结</a></h2><h1 id="第8章-多态"><a href="#第8章-多态" class="headerlink" title="第8章 多态"></a><a href="#index_8">第8章 多态</a></h1><h2 id="第8章-1-再论向上转型"><a href="#第8章-1-再论向上转型" class="headerlink" title="第8章-1 再论向上转型"></a><a href="#index_8-1">第8章-1 再论向上转型</a></h2><h2 id="第8章-2-转机"><a href="#第8章-2-转机" class="headerlink" title="第8章-2 转机"></a><a href="#index_8-2">第8章-2 转机</a></h2><h2 id="第8章-3-构造器和多态"><a href="#第8章-3-构造器和多态" class="headerlink" title="第8章-3 构造器和多态"></a><a href="#index_8-3">第8章-3 构造器和多态</a></h2><h2 id="第8章-4-协变返回类型"><a href="#第8章-4-协变返回类型" class="headerlink" title="第8章-4 协变返回类型"></a><a href="#index_8-4">第8章-4 协变返回类型</a></h2><h2 id="第8章-5-用继承进行设计"><a href="#第8章-5-用继承进行设计" class="headerlink" title="第8章-5 用继承进行设计"></a><a href="#index_8-5">第8章-5 用继承进行设计</a></h2><h3 id="第8章-5-1-纯继承与拓展"><a href="#第8章-5-1-纯继承与拓展" class="headerlink" title="第8章-5-1 纯继承与拓展"></a><a href="#index_8-5-1">第8章-5-1 纯继承与拓展</a></h3><h3 id="第8章-5-2-向下转型与运行时类型识别"><a href="#第8章-5-2-向下转型与运行时类型识别" class="headerlink" title="第8章-5-2 向下转型与运行时类型识别"></a><a href="#index_8-5-2">第8章-5-2 向下转型与运行时类型识别</a></h3><h2 id="第8章-6-总结"><a href="#第8章-6-总结" class="headerlink" title="第8章-6 总结"></a><a href="#index_8-6">第8章-6 总结</a></h2><h1 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a><a href="#index_9">第9章 接口</a></h1><h2 id="第9章-1-抽象类和抽象方法"><a href="#第9章-1-抽象类和抽象方法" class="headerlink" title="第9章-1 抽象类和抽象方法"></a><a href="#index_9-1">第9章-1 抽象类和抽象方法</a></h2><h2 id="第9章-2-接口"><a href="#第9章-2-接口" class="headerlink" title="第9章-2 接口"></a><a href="#index_9-2">第9章-2 接口</a></h2><h2 id="第9章-3-完全解耦"><a href="#第9章-3-完全解耦" class="headerlink" title="第9章-3 完全解耦"></a><a href="#index_9-3">第9章-3 完全解耦</a></h2><h2 id="第9章-4-Java中的多重继承"><a href="#第9章-4-Java中的多重继承" class="headerlink" title="第9章-4 Java中的多重继承"></a><a href="#index_9-4">第9章-4 Java中的多重继承</a></h2><h2 id="第9章-5-通过继承来拓展接口"><a href="#第9章-5-通过继承来拓展接口" class="headerlink" title="第9章-5 通过继承来拓展接口"></a><a href="#index_9-5">第9章-5 通过继承来拓展接口</a></h2><h2 id="第9章-6-适配接口"><a href="#第9章-6-适配接口" class="headerlink" title="第9章-6 适配接口"></a><a href="#index_9-6">第9章-6 适配接口</a></h2><h2 id="第9章-7-接口中的域"><a href="#第9章-7-接口中的域" class="headerlink" title="第9章-7 接口中的域"></a><a href="#index_9-7">第9章-7 接口中的域</a></h2><h2 id="第9章-8-嵌套接口"><a href="#第9章-8-嵌套接口" class="headerlink" title="第9章-8 嵌套接口"></a><a href="#index_9-8">第9章-8 嵌套接口</a></h2><h2 id="第9章-9-接口与工厂"><a href="#第9章-9-接口与工厂" class="headerlink" title="第9章-9 接口与工厂"></a><a href="#index_9-9">第9章-9 接口与工厂</a></h2><h2 id="第9章-10-总结"><a href="#第9章-10-总结" class="headerlink" title="第9章-10 总结"></a><a href="#index_9-10">第9章-10 总结</a></h2><h1 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a><a href="#index_10">第10章 内部类</a></h1><h2 id="第10章-1-创建内部类"><a href="#第10章-1-创建内部类" class="headerlink" title="第10章-1 创建内部类"></a><a href="#index_10-1">第10章-1 创建内部类</a></h2><h2 id="第10章-2-链接到外部类"><a href="#第10章-2-链接到外部类" class="headerlink" title="第10章-2 链接到外部类"></a><a href="#index_10-2">第10章-2 链接到外部类</a></h2><h2 id="第10章-3-使用-this与-new"><a href="#第10章-3-使用-this与-new" class="headerlink" title="第10章-3 使用.this与.new"></a><a href="#index_10-3">第10章-3 使用.this与.new</a></h2><h2 id="第10章-4-内部类与向上转型"><a href="#第10章-4-内部类与向上转型" class="headerlink" title="第10章-4 内部类与向上转型"></a><a href="#index_10-4">第10章-4 内部类与向上转型</a></h2><h2 id="第10章-5-在方法和作用域内的内部类"><a href="#第10章-5-在方法和作用域内的内部类" class="headerlink" title="第10章-5 在方法和作用域内的内部类"></a><a href="#index_10-5">第10章-5 在方法和作用域内的内部类</a></h2><h2 id="第10章-6-匿名内部类"><a href="#第10章-6-匿名内部类" class="headerlink" title="第10章-6 匿名内部类"></a><a href="#index_10-6">第10章-6 匿名内部类</a></h2><h2 id="第10章-7-嵌套类"><a href="#第10章-7-嵌套类" class="headerlink" title="第10章-7 嵌套类"></a><a href="#index_10-7">第10章-7 嵌套类</a></h2><h2 id="第10章-8-为什么需要内部类"><a href="#第10章-8-为什么需要内部类" class="headerlink" title="第10章-8 为什么需要内部类"></a><a href="#index_10-8">第10章-8 为什么需要内部类</a></h2><h2 id="第10章-9-内部类的继承"><a href="#第10章-9-内部类的继承" class="headerlink" title="第10章-9 内部类的继承"></a><a href="#index_10-9">第10章-9 内部类的继承</a></h2><h2 id="第10章-10-内部类可以被覆盖吗"><a href="#第10章-10-内部类可以被覆盖吗" class="headerlink" title="第10章-10 内部类可以被覆盖吗"></a><a href="#index_10-10">第10章-10 内部类可以被覆盖吗</a></h2><h2 id="第10章-11-局部内部类"><a href="#第10章-11-局部内部类" class="headerlink" title="第10章-11 局部内部类"></a><a href="#index_10-11">第10章-11 局部内部类</a></h2><h2 id="第10章-12-内部类标识符"><a href="#第10章-12-内部类标识符" class="headerlink" title="第10章-12 内部类标识符"></a><a href="#index_10-12">第10章-12 内部类标识符</a></h2><h2 id="第10章-13-总结"><a href="#第10章-13-总结" class="headerlink" title="第10章-13 总结"></a><a href="#index_10-13">第10章-13 总结</a></h2><h1 id="第11章-持有对象"><a href="#第11章-持有对象" class="headerlink" title="第11章 持有对象"></a><a href="#index_11">第11章 持有对象</a></h1><h2 id="第11章-1-泛型和类型安全的容器"><a href="#第11章-1-泛型和类型安全的容器" class="headerlink" title="第11章-1 泛型和类型安全的容器"></a><a href="#index_11-1">第11章-1 泛型和类型安全的容器</a></h2><h2 id="第11章-2-基本概念"><a href="#第11章-2-基本概念" class="headerlink" title="第11章-2 基本概念"></a><a href="#index_11-2">第11章-2 基本概念</a></h2><h2 id="第11章-3-添加一组元素"><a href="#第11章-3-添加一组元素" class="headerlink" title="第11章-3 添加一组元素"></a><a href="#index_11-3">第11章-3 添加一组元素</a></h2><h2 id="第11章-4-容器的打印"><a href="#第11章-4-容器的打印" class="headerlink" title="第11章-4 容器的打印"></a><a href="#index_11-4">第11章-4 容器的打印</a></h2><h2 id="第11章-5-List（原理-amp-简介）"><a href="#第11章-5-List（原理-amp-简介）" class="headerlink" title="第11章-5 List（原理 &amp; 简介）"></a><a href="#index_11-5">第11章-5 List（原理 &amp; 简介）</a></h2><h2 id="第11章-6-迭代器"><a href="#第11章-6-迭代器" class="headerlink" title="第11章-6 迭代器"></a><a href="#index_11-6">第11章-6 迭代器</a></h2><h2 id="第11章-7-LinkedList"><a href="#第11章-7-LinkedList" class="headerlink" title="第11章-7 LinkedList"></a><a href="#index_11-7">第11章-7 LinkedList</a></h2><h2 id="第11章-8-Stack"><a href="#第11章-8-Stack" class="headerlink" title="第11章-8 Stack"></a><a href="#index_11-8">第11章-8 Stack</a></h2><h2 id="第11章-9-Set"><a href="#第11章-9-Set" class="headerlink" title="第11章-9 Set"></a><a href="#index_11-9">第11章-9 Set</a></h2><h2 id="第11章-10-Map"><a href="#第11章-10-Map" class="headerlink" title="第11章-10 Map"></a><a href="#index_11-10">第11章-10 Map</a></h2><h2 id="第11章-11-Queue"><a href="#第11章-11-Queue" class="headerlink" title="第11章-11 Queue"></a><a href="#index_11-11">第11章-11 Queue</a></h2><h2 id="第11章-12-Collection和Iterator"><a href="#第11章-12-Collection和Iterator" class="headerlink" title="第11章-12 Collection和Iterator"></a><a href="#index_11-12">第11章-12 Collection和Iterator</a></h2><h2 id="第11章-13-Foreach与迭代器"><a href="#第11章-13-Foreach与迭代器" class="headerlink" title="第11章-13 Foreach与迭代器"></a><a href="#index_11-13">第11章-13 Foreach与迭代器</a></h2><h3 id="第11章-13-1-适配器方法惯用法→示例源码说明"><a href="#第11章-13-1-适配器方法惯用法→示例源码说明" class="headerlink" title="第11章-13-1 适配器方法惯用法→示例源码说明"></a><a href="#index_11-13-1">第11章-13-1 适配器方法惯用法→示例源码说明</a></h3><h2 id="第11章-14-总结"><a href="#第11章-14-总结" class="headerlink" title="第11章-14 总结"></a><a href="#index_11-14">第11章-14 总结</a></h2><h1 id="第12章-通过异常处理错误"><a href="#第12章-通过异常处理错误" class="headerlink" title="第12章 通过异常处理错误"></a><a href="#index_12">第12章 通过异常处理错误</a></h1><h2 id="第12章-1-概念"><a href="#第12章-1-概念" class="headerlink" title="第12章-1 概念"></a><a href="#index_12-1">第12章-1 概念</a></h2><h2 id="第12章-2-基本异常"><a href="#第12章-2-基本异常" class="headerlink" title="第12章-2 基本异常"></a><a href="#index_12-2">第12章-2 基本异常</a></h2><h3 id="第12章-2-1-捕获异常参数"><a href="#第12章-2-1-捕获异常参数" class="headerlink" title="第12章-2-1 捕获异常参数"></a><a href="#index_12-2-1">第12章-2-1 捕获异常参数</a></h3><h2 id="第12章-3-捕获异常"><a href="#第12章-3-捕获异常" class="headerlink" title="第12章-3 捕获异常"></a><a href="#index_12-3">第12章-3 捕获异常</a></h2><h3 id="第12章-3-1-try块"><a href="#第12章-3-1-try块" class="headerlink" title="第12章-3-1 try块"></a><a href="#index_12-3-1">第12章-3-1 try块</a></h3><h3 id="第12章-3-2-异常处理程序"><a href="#第12章-3-2-异常处理程序" class="headerlink" title="第12章-3-2 异常处理程序"></a><a href="#index_12-3-2">第12章-3-2 异常处理程序</a></h3><h2 id="第12章-4-创建自定义异常"><a href="#第12章-4-创建自定义异常" class="headerlink" title="第12章-4 创建自定义异常"></a><a href="#index_12-4">第12章-4 创建自定义异常</a></h2><h3 id="第12章-4-1-异常与记录日志"><a href="#第12章-4-1-异常与记录日志" class="headerlink" title="第12章-4-1 异常与记录日志"></a><a href="#index_12-4-1">第12章-4-1 异常与记录日志</a></h3><h2 id="第12章-5-异常说明"><a href="#第12章-5-异常说明" class="headerlink" title="第12章-5 异常说明"></a><a href="#index_12-5">第12章-5 异常说明</a></h2><h2 id="第12章-6-捕获所有异常"><a href="#第12章-6-捕获所有异常" class="headerlink" title="第12章-6 捕获所有异常"></a><a href="#index_12-6">第12章-6 捕获所有异常</a></h2><h3 id="第12章-6-1-栈轨迹"><a href="#第12章-6-1-栈轨迹" class="headerlink" title="第12章-6-1 栈轨迹"></a><a href="#index_12-6-1">第12章-6-1 栈轨迹</a></h3><h3 id="第12章-6-2-重新抛出异常"><a href="#第12章-6-2-重新抛出异常" class="headerlink" title="第12章-6-2 重新抛出异常"></a><a href="#index_12-6-2">第12章-6-2 重新抛出异常</a></h3><h3 id="第12章-6-3-异常链"><a href="#第12章-6-3-异常链" class="headerlink" title="第12章-6-3 异常链"></a><a href="#index_12-6-3">第12章-6-3 异常链</a></h3><h2 id="第12章-7-Java标准异常"><a href="#第12章-7-Java标准异常" class="headerlink" title="第12章-7 Java标准异常"></a><a href="#index_12-7">第12章-7 Java标准异常</a></h2><h3 id="第12章-7-1-特例：RuntimeException"><a href="#第12章-7-1-特例：RuntimeException" class="headerlink" title="第12章-7-1 特例：RuntimeException"></a><a href="#index_12-7-1">第12章-7-1 特例：RuntimeException</a></h3><h2 id="第12章-8-使用finally进行清理"><a href="#第12章-8-使用finally进行清理" class="headerlink" title="第12章-8 使用finally进行清理"></a><a href="#index_12-8">第12章-8 使用finally进行清理</a></h2><h3 id="第12章-8-1-finally用来做什么"><a href="#第12章-8-1-finally用来做什么" class="headerlink" title="第12章-8-1 finally用来做什么"></a><a href="#index_12-8-1">第12章-8-1 finally用来做什么</a></h3><h3 id="第12章-8-2-在return中使用finally"><a href="#第12章-8-2-在return中使用finally" class="headerlink" title="第12章-8-2 在return中使用finally"></a><a href="#index_12-8-2">第12章-8-2 在return中使用finally</a></h3><h3 id="第12章-8-3-缺憾：异常缺失"><a href="#第12章-8-3-缺憾：异常缺失" class="headerlink" title="第12章-8-3 缺憾：异常缺失"></a><a href="#index_12-8-3">第12章-8-3 缺憾：异常缺失</a></h3><h2 id="第12章-9-异常的限制"><a href="#第12章-9-异常的限制" class="headerlink" title="第12章-9 异常的限制"></a><a href="#index_12-9">第12章-9 异常的限制</a></h2><h2 id="第12章-10-构造器"><a href="#第12章-10-构造器" class="headerlink" title="第12章-10 构造器"></a><a href="#index_12-10">第12章-10 构造器</a></h2><h2 id="第12章-11-异常匹配"><a href="#第12章-11-异常匹配" class="headerlink" title="第12章-11 异常匹配"></a><a href="#index_12-11">第12章-11 异常匹配</a></h2><h2 id="第12章-12-其他可选方式"><a href="#第12章-12-其他可选方式" class="headerlink" title="第12章-12 其他可选方式"></a><a href="#index_12-12">第12章-12 其他可选方式</a></h2><h3 id="第12章-12-1-历史"><a href="#第12章-12-1-历史" class="headerlink" title="第12章-12-1 历史"></a><a href="#index_12-12-1">第12章-12-1 历史</a></h3><h3 id="第12章-12-2-观点"><a href="#第12章-12-2-观点" class="headerlink" title="第12章-12-2 观点"></a><a href="#index_12-12-2">第12章-12-2 观点</a></h3><h3 id="第12章-12-3-把异常传递给控制台"><a href="#第12章-12-3-把异常传递给控制台" class="headerlink" title="第12章-12-3 把异常传递给控制台"></a><a href="#index_12-12-3">第12章-12-3 把异常传递给控制台</a></h3><h3 id="第12章-12-4-把“被检查的异常”转换为“不检查的异常”"><a href="#第12章-12-4-把“被检查的异常”转换为“不检查的异常”" class="headerlink" title="第12章-12-4 把“被检查的异常”转换为“不检查的异常”"></a><a href="#index_12-12-4">第12章-12-4 把“被检查的异常”转换为“不检查的异常”</a></h3><h2 id="第12章-13-异常使用指南"><a href="#第12章-13-异常使用指南" class="headerlink" title="第12章-13 异常使用指南"></a><a href="#index_12-13">第12章-13 异常使用指南</a></h2><h2 id="第12章-14-总结"><a href="#第12章-14-总结" class="headerlink" title="第12章-14 总结"></a><a href="#index_12-14">第12章-14 总结</a></h2><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a><a href="#index_13">第13章 字符串</a></h1><h2 id="第13章-1-不可变String"><a href="#第13章-1-不可变String" class="headerlink" title="第13章-1 不可变String"></a><a href="#index_13-1">第13章-1 不可变String</a></h2><h2 id="第13章-2-重载“-”与StringBuilder"><a href="#第13章-2-重载“-”与StringBuilder" class="headerlink" title="第13章-2 重载“+”与StringBuilder"></a><a href="#index_13-2">第13章-2 重载“+”与StringBuilder</a></h2><h2 id="第13章-3-无意识的递归"><a href="#第13章-3-无意识的递归" class="headerlink" title="第13章-3 无意识的递归"></a><a href="#index_13-3">第13章-3 无意识的递归</a></h2><h2 id="第13章-4-String上的操作"><a href="#第13章-4-String上的操作" class="headerlink" title="第13章-4 String上的操作"></a><a href="#index_13-4">第13章-4 String上的操作</a></h2><h2 id="第13章-5-格式化输出"><a href="#第13章-5-格式化输出" class="headerlink" title="第13章-5 格式化输出"></a><a href="#index_13-5">第13章-5 格式化输出</a></h2><h3 id="第13章-5-4-格式化说明符"><a href="#第13章-5-4-格式化说明符" class="headerlink" title="第13章-5-4 格式化说明符"></a><a href="#index_13-5-4">第13章-5-4 格式化说明符</a></h3><h2 id="第13章-6-正则表达式"><a href="#第13章-6-正则表达式" class="headerlink" title="第13章-6 正则表达式"></a><a href="#index_13-6">第13章-6 正则表达式</a></h2><h2 id="第13章-7-扫描输入"><a href="#第13章-7-扫描输入" class="headerlink" title="第13章-7 扫描输入"></a><a href="#index_13-7">第13章-7 扫描输入</a></h2><h2 id="第13章-8-StringTokenizer（已废弃）"><a href="#第13章-8-StringTokenizer（已废弃）" class="headerlink" title="第13章-8 StringTokenizer（已废弃）"></a><a href="#index_13-8">第13章-8 StringTokenizer（已废弃）</a></h2><h2 id="第13章-9-总结"><a href="#第13章-9-总结" class="headerlink" title="第13章-9 总结"></a><a href="#index_13-9">第13章-9 总结</a></h2><h1 id="第14章-类型信息（RTTI）"><a href="#第14章-类型信息（RTTI）" class="headerlink" title="第14章 类型信息（RTTI）"></a><a href="#index_14">第14章 类型信息（RTTI）</a></h1><h2 id="第14章-1-为什么需要RTTI"><a href="#第14章-1-为什么需要RTTI" class="headerlink" title="第14章-1 为什么需要RTTI"></a><a href="#index_14-1">第14章-1 为什么需要RTTI</a></h2><h2 id="第14章-2-Class对象"><a href="#第14章-2-Class对象" class="headerlink" title="第14章-2 Class对象"></a><a href="#index_14-2">第14章-2 Class对象</a></h2><h3 id="第14章-2-1-类字面量"><a href="#第14章-2-1-类字面量" class="headerlink" title="第14章-2-1 类字面量"></a><a href="#index_14-2-1">第14章-2-1 类字面量</a></h3><h3 id="第14章-2-2-泛化的Class引用"><a href="#第14章-2-2-泛化的Class引用" class="headerlink" title="第14章-2-2 泛化的Class引用"></a><a href="#index_14-2-2">第14章-2-2 泛化的Class引用</a></h3><h3 id="第14章-2-3-类的转换（原：新的转型语法）"><a href="#第14章-2-3-类的转换（原：新的转型语法）" class="headerlink" title="第14章-2-3 类的转换（原：新的转型语法）"></a><a href="#index_14-2-3">第14章-2-3 类的转换（原：新的转型语法）</a></h3><h2 id="第14章-3-类型转换前先做检查"><a href="#第14章-3-类型转换前先做检查" class="headerlink" title="第14章-3 类型转换前先做检查"></a><a href="#index_14-3">第14章-3 类型转换前先做检查</a></h2><h2 id="第14章-4-注册工厂"><a href="#第14章-4-注册工厂" class="headerlink" title="第14章-4 注册工厂"></a><a href="#index_14-4">第14章-4 注册工厂</a></h2><h2 id="第14章-5-instanceof与Class的等价性"><a href="#第14章-5-instanceof与Class的等价性" class="headerlink" title="第14章-5 instanceof与Class的等价性"></a><a href="#index_14-5">第14章-5 instanceof与Class的等价性</a></h2><h2 id="第14章-6-反射：运行时的类信息"><a href="#第14章-6-反射：运行时的类信息" class="headerlink" title="第14章-6 反射：运行时的类信息"></a><a href="#index_14-6">第14章-6 反射：运行时的类信息</a></h2><h3 id="第14章-6-1-类方法提取器"><a href="#第14章-6-1-类方法提取器" class="headerlink" title="第14章-6-1 类方法提取器"></a><a href="#index_14-6-1">第14章-6-1 类方法提取器</a></h3><h2 id="第14章-7-动态代理"><a href="#第14章-7-动态代理" class="headerlink" title="第14章-7 动态代理"></a><a href="#index_14-7">第14章-7 动态代理</a></h2><h2 id="第14章-8-空对象"><a href="#第14章-8-空对象" class="headerlink" title="第14章-8 空对象"></a><a href="#index_14-8">第14章-8 空对象</a></h2><h3 id="第14章-8-1-模拟对象与桩"><a href="#第14章-8-1-模拟对象与桩" class="headerlink" title="第14章-8-1 模拟对象与桩"></a><a href="#index_14-8-1">第14章-8-1 模拟对象与桩</a></h3><h2 id="第14章-9-接口与类型信息"><a href="#第14章-9-接口与类型信息" class="headerlink" title="第14章-9 接口与类型信息"></a><a href="#index_14-9">第14章-9 接口与类型信息</a></h2><h2 id="第14章-10-总结"><a href="#第14章-10-总结" class="headerlink" title="第14章-10 总结"></a><a href="#index_14-10">第14章-10 总结</a></h2><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a><a href="#index_15">第15章 泛型</a></h1><h2 id="第15章-1-与C-比较"><a href="#第15章-1-与C-比较" class="headerlink" title="第15章-1 与C++比较"></a><a href="#index_15-1">第15章-1 与C++比较</a></h2><h2 id="第15章-2-简单泛型"><a href="#第15章-2-简单泛型" class="headerlink" title="第15章-2 简单泛型"></a><a href="#index_15-2">第15章-2 简单泛型</a></h2><h3 id="第15章-2-1-一个元祖类库"><a href="#第15章-2-1-一个元祖类库" class="headerlink" title="第15章-2-1 一个元祖类库"></a><a href="#index_15-2-1">第15章-2-1 一个元祖类库</a></h3><h3 id="第15章-2-2-一个堆栈类"><a href="#第15章-2-2-一个堆栈类" class="headerlink" title="第15章-2-2 一个堆栈类"></a><a href="#index_15-2-2">第15章-2-2 一个堆栈类</a></h3><h3 id="第15章-2-3-RandomList"><a href="#第15章-2-3-RandomList" class="headerlink" title="第15章-2-3 RandomList"></a><a href="#index_15-2-3">第15章-2-3 RandomList</a></h3><h2 id="第15章-3-泛型接口"><a href="#第15章-3-泛型接口" class="headerlink" title="第15章-3 泛型接口"></a><a href="#index_15-3">第15章-3 泛型接口</a></h2><h2 id="第15章-4-泛型方法"><a href="#第15章-4-泛型方法" class="headerlink" title="第15章-4 泛型方法"></a><a href="#index_15-4">第15章-4 泛型方法</a></h2><h3 id="第15章-4-1-杠杆利用类型参数判断"><a href="#第15章-4-1-杠杆利用类型参数判断" class="headerlink" title="第15章-4-1 杠杆利用类型参数判断"></a><a href="#index_15-4-1">第15章-4-1 杠杆利用类型参数判断</a></h3><h3 id="第15章-4-2-可变参数与泛型方法"><a href="#第15章-4-2-可变参数与泛型方法" class="headerlink" title="第15章-4-2 可变参数与泛型方法"></a><a href="#index_15-4-2">第15章-4-2 可变参数与泛型方法</a></h3><h3 id="第15章-4-3-用于Generator的泛型方法"><a href="#第15章-4-3-用于Generator的泛型方法" class="headerlink" title="第15章-4-3 用于Generator的泛型方法"></a><a href="#index_15-4-3">第15章-4-3 用于Generator的泛型方法</a></h3><h3 id="第15章-4-4-一个通用的Generator"><a href="#第15章-4-4-一个通用的Generator" class="headerlink" title="第15章-4-4 一个通用的Generator"></a><a href="#index_15-4-4">第15章-4-4 一个通用的Generator</a></h3><h3 id="第15章-4-5-简化元祖的使用"><a href="#第15章-4-5-简化元祖的使用" class="headerlink" title="第15章-4-5 简化元祖的使用"></a><a href="#index_15-4-5">第15章-4-5 简化元祖的使用</a></h3><h3 id="第15章-4-6-一个Set实用工具"><a href="#第15章-4-6-一个Set实用工具" class="headerlink" title="第15章-4-6 一个Set实用工具"></a><a href="#index_15-4-6">第15章-4-6 一个Set实用工具</a></h3><h2 id="第15章-5-匿名内部类"><a href="#第15章-5-匿名内部类" class="headerlink" title="第15章-5 匿名内部类"></a><a href="#index_15-5">第15章-5 匿名内部类</a></h2><h2 id="第15章-6-构建复杂模型"><a href="#第15章-6-构建复杂模型" class="headerlink" title="第15章-6 构建复杂模型"></a><a href="#index_15-6">第15章-6 构建复杂模型</a></h2><h2 id="第15章-7-擦除的神秘之处"><a href="#第15章-7-擦除的神秘之处" class="headerlink" title="第15章-7 擦除的神秘之处"></a><a href="#index_15-7">第15章-7 擦除的神秘之处</a></h2><h3 id="第15章-7-1-C-的方式"><a href="#第15章-7-1-C-的方式" class="headerlink" title="第15章-7-1 C++的方式"></a><a href="#index_15-7-1">第15章-7-1 C++的方式</a></h3><h3 id="第15章-7-2-迁移兼容性"><a href="#第15章-7-2-迁移兼容性" class="headerlink" title="第15章-7-2 迁移兼容性"></a><a href="#index_15-7-2">第15章-7-2 迁移兼容性</a></h3><h3 id="第15章-7-3-擦除的问题"><a href="#第15章-7-3-擦除的问题" class="headerlink" title="第15章-7-3 擦除的问题"></a><a href="#index_15-7-3">第15章-7-3 擦除的问题</a></h3><h3 id="第15章-7-4-边界处的动作"><a href="#第15章-7-4-边界处的动作" class="headerlink" title="第15章-7-4 边界处的动作"></a><a href="#index_15-7-4">第15章-7-4 边界处的动作</a></h3><h2 id="第15章-8-擦除的补偿"><a href="#第15章-8-擦除的补偿" class="headerlink" title="第15章-8 擦除的补偿"></a><a href="#index_15-">第15章-8 擦除的补偿</a></h2><h3 id="第15章-8-1-创建类型实例"><a href="#第15章-8-1-创建类型实例" class="headerlink" title="第15章-8-1 创建类型实例"></a><a href="#index_15-8-1">第15章-8-1 创建类型实例</a></h3><h3 id="第15章-8-2-泛型数组"><a href="#第15章-8-2-泛型数组" class="headerlink" title="第15章-8-2 泛型数组"></a><a href="#index_15-8-2">第15章-8-2 泛型数组</a></h3><h2 id="第15章-9-边界"><a href="#第15章-9-边界" class="headerlink" title="第15章-9 边界"></a><a href="#index_15-9">第15章-9 边界</a></h2><h2 id="第15章-10-通配符"><a href="#第15章-10-通配符" class="headerlink" title="第15章-10 通配符"></a><a href="#index_15-10">第15章-10 通配符</a></h2><h3 id="第15章-10-1-编译器有多聪明"><a href="#第15章-10-1-编译器有多聪明" class="headerlink" title="第15章-10-1 编译器有多聪明"></a><a href="#index_15-10-1">第15章-10-1 编译器有多聪明</a></h3><h3 id="第15章-10-2-逆变"><a href="#第15章-10-2-逆变" class="headerlink" title="第15章-10-2 逆变"></a><a href="#index_15-10-2">第15章-10-2 逆变</a></h3><h3 id="第15章-10-3-无界通配符"><a href="#第15章-10-3-无界通配符" class="headerlink" title="第15章-10-3 无界通配符"></a><a href="#index_15-10-3">第15章-10-3 无界通配符</a></h3><h3 id="第15章-10-4-捕获转换（通配符捕获）"><a href="#第15章-10-4-捕获转换（通配符捕获）" class="headerlink" title="第15章-10-4 捕获转换（通配符捕获）"></a><a href="#index_15-10-4">第15章-10-4 捕获转换（通配符捕获）</a></h3><h2 id="第15章-11-问题"><a href="#第15章-11-问题" class="headerlink" title="第15章-11 问题"></a><a href="#index_15-11">第15章-11 问题</a></h2><h3 id="第15章-11-1-任何基本类型都不能作为类型"><a href="#第15章-11-1-任何基本类型都不能作为类型" class="headerlink" title="第15章-11-1 任何基本类型都不能作为类型"></a><a href="#index_15-11-1">第15章-11-1 任何基本类型都不能作为类型</a></h3><h3 id="第15章-11-2-实现参数化接口"><a href="#第15章-11-2-实现参数化接口" class="headerlink" title="第15章-11-2 实现参数化接口"></a><a href="#index_15-11-2">第15章-11-2 实现参数化接口</a></h3><h3 id="第15章-11-3-转型和警告"><a href="#第15章-11-3-转型和警告" class="headerlink" title="第15章-11-3 转型和警告"></a><a href="#index_15-11-3">第15章-11-3 转型和警告</a></h3><h3 id="第15章-11-4-重载"><a href="#第15章-11-4-重载" class="headerlink" title="第15章-11-4 重载"></a><a href="#index_15-11-4">第15章-11-4 重载</a></h3><h3 id="第15章-11-5-基类劫持了接口"><a href="#第15章-11-5-基类劫持了接口" class="headerlink" title="第15章-11-5 基类劫持了接口"></a><a href="#index_15-11-5">第15章-11-5 基类劫持了接口</a></h3><h2 id="第15章-12-自限定的类型"><a href="#第15章-12-自限定的类型" class="headerlink" title="第15章-12 自限定的类型"></a><a href="#index_15-12">第15章-12 自限定的类型</a></h2><h3 id="第15章-12-1-古怪的循环泛型"><a href="#第15章-12-1-古怪的循环泛型" class="headerlink" title="第15章-12-1 古怪的循环泛型"></a><a href="#index_15-12-1">第15章-12-1 古怪的循环泛型</a></h3><h3 id="第15章-12-2-自限定"><a href="#第15章-12-2-自限定" class="headerlink" title="第15章-12-2 自限定"></a><a href="#index_15-12-2">第15章-12-2 自限定</a></h3><h3 id="第15章-12-3-参数协变"><a href="#第15章-12-3-参数协变" class="headerlink" title="第15章-12-3 参数协变"></a><a href="#index_15-12-3">第15章-12-3 参数协变</a></h3><h2 id="第15章-13-动态类型安全"><a href="#第15章-13-动态类型安全" class="headerlink" title="第15章-13 动态类型安全"></a><a href="#index_15-13">第15章-13 动态类型安全</a></h2><h2 id="第15章-14-异常"><a href="#第15章-14-异常" class="headerlink" title="第15章-14 异常"></a><a href="#index_15-14">第15章-14 异常</a></h2><h2 id="第15章-15-混型"><a href="#第15章-15-混型" class="headerlink" title="第15章-15 混型"></a><a href="#index_15-15">第15章-15 混型</a></h2><h3 id="第15章-15-1-C-中的混型"><a href="#第15章-15-1-C-中的混型" class="headerlink" title="第15章-15-1 C++中的混型"></a><a href="#index_15-15-1">第15章-15-1 C++中的混型</a></h3><h3 id="第15章-15-2-与接口混合"><a href="#第15章-15-2-与接口混合" class="headerlink" title="第15章-15-2 与接口混合"></a><a href="#index_15-15-2">第15章-15-2 与接口混合</a></h3><h3 id="第15章-15-3-使用装饰器模式"><a href="#第15章-15-3-使用装饰器模式" class="headerlink" title="第15章-15-3 使用装饰器模式"></a><a href="#index_15-15-3">第15章-15-3 使用装饰器模式</a></h3><h3 id="第15章-15-4-与动态代理混合"><a href="#第15章-15-4-与动态代理混合" class="headerlink" title="第15章-15-4 与动态代理混合"></a><a href="#index_15-15-4">第15章-15-4 与动态代理混合</a></h3><h2 id="第15章-16-潜在类型机制"><a href="#第15章-16-潜在类型机制" class="headerlink" title="第15章-16 潜在类型机制"></a><a href="#index_15-16">第15章-16 潜在类型机制</a></h2><h2 id="第15章-17-对缺乏潜在类型机制的补偿"><a href="#第15章-17-对缺乏潜在类型机制的补偿" class="headerlink" title="第15章-17 对缺乏潜在类型机制的补偿"></a><a href="#index_15-17">第15章-17 对缺乏潜在类型机制的补偿</a></h2><h3 id="第15章-17-1-反射"><a href="#第15章-17-1-反射" class="headerlink" title="第15章-17-1 反射"></a><a href="#index_15-17-1">第15章-17-1 反射</a></h3><h3 id="第15章-17-2-将一个方法应用于序列"><a href="#第15章-17-2-将一个方法应用于序列" class="headerlink" title="第15章-17-2 将一个方法应用于序列"></a><a href="#index_15-17-2">第15章-17-2 将一个方法应用于序列</a></h3><h3 id="第15章-17-3-当你并为碰巧拥有正确的接口时"><a href="#第15章-17-3-当你并为碰巧拥有正确的接口时" class="headerlink" title="第15章-17-3 当你并为碰巧拥有正确的接口时"></a><a href="#index_15-17-3">第15章-17-3 当你并为碰巧拥有正确的接口时</a></h3><h3 id="第15章-17-4-用适配器仿真潜在类型机制"><a href="#第15章-17-4-用适配器仿真潜在类型机制" class="headerlink" title="第15章-17-4 用适配器仿真潜在类型机制"></a><a href="#index_15-17-4">第15章-17-4 用适配器仿真潜在类型机制</a></h3><h2 id="第15章-18-将函数对象用作策略"><a href="#第15章-18-将函数对象用作策略" class="headerlink" title="第15章-18 将函数对象用作策略"></a><a href="#index_15-18">第15章-18 将函数对象用作策略</a></h2><h2 id="第15章-19-总结：转型真的如此之糟吗？"><a href="#第15章-19-总结：转型真的如此之糟吗？" class="headerlink" title="第15章-19 总结：转型真的如此之糟吗？"></a><a href="#index_15-19">第15章-19 总结：转型真的如此之糟吗？</a></h2><h3 id="第15章-19-1-进阶读物"><a href="#第15章-19-1-进阶读物" class="headerlink" title="第15章-19-1 进阶读物"></a><a href="#index_15-19-1">第15章-19-1 进阶读物</a></h3><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a><a href="#index_16">第16章 数组</a></h1><h2 id="第16章-1-数组为什么特殊"><a href="#第16章-1-数组为什么特殊" class="headerlink" title="第16章-1 数组为什么特殊"></a><a href="#index_16-1">第16章-1 数组为什么特殊</a></h2><h2 id="第16章-2-数组是第一级对象"><a href="#第16章-2-数组是第一级对象" class="headerlink" title="第16章-2 数组是第一级对象"></a><a href="#index_16-2">第16章-2 数组是第一级对象</a></h2><h2 id="第16章-3-返回一个数组"><a href="#第16章-3-返回一个数组" class="headerlink" title="第16章-3 返回一个数组"></a><a href="#index_16-3">第16章-3 返回一个数组</a></h2><h2 id="第16章-4-多维数组"><a href="#第16章-4-多维数组" class="headerlink" title="第16章-4 多维数组"></a><a href="#index_16-4">第16章-4 多维数组</a></h2><h2 id="第16章-5-数组与泛型"><a href="#第16章-5-数组与泛型" class="headerlink" title="第16章-5 数组与泛型"></a><a href="#index_16-5">第16章-5 数组与泛型</a></h2><h2 id="第16章-6-创建测试数据"><a href="#第16章-6-创建测试数据" class="headerlink" title="第16章-6 创建测试数据"></a><a href="#index_16-6">第16章-6 创建测试数据</a></h2><h3 id="第16章-6-1-Arrays-fill"><a href="#第16章-6-1-Arrays-fill" class="headerlink" title="第16章-6-1 Arrays.fill()"></a><a href="#index_16-6-1">第16章-6-1 Arrays.fill()</a></h3><h3 id="第16章-6-2-数据生成器"><a href="#第16章-6-2-数据生成器" class="headerlink" title="第16章-6-2 数据生成器"></a><a href="#index_16-6-2">第16章-6-2 数据生成器</a></h3><h3 id="第16章-6-3-从Generator中创建数组"><a href="#第16章-6-3-从Generator中创建数组" class="headerlink" title="第16章-6-3 从Generator中创建数组"></a><a href="#index_16-6-3">第16章-6-3 从Generator中创建数组</a></h3><h2 id="第16章-7-Arrays实用功能"><a href="#第16章-7-Arrays实用功能" class="headerlink" title="第16章-7 Arrays实用功能"></a><a href="#index_16-7">第16章-7 Arrays实用功能</a></h2><h3 id="第16章-7-1-复制数组"><a href="#第16章-7-1-复制数组" class="headerlink" title="第16章-7-1 复制数组"></a><a href="#index_16-7-1">第16章-7-1 复制数组</a></h3><h3 id="第16章-7-2-数组的比较"><a href="#第16章-7-2-数组的比较" class="headerlink" title="第16章-7-2 数组的比较"></a><a href="#index_16-7-2">第16章-7-2 数组的比较</a></h3><h3 id="第16章-7-3-数组元素的比较"><a href="#第16章-7-3-数组元素的比较" class="headerlink" title="第16章-7-3 数组元素的比较"></a><a href="#index_16-7-3">第16章-7-3 数组元素的比较</a></h3><h3 id="第16章-7-4-数组排序"><a href="#第16章-7-4-数组排序" class="headerlink" title="第16章-7-4 数组排序"></a><a href="#index_16-7-4">第16章-7-4 数组排序</a></h3><h3 id="第16章-7-5-在已排序的数组中查找"><a href="#第16章-7-5-在已排序的数组中查找" class="headerlink" title="第16章-7-5 在已排序的数组中查找"></a><a href="#index_16-7-5">第16章-7-5 在已排序的数组中查找</a></h3><h2 id="第16章-8-总结"><a href="#第16章-8-总结" class="headerlink" title="第16章-8 总结"></a><a href="#index_16-8">第16章-8 总结</a></h2><h1 id="第17章-容器深入研究"><a href="#第17章-容器深入研究" class="headerlink" title="第17章 容器深入研究"></a><a href="#index_17">第17章 容器深入研究</a></h1><h2 id="第17章-1-完整容器分类法"><a href="#第17章-1-完整容器分类法" class="headerlink" title="第17章-1 完整容器分类法"></a><a href="#index_17-1">第17章-1 完整容器分类法</a></h2><h2 id="第17章-2-填充容器"><a href="#第17章-2-填充容器" class="headerlink" title="第17章-2 填充容器"></a><a href="#index_17-2">第17章-2 填充容器</a></h2><h3 id="第17章-2-1-一种Generator解决方案"><a href="#第17章-2-1-一种Generator解决方案" class="headerlink" title="第17章-2-1 一种Generator解决方案"></a><a href="#index_17-2-1">第17章-2-1 一种Generator解决方案</a></h3><h3 id="第17章-2-2-Map生成器"><a href="#第17章-2-2-Map生成器" class="headerlink" title="第17章-2-2 Map生成器"></a><a href="#index_17-2-2">第17章-2-2 Map生成器</a></h3><h3 id="第17章-2-3-使用Abstract类"><a href="#第17章-2-3-使用Abstract类" class="headerlink" title="第17章-2-3 使用Abstract类"></a><a href="#index_17-2-3">第17章-2-3 使用Abstract类</a></h3><h2 id="第17章-3-Collection的功能方法"><a href="#第17章-3-Collection的功能方法" class="headerlink" title="第17章-3 Collection的功能方法"></a><a href="#index_17-3">第17章-3 Collection的功能方法</a></h2><h2 id="第17章-4-可选操作"><a href="#第17章-4-可选操作" class="headerlink" title="第17章-4 可选操作"></a><a href="#index_17-4">第17章-4 可选操作</a></h2><h3 id="第17章-4-1-未获支持的操作"><a href="#第17章-4-1-未获支持的操作" class="headerlink" title="第17章-4-1 未获支持的操作"></a><a href="#index_17-4-1">第17章-4-1 未获支持的操作</a></h3><h2 id="第17章-5-List的功能方法"><a href="#第17章-5-List的功能方法" class="headerlink" title="第17章-5 List的功能方法"></a><a href="#index_17-5">第17章-5 List的功能方法</a></h2><h2 id="第17章-6-Set和存储排序"><a href="#第17章-6-Set和存储排序" class="headerlink" title="第17章-6 Set和存储排序"></a><a href="#index_17-6">第17章-6 Set和存储排序</a></h2><h3 id="第17章-6-1-SortedSet"><a href="#第17章-6-1-SortedSet" class="headerlink" title="第17章-6-1 SortedSet"></a><a href="#index_17-6-1">第17章-6-1 SortedSet</a></h3><h2 id="第17章-7-队列"><a href="#第17章-7-队列" class="headerlink" title="第17章-7 队列"></a><a href="#index_17-7">第17章-7 队列</a></h2><h3 id="第17章-7-1-优先级队列"><a href="#第17章-7-1-优先级队列" class="headerlink" title="第17章-7-1 优先级队列"></a><a href="#index_17-7-1">第17章-7-1 优先级队列</a></h3><h3 id="第17章-7-2-双向队列"><a href="#第17章-7-2-双向队列" class="headerlink" title="第17章-7-2 双向队列"></a><a href="#index_17-7-2">第17章-7-2 双向队列</a></h3><h2 id="第17章-8-理解Map"><a href="#第17章-8-理解Map" class="headerlink" title="第17章-8 理解Map"></a><a href="#index_17-8">第17章-8 理解Map</a></h2><h3 id="第17章-8-1-性能"><a href="#第17章-8-1-性能" class="headerlink" title="第17章-8-1 性能"></a><a href="#index_17-8-1">第17章-8-1 性能</a></h3><h3 id="第17章-8-2-SortedMap"><a href="#第17章-8-2-SortedMap" class="headerlink" title="第17章-8-2 SortedMap"></a><a href="#index_17-8-2">第17章-8-2 SortedMap</a></h3><h3 id="第17章-8-3-LinkedHashMap"><a href="#第17章-8-3-LinkedHashMap" class="headerlink" title="第17章-8-3 LinkedHashMap"></a><a href="#index_17-8-3">第17章-8-3 LinkedHashMap</a></h3><h2 id="第17章-9-散列与散列码"><a href="#第17章-9-散列与散列码" class="headerlink" title="第17章-9 散列与散列码"></a><a href="#index_17-9">第17章-9 散列与散列码</a></h2><h3 id="第17章-9-1-理解hashCode"><a href="#第17章-9-1-理解hashCode" class="headerlink" title="第17章-9-1 理解hashCode()"></a><a href="#index_17-9-1">第17章-9-1 理解hashCode()</a></h3><h3 id="第17章-9-2-为速度而散列"><a href="#第17章-9-2-为速度而散列" class="headerlink" title="第17章-9-2 为速度而散列"></a><a href="#index_17-9-2">第17章-9-2 为速度而散列</a></h3><h3 id="第17章-9-3-覆盖hashCode"><a href="#第17章-9-3-覆盖hashCode" class="headerlink" title="第17章-9-3 覆盖hashCode()"></a><a href="#index_17-9-3">第17章-9-3 覆盖hashCode()</a></h3><h2 id="第17章-10-选择接口的不同实现"><a href="#第17章-10-选择接口的不同实现" class="headerlink" title="第17章-10 选择接口的不同实现"></a><a href="#index_17-10">第17章-10 选择接口的不同实现</a></h2><h3 id="第17章-10-1-性能测试框架"><a href="#第17章-10-1-性能测试框架" class="headerlink" title="第17章-10-1 性能测试框架"></a><a href="#index_17-10-1">第17章-10-1 性能测试框架</a></h3><h3 id="第17章-10-2-对List的选择"><a href="#第17章-10-2-对List的选择" class="headerlink" title="第17章-10-2 对List的选择"></a><a href="#index_17-10-2">第17章-10-2 对List的选择</a></h3><h3 id="第17章-10-3-微基准测试的危险"><a href="#第17章-10-3-微基准测试的危险" class="headerlink" title="第17章-10-3 微基准测试的危险"></a><a href="#index_17-10-3">第17章-10-3 微基准测试的危险</a></h3><h3 id="第17章-10-4-对Set的选择"><a href="#第17章-10-4-对Set的选择" class="headerlink" title="第17章-10-4 对Set的选择"></a><a href="#index_17-10-4">第17章-10-4 对Set的选择</a></h3><h3 id="第17章-10-5-对Map的选择"><a href="#第17章-10-5-对Map的选择" class="headerlink" title="第17章-10-5 对Map的选择"></a><a href="#index_17-10-5">第17章-10-5 对Map的选择</a></h3><h2 id="第17章-11-实用方法"><a href="#第17章-11-实用方法" class="headerlink" title="第17章-11 实用方法"></a><a href="#index_17-11">第17章-11 实用方法</a></h2><h3 id="第17章-11-1-List的排序和查询"><a href="#第17章-11-1-List的排序和查询" class="headerlink" title="第17章-11.1 List的排序和查询"></a><a href="#index_17-11-1">第17章-11.1 List的排序和查询</a></h3><h3 id="第17章-11-2-设定Collection或Map为不可修改"><a href="#第17章-11-2-设定Collection或Map为不可修改" class="headerlink" title="第17章-11.2 设定Collection或Map为不可修改"></a><a href="#index_17-11-2">第17章-11.2 设定Collection或Map为不可修改</a></h3><h3 id="第17章-11-3-Collection或Map的同步控制"><a href="#第17章-11-3-Collection或Map的同步控制" class="headerlink" title="第17章-11.3 Collection或Map的同步控制"></a><a href="#index_17-11-3">第17章-11.3 Collection或Map的同步控制</a></h3><h2 id="第17章-12-持有引用"><a href="#第17章-12-持有引用" class="headerlink" title="第17章-12 持有引用"></a><a href="#index_17-12">第17章-12 持有引用</a></h2><h3 id="第17章-12-1-WeakHashMap"><a href="#第17章-12-1-WeakHashMap" class="headerlink" title="第17章-12.1 WeakHashMap"></a><a href="#index_17-12-1">第17章-12.1 WeakHashMap</a></h3><h2 id="第17章-13-Java-1-0-1-1的容器"><a href="#第17章-13-Java-1-0-1-1的容器" class="headerlink" title="第17章-13 Java 1.0-1.1的容器"></a><a href="#index_17-13">第17章-13 Java 1.0-1.1的容器</a></h2><h3 id="第17章-13-1-Vector和Enumeration"><a href="#第17章-13-1-Vector和Enumeration" class="headerlink" title="第17章-13.1 Vector和Enumeration"></a><a href="#index_17-13-1">第17章-13.1 Vector和Enumeration</a></h3><h3 id="第17章-13-2-Hashtable"><a href="#第17章-13-2-Hashtable" class="headerlink" title="第17章-13.2 Hashtable"></a><a href="#index_17-13-2">第17章-13.2 Hashtable</a></h3><h3 id="第17章-13-3-Stack"><a href="#第17章-13-3-Stack" class="headerlink" title="第17章-13.3 Stack"></a><a href="#index_17-13-3">第17章-13.3 Stack</a></h3><h3 id="第17章-13-4-BitSet"><a href="#第17章-13-4-BitSet" class="headerlink" title="第17章-13.4 BitSet"></a><a href="#index_17-4-13-4">第17章-13.4 BitSet</a></h3><h2 id="第17章-14-总结"><a href="#第17章-14-总结" class="headerlink" title="第17章-14 总结"></a><a href="#index_17-14">第17章-14 总结</a></h2><h1 id="第18章-Java-IO系统"><a href="#第18章-Java-IO系统" class="headerlink" title="第18章 Java IO系统"></a><a href="#index_18">第18章 Java IO系统</a></h1><h2 id="第18章-1-File类"><a href="#第18章-1-File类" class="headerlink" title="第18章-1 File类"></a><a href="#index_18-1">第18章-1 File类</a></h2><h3 id="第18章-1-1-目录列表器"><a href="#第18章-1-1-目录列表器" class="headerlink" title="第18章-1-1 目录列表器"></a><a href="#index_18-1-1">第18章-1-1 目录列表器</a></h3><h3 id="第18章-1-2-目录实用工具"><a href="#第18章-1-2-目录实用工具" class="headerlink" title="第18章-1-2 目录实用工具"></a><a href="#index_18-1-2">第18章-1-2 目录实用工具</a></h3><h3 id="第18章-1-3-目录的检查及创建"><a href="#第18章-1-3-目录的检查及创建" class="headerlink" title="第18章-1-3 目录的检查及创建"></a><a href="#index_18-1-3">第18章-1-3 目录的检查及创建</a></h3><h2 id="第18章-2-输入（Input）和输出（Output）"><a href="#第18章-2-输入（Input）和输出（Output）" class="headerlink" title="第18章-2 输入（Input）和输出（Output）"></a><a href="#index_18-2">第18章-2 输入（Input）和输出（Output）</a></h2><h3 id="第18章-2-1-InputStream类型"><a href="#第18章-2-1-InputStream类型" class="headerlink" title="第18章-2-1 InputStream类型"></a><a href="#index_18-2-1">第18章-2-1 InputStream类型</a></h3><h3 id="第18章-2-2-OutputStream类型"><a href="#第18章-2-2-OutputStream类型" class="headerlink" title="第18章-2-2 OutputStream类型"></a><a href="#index_18-2-2">第18章-2-2 OutputStream类型</a></h3><h2 id="第18章-3-添加属性和有用的接口"><a href="#第18章-3-添加属性和有用的接口" class="headerlink" title="第18章-3 添加属性和有用的接口"></a><a href="#index_18-3">第18章-3 添加属性和有用的接口</a></h2><h3 id="第18章-3-1-通过FilterInputStream从InputStream读取数据"><a href="#第18章-3-1-通过FilterInputStream从InputStream读取数据" class="headerlink" title="第18章-3-1 通过FilterInputStream从InputStream读取数据"></a><a href="#index_18-3-1">第18章-3-1 通过FilterInputStream从InputStream读取数据</a></h3><h3 id="第18章-3-2-通过FilterOutputStream从OutputStream写入"><a href="#第18章-3-2-通过FilterOutputStream从OutputStream写入" class="headerlink" title="第18章-3-2 通过FilterOutputStream从OutputStream写入"></a><a href="#index_18-3-2">第18章-3-2 通过FilterOutputStream从OutputStream写入</a></h3><h2 id="第18章-4-Reader和Writer"><a href="#第18章-4-Reader和Writer" class="headerlink" title="第18章-4 Reader和Writer"></a><a href="#index_18-4">第18章-4 Reader和Writer</a></h2><h3 id="第18章-4-1-数据的来源和去处（字节流和字符流类库的关联）"><a href="#第18章-4-1-数据的来源和去处（字节流和字符流类库的关联）" class="headerlink" title="第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）"></a><a href="#index_18-4-1">第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）</a></h3><h3 id="第18章-4-2-更改流的行为"><a href="#第18章-4-2-更改流的行为" class="headerlink" title="第18章-4-2 更改流的行为"></a><a href="#index_18-4-2">第18章-4-2 更改流的行为</a></h3><h3 id="第18章-4-3-未发生变化的类"><a href="#第18章-4-3-未发生变化的类" class="headerlink" title="第18章-4-3 未发生变化的类"></a><a href="#index_18-4-3">第18章-4-3 未发生变化的类</a></h3><h2 id="第18章-5-自我独立的类：RandomAccessFile"><a href="#第18章-5-自我独立的类：RandomAccessFile" class="headerlink" title="第18章-5 自我独立的类：RandomAccessFile"></a><a href="#index_18-5">第18章-5 自我独立的类：RandomAccessFile</a></h2><h2 id="第18章-6-IO流的典型使用方式"><a href="#第18章-6-IO流的典型使用方式" class="headerlink" title="第18章-6 IO流的典型使用方式"></a><a href="#index_18-6">第18章-6 IO流的典型使用方式</a></h2><h3 id="第18章-6-1-缓冲输入文件"><a href="#第18章-6-1-缓冲输入文件" class="headerlink" title="第18章-6-1 缓冲输入文件"></a><a href="#index_18-6-1">第18章-6-1 缓冲输入文件</a></h3><h3 id="第18章-6-2-从内存输入"><a href="#第18章-6-2-从内存输入" class="headerlink" title="第18章-6-2 从内存输入"></a><a href="#index_18-6-2">第18章-6-2 从内存输入</a></h3><h3 id="第18章-6-3-格式化的内存输入"><a href="#第18章-6-3-格式化的内存输入" class="headerlink" title="第18章-6-3 格式化的内存输入"></a><a href="#index_18-6-3">第18章-6-3 格式化的内存输入</a></h3><h3 id="第18章-6-4-基本的文件输出"><a href="#第18章-6-4-基本的文件输出" class="headerlink" title="第18章-6-4 基本的文件输出"></a><a href="#index_18-6-4">第18章-6-4 基本的文件输出</a></h3><h3 id="第18章-6-5-存储和恢复数据"><a href="#第18章-6-5-存储和恢复数据" class="headerlink" title="第18章-6-5 存储和恢复数据"></a><a href="#index_18-6-5">第18章-6-5 存储和恢复数据</a></h3><h3 id="第18章-6-6-随机读写访问文件"><a href="#第18章-6-6-随机读写访问文件" class="headerlink" title="第18章-6-6 随机读写访问文件"></a><a href="#index_18-6-6">第18章-6-6 随机读写访问文件</a></h3><h3 id="第18章-6-7-管道流"><a href="#第18章-6-7-管道流" class="headerlink" title="第18章-6-7 管道流"></a><a href="#index_18-6-7">第18章-6-7 管道流</a></h3><h2 id="第18章-7-文件读写的实用工具"><a href="#第18章-7-文件读写的实用工具" class="headerlink" title="第18章-7 文件读写的实用工具"></a><a href="#index_18-7">第18章-7 文件读写的实用工具</a></h2><h3 id="第18章-7-1-读取二进制文件"><a href="#第18章-7-1-读取二进制文件" class="headerlink" title="第18章-7-1 读取二进制文件"></a><a href="#index_18-7-1">第18章-7-1 读取二进制文件</a></h3><h2 id="第18章-8-标准IO"><a href="#第18章-8-标准IO" class="headerlink" title="第18章-8 标准IO"></a><a href="#index_18-8">第18章-8 标准IO</a></h2><h3 id="第18章-8-1-从标准输入中读取"><a href="#第18章-8-1-从标准输入中读取" class="headerlink" title="第18章-8-1 从标准输入中读取"></a><a href="#index_18-8-1">第18章-8-1 从标准输入中读取</a></h3><h3 id="第18章-8-2-将System-out转换成PrintWriter"><a href="#第18章-8-2-将System-out转换成PrintWriter" class="headerlink" title="第18章-8-2 将System.out转换成PrintWriter"></a><a href="#index_18-8-2">第18章-8-2 将System.out转换成PrintWriter</a></h3><h3 id="第18章-8-3-标准IO重定向"><a href="#第18章-8-3-标准IO重定向" class="headerlink" title="第18章-8-3 标准IO重定向"></a><a href="#index_18-8-3">第18章-8-3 标准IO重定向</a></h3><h2 id="第18章-9-进程控制"><a href="#第18章-9-进程控制" class="headerlink" title="第18章-9 进程控制"></a><a href="#index_18-9">第18章-9 进程控制</a></h2><h2 id="第18章-10-新IO"><a href="#第18章-10-新IO" class="headerlink" title="第18章-10 新IO"></a><a href="#index_18-10">第18章-10 新IO</a></h2><h3 id="第18章-10-1-转换数据"><a href="#第18章-10-1-转换数据" class="headerlink" title="第18章-10-1 转换数据"></a><a href="#index_18-10-1">第18章-10-1 转换数据</a></h3><h3 id="第18章-10-2-获取基本类型"><a href="#第18章-10-2-获取基本类型" class="headerlink" title="第18章-10-2 获取基本类型"></a><a href="#index_18-10-2">第18章-10-2 获取基本类型</a></h3><h3 id="第18章-10-3-视图缓冲器"><a href="#第18章-10-3-视图缓冲器" class="headerlink" title="第18章-10-3 视图缓冲器"></a><a href="#index_18-10-3">第18章-10-3 视图缓冲器</a></h3><h3 id="第18章-10-4-用缓冲器操纵数据"><a href="#第18章-10-4-用缓冲器操纵数据" class="headerlink" title="第18章-10-4 用缓冲器操纵数据"></a><a href="#index_18-10-4">第18章-10-4 用缓冲器操纵数据</a></h3><h3 id="第18章-10-5-缓冲器的细节"><a href="#第18章-10-5-缓冲器的细节" class="headerlink" title="第18章-10-5 缓冲器的细节"></a><a href="#index_18-10-5">第18章-10-5 缓冲器的细节</a></h3><h3 id="第18章-10-6-内存映射文件"><a href="#第18章-10-6-内存映射文件" class="headerlink" title="第18章-10-6 内存映射文件"></a><a href="#index_18-10-6">第18章-10-6 内存映射文件</a></h3><h3 id="第18章-10-7-文件加锁"><a href="#第18章-10-7-文件加锁" class="headerlink" title="第18章-10-7 文件加锁"></a><a href="#index_18-10-7">第18章-10-7 文件加锁</a></h3><h2 id="第18章-11-压缩"><a href="#第18章-11-压缩" class="headerlink" title="第18章-11 压缩"></a><a href="#index_18-11">第18章-11 压缩</a></h2><h3 id="第18章-11-1-用GZIP进行简单压缩"><a href="#第18章-11-1-用GZIP进行简单压缩" class="headerlink" title="第18章-11-1 用GZIP进行简单压缩"></a><a href="#index_18-11-1">第18章-11-1 用GZIP进行简单压缩</a></h3><h3 id="第18章-11-2-用Zip进行多文件保存"><a href="#第18章-11-2-用Zip进行多文件保存" class="headerlink" title="第18章-11-2 用Zip进行多文件保存"></a><a href="#index_18-11-2">第18章-11-2 用Zip进行多文件保存</a></h3><h3 id="第18章-11-3-Java档案文件"><a href="#第18章-11-3-Java档案文件" class="headerlink" title="第18章-11-3 Java档案文件"></a><a href="#index_18-11-3">第18章-11-3 Java档案文件</a></h3><h2 id="第18章-12-对象序列化"><a href="#第18章-12-对象序列化" class="headerlink" title="第18章-12 对象序列化"></a><a href="#index_18-12">第18章-12 对象序列化</a></h2><h3 id="第18章-12-1-寻找类"><a href="#第18章-12-1-寻找类" class="headerlink" title="第18章-12-1 寻找类"></a><a href="#index_18-12-1">第18章-12-1 寻找类</a></h3><h3 id="第18章-12-2-序列化的控制"><a href="#第18章-12-2-序列化的控制" class="headerlink" title="第18章-12-2 序列化的控制"></a><a href="#index_18-12-2">第18章-12-2 序列化的控制</a></h3><h3 id="第18章-12-3-使用“持久性”"><a href="#第18章-12-3-使用“持久性”" class="headerlink" title="第18章-12-3 使用“持久性”"></a><a href="#index_18-12-3">第18章-12-3 使用“持久性”</a></h3><h2 id="第18章-13-XML"><a href="#第18章-13-XML" class="headerlink" title="第18章-13 XML"></a><a href="#index_18-13">第18章-13 XML</a></h2><h2 id="第18章-14-Preferences"><a href="#第18章-14-Preferences" class="headerlink" title="第18章-14 Preferences"></a><a href="#index_18-14">第18章-14 Preferences</a></h2><h2 id="第18章-15-总结"><a href="#第18章-15-总结" class="headerlink" title="第18章-15 总结"></a><a href="#index_18-15">第18章-15 总结</a></h2><h1 id="第19章-枚举类型"><a href="#第19章-枚举类型" class="headerlink" title="第19章 枚举类型"></a><a href="#index_19">第19章 枚举类型</a></h1><h2 id="第19章-1-基本enum特性"><a href="#第19章-1-基本enum特性" class="headerlink" title="第19章-1 基本enum特性"></a><a href="#index_19-1">第19章-1 基本enum特性</a></h2><h3 id="第19章-1-1-将静态导入用于enum"><a href="#第19章-1-1-将静态导入用于enum" class="headerlink" title="第19章-1-1 将静态导入用于enum"></a><a href="#index_19-1-1">第19章-1-1 将静态导入用于enum</a></h3><h2 id="第19章-2-向enum中添加新方法"><a href="#第19章-2-向enum中添加新方法" class="headerlink" title="第19章-2 向enum中添加新方法"></a><a href="#index_19-2">第19章-2 向enum中添加新方法</a></h2><h3 id="第19章-2-1-覆盖enum的方法"><a href="#第19章-2-1-覆盖enum的方法" class="headerlink" title="第19章-2-1 覆盖enum的方法"></a><a href="#index_19-2-1">第19章-2-1 覆盖enum的方法</a></h3><h2 id="第19章-3-switch语句中的enum"><a href="#第19章-3-switch语句中的enum" class="headerlink" title="第19章-3 switch语句中的enum"></a><a href="#index_19-3">第19章-3 switch语句中的enum</a></h2><h2 id="第19章-4-values-的神秘之处"><a href="#第19章-4-values-的神秘之处" class="headerlink" title="第19章-4 values()的神秘之处"></a><a href="#index_19-4">第19章-4 values()的神秘之处</a></h2><h2 id="第19章-5-实现而非继承"><a href="#第19章-5-实现而非继承" class="headerlink" title="第19章-5 实现而非继承"></a><a href="#index_19-5">第19章-5 实现而非继承</a></h2><h2 id="第19章-6-随机选取"><a href="#第19章-6-随机选取" class="headerlink" title="第19章-6 随机选取"></a><a href="#index_19-6">第19章-6 随机选取</a></h2><h2 id="第19章-7-使用接口组织枚举"><a href="#第19章-7-使用接口组织枚举" class="headerlink" title="第19章-7 使用接口组织枚举"></a><a href="#index_19-7">第19章-7 使用接口组织枚举</a></h2><h2 id="第19章-8-使用EnumSet替代标志"><a href="#第19章-8-使用EnumSet替代标志" class="headerlink" title="第19章-8 使用EnumSet替代标志"></a><a href="#index_19-8">第19章-8 使用EnumSet替代标志</a></h2><h2 id="第19章-9-使用EnumMap"><a href="#第19章-9-使用EnumMap" class="headerlink" title="第19章-9 使用EnumMap"></a><a href="#index_19-9">第19章-9 使用EnumMap</a></h2><h2 id="第19章-10-常量相关的方法（枚举类的抽象方法）"><a href="#第19章-10-常量相关的方法（枚举类的抽象方法）" class="headerlink" title="第19章-10 常量相关的方法（枚举类的抽象方法）"></a><a href="#index_19-10">第19章-10 常量相关的方法（枚举类的抽象方法）</a></h2><h3 id="第19章-10-1-使用enum的职责链"><a href="#第19章-10-1-使用enum的职责链" class="headerlink" title="第19章-10-1 使用enum的职责链"></a><a href="#index_19-10-1">第19章-10-1 使用enum的职责链</a></h3><h3 id="第19章-10-2-使用enum的状态机"><a href="#第19章-10-2-使用enum的状态机" class="headerlink" title="第19章-10-2 使用enum的状态机"></a><a href="#index_19-10-2">第19章-10-2 使用enum的状态机</a></h3><h2 id="第19章-11-多路分发"><a href="#第19章-11-多路分发" class="headerlink" title="第19章-11 多路分发"></a><a href="#index_19-11">第19章-11 多路分发</a></h2><h3 id="第19章-11-1-使用enum分发"><a href="#第19章-11-1-使用enum分发" class="headerlink" title="第19章-11-1 使用enum分发"></a><a href="#index_19-11-1">第19章-11-1 使用enum分发</a></h3><h3 id="第19章-11-2-使用常量相关的方法"><a href="#第19章-11-2-使用常量相关的方法" class="headerlink" title="第19章-11-2 使用常量相关的方法"></a><a href="#index_19-11-2">第19章-11-2 使用常量相关的方法</a></h3><h3 id="第19章-11-3-使用EnumMap分发"><a href="#第19章-11-3-使用EnumMap分发" class="headerlink" title="第19章-11-3 使用EnumMap分发"></a><a href="#index_19-11-3">第19章-11-3 使用EnumMap分发</a></h3><h3 id="第19章-11-4-使用二维数组"><a href="#第19章-11-4-使用二维数组" class="headerlink" title="第19章-11-4 使用二维数组"></a><a href="#index_19-11-4">第19章-11-4 使用二维数组</a></h3><h2 id="第19章-12-总结"><a href="#第19章-12-总结" class="headerlink" title="第19章-12 总结"></a><a href="#index_19-12">第19章-12 总结</a></h2><h1 id="第20章-注解"><a href="#第20章-注解" class="headerlink" title="第20章 注解"></a><a href="#index_20">第20章 注解</a></h1><h2 id="第20章-1-基本语法"><a href="#第20章-1-基本语法" class="headerlink" title="第20章-1 基本语法"></a><a href="#index_20-1">第20章-1 基本语法</a></h2><h3 id="第20章-1-1-定义注解"><a href="#第20章-1-1-定义注解" class="headerlink" title="第20章-1-1 定义注解"></a><a href="#index_20-1-1">第20章-1-1 定义注解</a></h3><h3 id="第20章-1-2-元注解"><a href="#第20章-1-2-元注解" class="headerlink" title="第20章-1-2 元注解"></a><a href="#index_20-1-2">第20章-1-2 元注解</a></h3><h2 id="第20章-2-编写注解处理器"><a href="#第20章-2-编写注解处理器" class="headerlink" title="第20章-2 编写注解处理器"></a><a href="#index_20-2">第20章-2 编写注解处理器</a></h2><h3 id="第20章-2-1-注解元素"><a href="#第20章-2-1-注解元素" class="headerlink" title="第20章-2-1 注解元素"></a><a href="#index_20-2-1">第20章-2-1 注解元素</a></h3><h3 id="第20章-2-2-默认值限制"><a href="#第20章-2-2-默认值限制" class="headerlink" title="第20章-2-2 默认值限制"></a><a href="#index_20-2-2">第20章-2-2 默认值限制</a></h3><h3 id="第20章-2-3-生成外部文件"><a href="#第20章-2-3-生成外部文件" class="headerlink" title="第20章-2-3 生成外部文件"></a><a href="#index_20-2-3">第20章-2-3 生成外部文件</a></h3><h3 id="第20章-2-4-注解不支持继承"><a href="#第20章-2-4-注解不支持继承" class="headerlink" title="第20章-2-4 注解不支持继承"></a><a href="#index_20-2-4">第20章-2-4 注解不支持继承</a></h3><h3 id="第20章-2-5-实现处理器"><a href="#第20章-2-5-实现处理器" class="headerlink" title="第20章-2-5 实现处理器"></a><a href="#index_20-2-5">第20章-2-5 实现处理器</a></h3><h2 id="第20章-3-使用apt处理注解"><a href="#第20章-3-使用apt处理注解" class="headerlink" title="第20章-3 使用apt处理注解"></a><a href="#index_20-3">第20章-3 使用apt处理注解</a></h2><h2 id="第20章-4-将观察者模式用于apt"><a href="#第20章-4-将观察者模式用于apt" class="headerlink" title="第20章-4 将观察者模式用于apt"></a><a href="#index_20-4">第20章-4 将观察者模式用于apt</a></h2><h2 id="第20章-5-基于注解的单元测试"><a href="#第20章-5-基于注解的单元测试" class="headerlink" title="第20章-5 基于注解的单元测试"></a><a href="#index_20-5">第20章-5 基于注解的单元测试</a></h2><h3 id="第20章-5-1-将-Unit用于泛型"><a href="#第20章-5-1-将-Unit用于泛型" class="headerlink" title="第20章-5-1 将@Unit用于泛型"></a><a href="#index_20-5-1">第20章-5-1 将@Unit用于泛型</a></h3><h3 id="第20章-5-2-不需要任何“套件”"><a href="#第20章-5-2-不需要任何“套件”" class="headerlink" title="第20章-5-2 不需要任何“套件”"></a><a href="#index_20-5-2">第20章-5-2 不需要任何“套件”</a></h3><h3 id="第20章-5-3-实现-Unit"><a href="#第20章-5-3-实现-Unit" class="headerlink" title="第20章-5-3 实现@Unit"></a><a href="#index_20-5-3">第20章-5-3 实现@Unit</a></h3><h3 id="第20章-5-4-移除测试代码"><a href="#第20章-5-4-移除测试代码" class="headerlink" title="第20章-5-4 移除测试代码"></a><a href="#index_20-5-4">第20章-5-4 移除测试代码</a></h3><h2 id="第20章-6-总结"><a href="#第20章-6-总结" class="headerlink" title="第20章-6 总结"></a><a href="#index_20-6">第20章-6 总结</a></h2><h1 id="第21章-并发"><a href="#第21章-并发" class="headerlink" title="第21章 并发"></a><a href="#index_21">第21章 并发</a></h1><h2 id="第21章-1-并发的多面性"><a href="#第21章-1-并发的多面性" class="headerlink" title="第21章-1 并发的多面性"></a><a href="#index_21-1">第21章-1 并发的多面性</a></h2><h2 id="第21章-2-基本的线程机制"><a href="#第21章-2-基本的线程机制" class="headerlink" title="第21章-2 基本的线程机制"></a><a href="#index_21-2">第21章-2 基本的线程机制</a></h2><h2 id="第21章-3-共享受限资源"><a href="#第21章-3-共享受限资源" class="headerlink" title="第21章-3 共享受限资源"></a><a href="#index_21-3">第21章-3 共享受限资源</a></h2><h2 id="第21章-4-终结任务"><a href="#第21章-4-终结任务" class="headerlink" title="第21章-4 终结任务"></a><a href="#index_21-4">第21章-4 终结任务</a></h2><h2 id="第21章-5-线程之间的协作"><a href="#第21章-5-线程之间的协作" class="headerlink" title="第21章-5 线程之间的协作"></a><a href="#index_21-5">第21章-5 线程之间的协作</a></h2><h2 id="第21章-6-死锁"><a href="#第21章-6-死锁" class="headerlink" title="第21章-6 死锁"></a><a href="#index_21-6">第21章-6 死锁</a></h2><h2 id="第21章-7-新类库中的构件"><a href="#第21章-7-新类库中的构件" class="headerlink" title="第21章-7 新类库中的构件"></a><a href="#index_21-7">第21章-7 新类库中的构件</a></h2><h2 id="第21章-8-仿真"><a href="#第21章-8-仿真" class="headerlink" title="第21章-8 仿真"></a><a href="#index_21-8">第21章-8 仿真</a></h2><h2 id="第21章-9-性能调优"><a href="#第21章-9-性能调优" class="headerlink" title="第21章-9 性能调优"></a><a href="#index_21-9">第21章-9 性能调优</a></h2><h2 id="第21章-10-活动对象"><a href="#第21章-10-活动对象" class="headerlink" title="第21章-10 活动对象"></a><a href="#index_21-10">第21章-10 活动对象</a></h2><h2 id="第21章-11-总结"><a href="#第21章-11-总结" class="headerlink" title="第21章-11 总结"></a><a href="#index_21-11">第21章-11 总结</a></h2><h1 id="第22章-图形化用户界面"><a href="#第22章-图形化用户界面" class="headerlink" title="第22章 图形化用户界面"></a><a href="#index_22">第22章 图形化用户界面</a></h1><hr>
<h1 id="📖参看"><a href="#📖参看" class="headerlink" title="📖参看"></a>📖参看</h1><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>主要参看📖</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ul>
<li><a href="/2021/04/15/Java/" title="Java">Java</a></li>
<li><a href="/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B/" title="《Thinking-in-Java》">《Thinking-in-Java》</a></li>
</ul>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>分类：解决问题✅</span></div>
    <div class="xContent"><div class="inner">
        <ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/heimu24/article/details/81189700">Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000019710978">(……) inline-block的元素垂直居中的问题 - SegmentFault 思否</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itranslater.com/qa/details/2117469006360740864">如何在GitHub风格的Markdown中添加脚注？ - ITranslater</a></li>
</ul>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>分类：工具🧰&ensp;|&ensp;查阅🔍</span></div>
    <div class="xContent"><div class="inner">
        <ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc()">calc() - CSS（层叠样式表） | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/fit-content">fit-content() - CSS（层叠样式表） | MDN</a></li>
<li>【★】【GFM】<a target="_blank" rel="noopener" href="https://github.github.com/gfm/">GitHub Flavored Markdown Spec - github.github.com</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3schools.com/colors/colors_picker.asp">HTML Color Picker</a></li>
<li><a target="_blank" rel="noopener" href="http://www.oicqzone.com/pc/2015083122336.html">HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 教程 | 菜鸟教程</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F446/">👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F4D6/">📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F517/">🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F5CE/">🗎 - 文献: U+1F5CE - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/203B/">※ - 参考标志: U+203B - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/260C/">☌ - 关联: U+260C - Unicode 字符百科</a></li>
</ul>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>分类：其他（二度及以上关联☌）</span></div>
    <div class="xContent"><div class="inner">
         
    </div></div>
    </div>

<hr>
<h1 id="※参考和引用"><a href="#※参考和引用" class="headerlink" title="※参考和引用"></a>※参考和引用</h1><ol>
<li><a id="cite_note-1" href="#cite_ref-1" aria-label="跳转" title="跳转">^</a>&ensp;<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象程序设计 - 维基百科，自由的百科全书</a></li>
<li><a id="cite_note-2" href="#cite_ref-2" aria-label="跳转" title="跳转">^</a>&ensp;<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792">面向对象程序设计（一种计算机编程架构）_百度百科</a></li>
</ol>
<hr>
<h1 id="🔗外部链接"><a href="#🔗外部链接" class="headerlink" title="🔗外部链接"></a>🔗外部链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54">Wikipedia’s external link ltr-icon</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
</ul>

            </div>
            
                <div class="kratos-copyright text-center clearfix">
                    <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
                </div>
            
            <footer class="kratos-entry-footer clearfix">
                
                    <div class="post-like-donate text-center clearfix" id="post-like-donate">
                    
                    
                        <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                        <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://suitelhy.github.io/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://suitelhy.github.io/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/";
            const title         = "「《Thinking in Java》（第4版） ← 整理手册」";
            const excerpt       = `目录
第1章 面向对象导论

1.1 抽象过程
1.2 每个对象都有一个接口
1.3 每个对象都提供服务
1.4 被隐藏的具体实现
1.5 复用具体实现
1.6 继承
1.6.1 “是一个”与“像是一个”的关系


1.7 伴随多态的...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                    
                    </div>
                
                <div class="footer-tag clearfix">
                    <div class="pull-left">
                    <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/Java/" rel="tag">Java</a>, <a class="tag-none-link" href="/tags/%E3%80%8AThinking-in-Java%E3%80%8B/" rel="tag">《Thinking in Java》</a>, <a class="tag-none-link" href="/tags/ComputerScience/" rel="tag">计算机科学</a>
                    </div>
                    <div class="pull-date">
                    <span>最后编辑：2021-04-22</span>
                    </div>
                </div>
            </footer>
        </div>
        
            <nav class="navigation post-navigation clearfix" role="navigation">
                
                <div class="nav-previous clearfix">
                    <a title=" 实践手册" href="/2021/04/16/实践手册/">&lt; 上一篇</a>
                </div>
                
                
                <div class="nav-next clearfix">
                    <a title=" 《Thinking in Java》" href="/2021/04/16/《Thinking-in-Java》/">下一篇 &gt;</a>
                </div>
                
            </nav>
        
        
    </article>
</section>

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="https://avatars.githubusercontent.com/SuiteLHY" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">青春倚靠着时光，轻快的脚步在世间流韵； 云上光华从指间绽放，地上人们自由而幸福。</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-text">第1章 面向对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Object-oriend-Programming%EF%BC%8COOP%EF%BC%89%E3%80%82"><span class="toc-text">面向对象程序设计（Object-oriend Programming，OOP）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">主要特征：封装性、继承性、多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BC%98%E7%82%B9"><span class="toc-text">设计优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="toc-text">设计缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-text">名词解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">第1章-1 抽象过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-2-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">第1章-2 每个对象都有一个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-3-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-text">第1章-3 每个对象都提供服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-4-%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">第1章-4 被隐藏的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-5-%E5%A4%8D%E7%94%A8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">第1章-5 复用具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-%E7%BB%A7%E6%89%BF"><span class="toc-text">第1章-6 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-1-%E2%80%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E4%B8%8E%E2%80%9C%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">第1章-6-1 “是一个”与“像是一个”的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-7-%E4%BC%B4%E9%9A%8F%E5%A4%9A%E6%80%81%E7%9A%84%E5%8F%AF%E4%BA%92%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-text">第1章-7 伴随多态的可互换对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-8-%E5%8D%95%E6%A0%B9%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-text">第1章-8 单根继承结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-%E5%AE%B9%E5%99%A8"><span class="toc-text">第1章-9 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-1-%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-text">第1章-9-1 参数化类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">第1章-10 对象的创建和生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">第1章-11 异常处理：错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">第1章-12 并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-Java%E4%B8%8EInternet"><span class="toc-text">第1章-13 Java与Internet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-1-Web%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">第1章-13-1 Web是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-text">第1章-13-2 客户端编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-text">第1章-13-3 服务器端编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第1章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-text">第2章 一切都是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-1-%E7%94%A8%E5%BC%95%E7%94%A8%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1"><span class="toc-text">第2章-1 用引用操纵对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-%E5%BF%85%E9%A1%BB%E7%94%B1%E4%BD%A0%E5%88%9B%E5%BB%BA%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E3%80%90%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-text">第2章-2 必须由你创建所有对象【底层存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-1-%E5%AD%98%E5%82%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E3%80%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-text">第2章-2-1 存储到什么地方【对象的存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-text">寄存器。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%EF%BC%88Heap%EF%BC%89%E3%80%82"><span class="toc-text">堆栈（Heap）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Stack%EF%BC%89%E3%80%82"><span class="toc-text">堆（Stack）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%89%E3%80%82"><span class="toc-text">常量存储（常量池）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9ERAM%E5%AD%98%E5%82%A8%E3%80%82"><span class="toc-text">非RAM存储。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-2-%E7%89%B9%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">第2章-2-2 特例：基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-3-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">第2章-2-3 Java中的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-3-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">第2章-3 永远不需要销毁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第2章-4 创建新的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-5-%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">第2章-5 方法、参数和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-text">第2章-6 构建一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-7-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-text">第2章-7 你的第一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-8-%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E6%A1%A3"><span class="toc-text">第2章-8 注释和嵌入式文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-9-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-text">第2章-9 编码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第2章-10 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-11-%E7%BB%83%E4%B9%A0"><span class="toc-text">第2章-11 练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-1-%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5"><span class="toc-text">第3章-1 更简单的打印语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-2-%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-2 使用Java操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-3-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">第3章-3 优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-%E8%B5%8B%E5%80%BC"><span class="toc-text">第3章-4 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84%E5%88%AB%E5%90%8D%E9%97%AE%E9%A2%98"><span class="toc-text">第3章-4.1 方法调用中的别名问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-5 算数操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-1-%E4%B8%80%E5%85%83%E5%8A%A0%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-5-1 一元加减操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-6-%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F"><span class="toc-text">第3章-6 自动递增和递减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-7 关系操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-1-%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-text">第3章-7-1 测试对象的等价性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-8 逻辑操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-1-%E7%9F%AD%E8%B7%AF"><span class="toc-text">第3章-8-1 短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-%E7%9B%B4%E6%8E%A5%E5%B8%B8%E9%87%8F"><span class="toc-text">第3章-9 直接常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-1-%E6%8C%87%E6%95%B0%E8%AE%B0%E6%95%B0%E6%B3%95"><span class="toc-text">第3章-9-1 指数记数法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-10-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-10 按位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-11-%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-11 移位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-12-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6if-else"><span class="toc-text">第3章-12 三元操作符if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%92%8C"><span class="toc-text">第3章-13 字符串操作符+和&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-14-%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">第3章-14 使用操作符时常犯的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-15 类型转换操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-1-%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5"><span class="toc-text">第3章-15-1 截尾和舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-2-%E6%8F%90%E5%8D%87"><span class="toc-text">第3章-15-2 提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-16-Java%E6%B2%A1%E6%9C%89sizeof"><span class="toc-text">第3章-16 Java没有sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B0%8F%E7%BB%93"><span class="toc-text">第3章-17 操作符小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-18-%E6%80%BB%E7%BB%93"><span class="toc-text">第3章-18 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">第4章 控制执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text">第5章 初始化与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-1-%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%A1%AE%E4%BF%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-1 用构造器确保初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-2-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">第5章-2 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">第5章-3 默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">第5章-4 this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-1-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">第5章-4-1 在构造器中调用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-2-static%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">第5章-4-2 static的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">第5章-5 清理：终结处理和垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-6 成员初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-1-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-6-1 指定初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7 构造器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">第5章-7-1 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-2-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7-2 静态数据的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-3-%E6%98%BE%E5%BC%8F%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7-3 显式的静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-4-%E9%9D%9E%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7-4 非静态实例初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-8 数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">第5章-8-1 可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第5章-9 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enum%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">第5章-9-1 枚举类（enum）——基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">第5章-9-2 枚举类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第5章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">第6章 访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-%E5%8C%85%EF%BC%9A%E5%BA%93%E5%8D%95%E5%85%83"><span class="toc-text">第6章-1 包：库单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-1-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-text">第6章-1-1 代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-2-%E5%88%9B%E5%BB%BA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%8C%85%E5%90%8D"><span class="toc-text">第6章-1-2 创建独一无二的包名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-3-%E5%AE%9A%E5%88%B6%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-text">第6章-1-3 定制工具库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-4-%E7%94%A8import%E6%94%B9%E5%8F%98%E8%A1%8C%E4%B8%BA"><span class="toc-text">第6章-1-4 用import改变行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-5-%E5%AF%B9%E4%BD%BF%E7%94%A8%E5%8C%85%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-text">第6章-1-5 对使用包的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-2-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-text">第6章-2 Java访问权限修饰词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">第6章-3 接口和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-4-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">第6章-4 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-5-%E6%80%BB%E7%BB%93"><span class="toc-text">第6章-5 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB"><span class="toc-text">第7章 复用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-1-%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-text">第7章-1 组合语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">第7章-2 继承语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB"><span class="toc-text">第7章-2-1 初始化基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E7%AC%AC7%E7%AB%A0-2-2-%E9%87%8D%E5%86%99"><span class="toc-text">【拓展】第7章-2-2 重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-3-%E4%BB%A3%E7%90%86"><span class="toc-text">第7章-3 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">第7章-4 结合使用组合和继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-5-%E5%9C%A8%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-text">第7章-5 在组合与继承之间选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-6-protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">第7章-6 protected关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第7章-7 向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">第7章-8 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-1-final%E6%95%B0%E6%8D%AE"><span class="toc-text">第7章-8-1 final数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-2-final%E6%96%B9%E6%B3%95"><span class="toc-text">第7章-8-2 final方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-3-final%E7%B1%BB"><span class="toc-text">第7章-8-3 final类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-4-%E6%9C%89%E5%85%B3final%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-text">第7章-8-4 有关final的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">第7章-9 初始化类及类的加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第7章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-text">第8章 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-1-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第8章-1 再论向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-%E8%BD%AC%E6%9C%BA"><span class="toc-text">第8章-2 转机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">第8章-3 构造器和多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-4-%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">第8章-4 协变返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-text">第8章-5 用继承进行设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-1-%E7%BA%AF%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8B%93%E5%B1%95"><span class="toc-text">第8章-5-1 纯继承与拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-text">第8章-5-2 向下转型与运行时类型识别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-text">第8章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">第9章-1 抽象类和抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-2-%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-2 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-3-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-text">第9章-3 完全解耦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-4-Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">第9章-4 Java中的多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-5-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-5 通过继承来拓展接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-6-%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-6 适配接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-7-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F"><span class="toc-text">第9章-7 接口中的域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-8-%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-8 嵌套接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-text">第9章-9 接口与工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第9章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-1-%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-1 创建内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-2-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-2 链接到外部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-3-%E4%BD%BF%E7%94%A8-this%E4%B8%8E-new"><span class="toc-text">第10章-3 使用.this与.new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-4-%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第10章-4 内部类与向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-5-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-5 在方法和作用域内的内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-6 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-7-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text">第10章-7 嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-8 为什么需要内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-9-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">第10章-9 内部类的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-10-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A6%86%E7%9B%96%E5%90%97"><span class="toc-text">第10章-10 内部类可以被覆盖吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-11-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-11 局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-12-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">第10章-12 内部类标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-13-%E6%80%BB%E7%BB%93"><span class="toc-text">第10章-13 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-text">第11章 持有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-1-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">第11章-1 泛型和类型安全的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">第11章-2 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">第11章-3 添加一组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-4-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-text">第11章-4 容器的打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-5-List%EF%BC%88%E5%8E%9F%E7%90%86-amp-%E7%AE%80%E4%BB%8B%EF%BC%89"><span class="toc-text">第11章-5 List（原理 &amp; 简介）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-6-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">第11章-6 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-7-LinkedList"><span class="toc-text">第11章-7 LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-8-Stack"><span class="toc-text">第11章-8 Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-9-Set"><span class="toc-text">第11章-9 Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-10-Map"><span class="toc-text">第11章-10 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-11-Queue"><span class="toc-text">第11章-11 Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-12-Collection%E5%92%8CIterator"><span class="toc-text">第11章-12 Collection和Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-Foreach%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">第11章-13 Foreach与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%96%B9%E6%B3%95%E6%83%AF%E7%94%A8%E6%B3%95%E2%86%92%E7%A4%BA%E4%BE%8B%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-text">第11章-13-1 适配器方法惯用法→示例源码说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第11章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-text">第12章 通过异常处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">第12章-1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-2 基本异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-1-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%8F%82%E6%95%B0"><span class="toc-text">第12章-2-1 捕获异常参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-3 捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-1-try%E5%9D%97"><span class="toc-text">第12章-3-1 try块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">第12章-3-2 异常处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-4 创建自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-1-%E5%BC%82%E5%B8%B8%E4%B8%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-text">第12章-4-1 异常与记录日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-5-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-text">第12章-5 异常说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-6 捕获所有异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-1-%E6%A0%88%E8%BD%A8%E8%BF%B9"><span class="toc-text">第12章-6-1 栈轨迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-2-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-6-2 重新抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-3-%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-text">第12章-6-3 异常链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-Java%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-7 Java标准异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-1-%E7%89%B9%E4%BE%8B%EF%BC%9ARuntimeException"><span class="toc-text">第12章-7-1 特例：RuntimeException</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-%E4%BD%BF%E7%94%A8finally%E8%BF%9B%E8%A1%8C%E6%B8%85%E7%90%86"><span class="toc-text">第12章-8 使用finally进行清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-1-finally%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">第12章-8-1 finally用来做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-2-%E5%9C%A8return%E4%B8%AD%E4%BD%BF%E7%94%A8finally"><span class="toc-text">第12章-8-2 在return中使用finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-3-%E7%BC%BA%E6%86%BE%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BC%BA%E5%A4%B1"><span class="toc-text">第12章-8-3 缺憾：异常缺失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-9-%E5%BC%82%E5%B8%B8%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">第12章-9 异常的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-10-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">第12章-10 构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%8C%B9%E9%85%8D"><span class="toc-text">第12章-11 异常匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89%E6%96%B9%E5%BC%8F"><span class="toc-text">第12章-12 其他可选方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-1-%E5%8E%86%E5%8F%B2"><span class="toc-text">第12章-12-1 历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-2-%E8%A7%82%E7%82%B9"><span class="toc-text">第12章-12-2 观点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-3-%E6%8A%8A%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92%E7%BB%99%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">第12章-12-3 把异常传递给控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-4-%E6%8A%8A%E2%80%9C%E8%A2%AB%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E2%80%9C%E4%B8%8D%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D"><span class="toc-text">第12章-12-4 把“被检查的异常”转换为“不检查的异常”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-13-%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-text">第12章-13 异常使用指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第12章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">第13章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-1-%E4%B8%8D%E5%8F%AF%E5%8F%98String"><span class="toc-text">第13章-1 不可变String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-2-%E9%87%8D%E8%BD%BD%E2%80%9C-%E2%80%9D%E4%B8%8EStringBuilder"><span class="toc-text">第13章-2 重载“+”与StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-3-%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-text">第13章-3 无意识的递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-4-String%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">第13章-4 String上的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">第13章-5 格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">第13章-5-4 格式化说明符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">第13章-6 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-7-%E6%89%AB%E6%8F%8F%E8%BE%93%E5%85%A5"><span class="toc-text">第13章-7 扫描输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-8-StringTokenizer%EF%BC%88%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="toc-text">第13章-8 StringTokenizer（已废弃）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-9-%E6%80%BB%E7%BB%93"><span class="toc-text">第13章-9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%88RTTI%EF%BC%89"><span class="toc-text">第14章 类型信息（RTTI）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81RTTI"><span class="toc-text">第14章-1 为什么需要RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-Class%E5%AF%B9%E8%B1%A1"><span class="toc-text">第14章-2 Class对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-1-%E7%B1%BB%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">第14章-2-1 类字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-2-%E6%B3%9B%E5%8C%96%E7%9A%84Class%E5%BC%95%E7%94%A8"><span class="toc-text">第14章-2-2 泛化的Class引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-3-%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%8E%9F%EF%BC%9A%E6%96%B0%E7%9A%84%E8%BD%AC%E5%9E%8B%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-text">第14章-2-3 类的转换（原：新的转型语法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%8D%E5%85%88%E5%81%9A%E6%A3%80%E6%9F%A5"><span class="toc-text">第14章-3 类型转换前先做检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-4-%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82"><span class="toc-text">第14章-4 注册工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-5-instanceof%E4%B8%8EClass%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-text">第14章-5 instanceof与Class的等价性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-%E5%8F%8D%E5%B0%84%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-text">第14章-6 反射：运行时的类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-1-%E7%B1%BB%E6%96%B9%E6%B3%95%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-text">第14章-6-1 类方法提取器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-7-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">第14章-7 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">第14章-8 空对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-1-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A1%A9"><span class="toc-text">第14章-8-1 模拟对象与桩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">第14章-9 接口与类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第14章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-text">第15章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-1-%E4%B8%8EC-%E6%AF%94%E8%BE%83"><span class="toc-text">第15章-1 与C++比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-text">第15章-2 简单泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-1-%E4%B8%80%E4%B8%AA%E5%85%83%E7%A5%96%E7%B1%BB%E5%BA%93"><span class="toc-text">第15章-2-1 一个元祖类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-2-%E4%B8%80%E4%B8%AA%E5%A0%86%E6%A0%88%E7%B1%BB"><span class="toc-text">第15章-2-2 一个堆栈类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-3-RandomList"><span class="toc-text">第15章-2-3 RandomList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-3-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">第15章-3 泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">第15章-4 泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-1-%E6%9D%A0%E6%9D%86%E5%88%A9%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%88%A4%E6%96%AD"><span class="toc-text">第15章-4-1 杠杆利用类型参数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">第15章-4-2 可变参数与泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-3-%E7%94%A8%E4%BA%8EGenerator%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">第15章-4-3 用于Generator的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-4-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Generator"><span class="toc-text">第15章-4-4 一个通用的Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-5-%E7%AE%80%E5%8C%96%E5%85%83%E7%A5%96%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">第15章-4-5 简化元祖的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-6-%E4%B8%80%E4%B8%AASet%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">第15章-4-6 一个Set实用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第15章-5 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">第15章-6 构建复杂模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-%E6%93%A6%E9%99%A4%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-text">第15章-7 擦除的神秘之处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-1-C-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">第15章-7-1 C++的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-2-%E8%BF%81%E7%A7%BB%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">第15章-7-2 迁移兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-3-%E6%93%A6%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">第15章-7-3 擦除的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-4-%E8%BE%B9%E7%95%8C%E5%A4%84%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-text">第15章-7-4 边界处的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-%E6%93%A6%E9%99%A4%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-text">第15章-8 擦除的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-1-%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="toc-text">第15章-8-1 创建类型实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-2-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">第15章-8-2 泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-9-%E8%BE%B9%E7%95%8C"><span class="toc-text">第15章-9 边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">第15章-10 通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-1-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E5%A4%9A%E8%81%AA%E6%98%8E"><span class="toc-text">第15章-10-1 编译器有多聪明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-2-%E9%80%86%E5%8F%98"><span class="toc-text">第15章-10-2 逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-3-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">第15章-10-3 无界通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-4-%E6%8D%95%E8%8E%B7%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7%EF%BC%89"><span class="toc-text">第15章-10-4 捕获转换（通配符捕获）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-%E9%97%AE%E9%A2%98"><span class="toc-text">第15章-11 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-1-%E4%BB%BB%E4%BD%95%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E9%83%BD%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="toc-text">第15章-11-1 任何基本类型都不能作为类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-2-%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-text">第15章-11-2 实现参数化接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-3-%E8%BD%AC%E5%9E%8B%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="toc-text">第15章-11-3 转型和警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-4-%E9%87%8D%E8%BD%BD"><span class="toc-text">第15章-11-4 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-5-%E5%9F%BA%E7%B1%BB%E5%8A%AB%E6%8C%81%E4%BA%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">第15章-11-5 基类劫持了接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-%E8%87%AA%E9%99%90%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">第15章-12 自限定的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-1-%E5%8F%A4%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%B3%9B%E5%9E%8B"><span class="toc-text">第15章-12-1 古怪的循环泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-2-%E8%87%AA%E9%99%90%E5%AE%9A"><span class="toc-text">第15章-12-2 自限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-3-%E5%8F%82%E6%95%B0%E5%8D%8F%E5%8F%98"><span class="toc-text">第15章-12-3 参数协变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-13-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">第15章-13 动态类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-14-%E5%BC%82%E5%B8%B8"><span class="toc-text">第15章-14 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-%E6%B7%B7%E5%9E%8B"><span class="toc-text">第15章-15 混型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-1-C-%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%9E%8B"><span class="toc-text">第15章-15-1 C++中的混型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-2-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B7%E5%90%88"><span class="toc-text">第15章-15-2 与接口混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-3-%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">第15章-15-3 使用装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-4-%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%B7%B7%E5%90%88"><span class="toc-text">第15章-15-4 与动态代理混合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-16-%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">第15章-16 潜在类型机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-%E5%AF%B9%E7%BC%BA%E4%B9%8F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-text">第15章-17 对缺乏潜在类型机制的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-1-%E5%8F%8D%E5%B0%84"><span class="toc-text">第15章-17-1 反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-2-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E4%BA%8E%E5%BA%8F%E5%88%97"><span class="toc-text">第15章-17-2 将一个方法应用于序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-3-%E5%BD%93%E4%BD%A0%E5%B9%B6%E4%B8%BA%E7%A2%B0%E5%B7%A7%E6%8B%A5%E6%9C%89%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6"><span class="toc-text">第15章-17-3 当你并为碰巧拥有正确的接口时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-4-%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%BB%BF%E7%9C%9F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">第15章-17-4 用适配器仿真潜在类型机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-18-%E5%B0%86%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="toc-text">第15章-18 将函数对象用作策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-%E6%80%BB%E7%BB%93%EF%BC%9A%E8%BD%AC%E5%9E%8B%E7%9C%9F%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%B3%9F%E5%90%97%EF%BC%9F"><span class="toc-text">第15章-19 总结：转型真的如此之糟吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-1-%E8%BF%9B%E9%98%B6%E8%AF%BB%E7%89%A9"><span class="toc-text">第15章-19-1 进阶读物</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-text">第16章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-1-%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E6%AE%8A"><span class="toc-text">第16章-1 数组为什么特殊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-2-%E6%95%B0%E7%BB%84%E6%98%AF%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%AF%B9%E8%B1%A1"><span class="toc-text">第16章-2 数组是第一级对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-3-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-3 返回一个数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-4 多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-5-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">第16章-5 数组与泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-text">第16章-6 创建测试数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-1-Arrays-fill"><span class="toc-text">第16章-6-1 Arrays.fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-2-%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">第16章-6-2 数据生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-3-%E4%BB%8EGenerator%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-6-3 从Generator中创建数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-Arrays%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">第16章-7 Arrays实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-1-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-7-1 复制数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-2-%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">第16章-7-2 数组的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-3-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">第16章-7-3 数组元素的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-4-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">第16章-7-4 数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-5-%E5%9C%A8%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-text">第16章-7-5 在已排序的数组中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-8-%E6%80%BB%E7%BB%93"><span class="toc-text">第16章-8 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="toc-text">第17章 容器深入研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-1-%E5%AE%8C%E6%95%B4%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-text">第17章-1 完整容器分类法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-%E5%A1%AB%E5%85%85%E5%AE%B9%E5%99%A8"><span class="toc-text">第17章-2 填充容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-1-%E4%B8%80%E7%A7%8DGenerator%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">第17章-2-1 一种Generator解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-2-Map%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">第17章-2-2 Map生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-3-%E4%BD%BF%E7%94%A8Abstract%E7%B1%BB"><span class="toc-text">第17章-2-3 使用Abstract类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-3-Collection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-text">第17章-3 Collection的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C"><span class="toc-text">第17章-4 可选操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-1-%E6%9C%AA%E8%8E%B7%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">第17章-4-1 未获支持的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-5-List%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-text">第17章-5 List的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-Set%E5%92%8C%E5%AD%98%E5%82%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">第17章-6 Set和存储排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-1-SortedSet"><span class="toc-text">第17章-6-1 SortedSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-%E9%98%9F%E5%88%97"><span class="toc-text">第17章-7 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-1-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">第17章-7-1 优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-2-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-text">第17章-7-2 双向队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-%E7%90%86%E8%A7%A3Map"><span class="toc-text">第17章-8 理解Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-1-%E6%80%A7%E8%83%BD"><span class="toc-text">第17章-8-1 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-2-SortedMap"><span class="toc-text">第17章-8-2 SortedMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-3-LinkedHashMap"><span class="toc-text">第17章-8-3 LinkedHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-%E6%95%A3%E5%88%97%E4%B8%8E%E6%95%A3%E5%88%97%E7%A0%81"><span class="toc-text">第17章-9 散列与散列码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-1-%E7%90%86%E8%A7%A3hashCode"><span class="toc-text">第17章-9-1 理解hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-2-%E4%B8%BA%E9%80%9F%E5%BA%A6%E8%80%8C%E6%95%A3%E5%88%97"><span class="toc-text">第17章-9-2 为速度而散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-3-%E8%A6%86%E7%9B%96hashCode"><span class="toc-text">第17章-9-3 覆盖hashCode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">第17章-10 选择接口的不同实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-1-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-text">第17章-10-1 性能测试框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-2-%E5%AF%B9List%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">第17章-10-2 对List的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-3-%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-text">第17章-10-3 微基准测试的危险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-4-%E5%AF%B9Set%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">第17章-10-4 对Set的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-5-%E5%AF%B9Map%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">第17章-10-5 对Map的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">第17章-11 实用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-1-List%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2"><span class="toc-text">第17章-11.1 List的排序和查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-2-%E8%AE%BE%E5%AE%9ACollection%E6%88%96Map%E4%B8%BA%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">第17章-11.2 设定Collection或Map为不可修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-3-Collection%E6%88%96Map%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-text">第17章-11.3 Collection或Map的同步控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-%E6%8C%81%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-text">第17章-12 持有引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-1-WeakHashMap"><span class="toc-text">第17章-12.1 WeakHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-Java-1-0-1-1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">第17章-13 Java 1.0-1.1的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-1-Vector%E5%92%8CEnumeration"><span class="toc-text">第17章-13.1 Vector和Enumeration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-2-Hashtable"><span class="toc-text">第17章-13.2 Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-3-Stack"><span class="toc-text">第17章-13.3 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-4-BitSet"><span class="toc-text">第17章-13.4 BitSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第17章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F"><span class="toc-text">第18章 Java IO系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-File%E7%B1%BB"><span class="toc-text">第18章-1 File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-1-%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E5%99%A8"><span class="toc-text">第18章-1-1 目录列表器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-2-%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">第18章-1-2 目录实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-3-%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E6%9F%A5%E5%8F%8A%E5%88%9B%E5%BB%BA"><span class="toc-text">第18章-1-3 目录的检查及创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-%E8%BE%93%E5%85%A5%EF%BC%88Input%EF%BC%89%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88Output%EF%BC%89"><span class="toc-text">第18章-2 输入（Input）和输出（Output）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-1-InputStream%E7%B1%BB%E5%9E%8B"><span class="toc-text">第18章-2-1 InputStream类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-2-OutputStream%E7%B1%BB%E5%9E%8B"><span class="toc-text">第18章-2-2 OutputStream类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">第18章-3 添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-1-%E9%80%9A%E8%BF%87FilterInputStream%E4%BB%8EInputStream%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-3-1 通过FilterInputStream从InputStream读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-2-%E9%80%9A%E8%BF%87FilterOutputStream%E4%BB%8EOutputStream%E5%86%99%E5%85%A5"><span class="toc-text">第18章-3-2 通过FilterOutputStream从OutputStream写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-Reader%E5%92%8CWriter"><span class="toc-text">第18章-4 Reader和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9D%A5%E6%BA%90%E5%92%8C%E5%8E%BB%E5%A4%84%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%89"><span class="toc-text">第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-2-%E6%9B%B4%E6%94%B9%E6%B5%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">第18章-4-2 更改流的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-3-%E6%9C%AA%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E7%B1%BB"><span class="toc-text">第18章-4-3 未发生变化的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-5-%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="toc-text">第18章-5 自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-IO%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">第18章-6 IO流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-1-%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-6-1 缓冲输入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-2-%E4%BB%8E%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-text">第18章-6-2 从内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-text">第18章-6-3 格式化的内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-text">第18章-6-4 基本的文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-5-%E5%AD%98%E5%82%A8%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-6-5 存储和恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-6-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-6-6 随机读写访问文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-7-%E7%AE%A1%E9%81%93%E6%B5%81"><span class="toc-text">第18章-6-7 管道流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">第18章-7 文件读写的实用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-1-%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-7-1 读取二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-%E6%A0%87%E5%87%86IO"><span class="toc-text">第18章-8 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-1-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-text">第18章-8-1 从标准输入中读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-2-%E5%B0%86System-out%E8%BD%AC%E6%8D%A2%E6%88%90PrintWriter"><span class="toc-text">第18章-8-2 将System.out转换成PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-3-%E6%A0%87%E5%87%86IO%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">第18章-8-3 标准IO重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-9-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">第18章-9 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-%E6%96%B0IO"><span class="toc-text">第18章-10 新IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-1-%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-10-1 转换数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-2-%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">第18章-10-2 获取基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-3-%E8%A7%86%E5%9B%BE%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-text">第18章-10-3 视图缓冲器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-4-%E7%94%A8%E7%BC%93%E5%86%B2%E5%99%A8%E6%93%8D%E7%BA%B5%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-10-4 用缓冲器操纵数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-5-%E7%BC%93%E5%86%B2%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">第18章-10-5 缓冲器的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-10-6 内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-7-%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-text">第18章-10-7 文件加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-%E5%8E%8B%E7%BC%A9"><span class="toc-text">第18章-11 压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-1-%E7%94%A8GZIP%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%8E%8B%E7%BC%A9"><span class="toc-text">第18章-11-1 用GZIP进行简单压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-2-%E7%94%A8Zip%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98"><span class="toc-text">第18章-11-2 用Zip进行多文件保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-3-Java%E6%A1%A3%E6%A1%88%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-11-3 Java档案文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">第18章-12 对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-1-%E5%AF%BB%E6%89%BE%E7%B1%BB"><span class="toc-text">第18章-12-1 寻找类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-2-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-text">第18章-12-2 序列化的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-3-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%8C%81%E4%B9%85%E6%80%A7%E2%80%9D"><span class="toc-text">第18章-12-3 使用“持久性”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-13-XML"><span class="toc-text">第18章-13 XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-14-Preferences"><span class="toc-text">第18章-14 Preferences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-15-%E6%80%BB%E7%BB%93"><span class="toc-text">第18章-15 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第19章 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-%E5%9F%BA%E6%9C%ACenum%E7%89%B9%E6%80%A7"><span class="toc-text">第19章-1 基本enum特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-1-%E5%B0%86%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E7%94%A8%E4%BA%8Eenum"><span class="toc-text">第19章-1-1 将静态导入用于enum</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-%E5%90%91enum%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-text">第19章-2 向enum中添加新方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-1-%E8%A6%86%E7%9B%96enum%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">第19章-2-1 覆盖enum的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-3-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84enum"><span class="toc-text">第19章-3 switch语句中的enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-4-values-%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-text">第19章-4 values()的神秘之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-5-%E5%AE%9E%E7%8E%B0%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-text">第19章-5 实现而非继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-6-%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96"><span class="toc-text">第19章-6 随机选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-7-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE"><span class="toc-text">第19章-7 使用接口组织枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-8-%E4%BD%BF%E7%94%A8EnumSet%E6%9B%BF%E4%BB%A3%E6%A0%87%E5%BF%97"><span class="toc-text">第19章-8 使用EnumSet替代标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-9-%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-text">第19章-9 使用EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">第19章-10 常量相关的方法（枚举类的抽象方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-1-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE"><span class="toc-text">第19章-10-1 使用enum的职责链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-2-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">第19章-10-2 使用enum的状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91"><span class="toc-text">第19章-11 多路分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-1-%E4%BD%BF%E7%94%A8enum%E5%88%86%E5%8F%91"><span class="toc-text">第19章-11-1 使用enum分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-2-%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">第19章-11-2 使用常量相关的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-3-%E4%BD%BF%E7%94%A8EnumMap%E5%88%86%E5%8F%91"><span class="toc-text">第19章-11-3 使用EnumMap分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-4-%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">第19章-11-4 使用二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-12-%E6%80%BB%E7%BB%93"><span class="toc-text">第19章-12 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">第20章-1 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-1-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章-1-1 定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-2-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章-1-2 元注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-%E7%BC%96%E5%86%99%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">第20章-2 编写注解处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-1-%E6%B3%A8%E8%A7%A3%E5%85%83%E7%B4%A0"><span class="toc-text">第20章-2-1 注解元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-2-%E9%BB%98%E8%AE%A4%E5%80%BC%E9%99%90%E5%88%B6"><span class="toc-text">第20章-2-2 默认值限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-3-%E7%94%9F%E6%88%90%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="toc-text">第20章-2-3 生成外部文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-4-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF"><span class="toc-text">第20章-2-4 注解不支持继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-5-%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">第20章-2-5 实现处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-3-%E4%BD%BF%E7%94%A8apt%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章-3 使用apt处理注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-4-%E5%B0%86%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BA%8Eapt"><span class="toc-text">第20章-4 将观察者模式用于apt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">第20章-5 基于注解的单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-1-%E5%B0%86-Unit%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">第20章-5-1 将@Unit用于泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-2-%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BB%BB%E4%BD%95%E2%80%9C%E5%A5%97%E4%BB%B6%E2%80%9D"><span class="toc-text">第20章-5-2 不需要任何“套件”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-3-%E5%AE%9E%E7%8E%B0-Unit"><span class="toc-text">第20章-5-3 实现@Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-4-%E7%A7%BB%E9%99%A4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">第20章-5-4 移除测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-text">第20章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-text">第21章 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-1-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%80%A7"><span class="toc-text">第21章-1 并发的多面性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">第21章-2 基本的线程机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-3-%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90"><span class="toc-text">第21章-3 共享受限资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-4-%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="toc-text">第21章-4 终结任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-5-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-text">第21章-5 线程之间的协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-6-%E6%AD%BB%E9%94%81"><span class="toc-text">第21章-6 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-7-%E6%96%B0%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="toc-text">第21章-7 新类库中的构件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-8-%E4%BB%BF%E7%9C%9F"><span class="toc-text">第21章-8 仿真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-9-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-text">第21章-9 性能调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-10-%E6%B4%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">第21章-10 活动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-11-%E6%80%BB%E7%BB%93"><span class="toc-text">第21章-11 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC22%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-text">第22章 图形化用户界面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%96%E5%8F%82%E7%9C%8B"><span class="toc-text">📖参看</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%BB%E5%8F%82%E8%80%83%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">※参考和引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%97%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-text">🔗外部链接</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HelloWorld/">HelloWorld🐣</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/InformationTechnology/">信息技术</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/InformationTechnology/Handbook/">手册</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/InformationTechnology/SiteRecord/">站点记录</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">其他🗒</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">博客</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Handbook/">手册</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DailyRecord/">日常记录</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">生命</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Knowledge/">知识</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Society/">社会</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SiteRecord/">站点记录</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerEngineering/">计算机工程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/">计算机科学</a><span class="category-list-count">7</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/Handbook/">手册</a><span class="category-list-count">2</span></li></ul></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Git/" style="font-size: 0.8em;">Git</a> <a href="/tags/Github/" style="font-size: 0.6em;">Github</a> <a href="/tags/HelloWorld/" style="font-size: 0.67em;">HelloWorld🐣</a> <a href="/tags/Hexo/" style="font-size: 0.6em;">Hexo</a> <a href="/tags/Java/" style="font-size: 0.8em;">Java</a> <a href="/tags/%E3%80%8AThinking-in-Java%E3%80%8B/" style="font-size: 0.67em;">《Thinking in Java》</a> <a href="/tags/Ethics/" style="font-size: 0.6em;">伦理</a> <a href="/tags/Tutorial/" style="font-size: 0.6em;">使用手册</a> <a href="/tags/InformationTechnology/" style="font-size: 0.73em;">信息技术</a> <a href="/tags/Blog/" style="font-size: 0.67em;">博客</a> <a href="/tags/PracticeManual/" style="font-size: 0.6em;">实践手册</a> <a href="/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" style="font-size: 0.6em;">开发日志</a> <a href="/tags/Handbook/" style="font-size: 0.73em;">手册</a> <a href="/tags/DailyRecord/" style="font-size: 0.6em;">日常记录</a> <a href="/tags/Law/" style="font-size: 0.6em;">法律</a> <a href="/tags/TheoryHandbook/" style="font-size: 0.67em;">理论手册</a> <a href="/tags/Life/" style="font-size: 0.6em;">生命</a> <a href="/tags/%E7%9F%A5%E8%AF%86/" style="font-size: 0.6em;">知识</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B/"><i class="fa  fa-book"></i> 《Thinking in Java》</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/"><i class="fa  fa-book"></i> 《Thinking in Java》（第4版） ← 整理手册</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/04/16/%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/"><i class="fa  fa-book"></i> 实践手册</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/04/16/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"><i class="fa  fa-book"></i> 使用手册（Tutorial）</a>
            
          
        
          
          
            <a class="list-group-item" href="/2021/04/16/%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/"><i class="fa  fa-book"></i> 理论手册（Theory Handbook）</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/SuiteLHY"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://github.com/SuiteLHY"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2021 夜与花海 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Suite.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>

<script async src="/js/candy.min.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="900328786"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>