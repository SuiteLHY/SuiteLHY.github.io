[{"title":"心理学","date":"2021-04-22T16:46:57.000Z","url":"/2021/04/22/%E5%BF%83%E7%90%86%E5%AD%A6/","tags":[["社会","/tags/Society/"],["心理学","/tags/Psychology/"]],"categories":[["社会","/categories/Society/"]],"content":" 心理学（英语：psychology）是一门研究人类和动物的心理现象、意识和行为的科学。它既是一门理论学科，也是一门应用学科，包括理论心理学与应用心理学两大领域。 心理学研究涉及意识、感觉、知觉、认知、情绪、人格、行为和人际关系等众多领域，影响其他学科的发展，例如：教育学、管理学、传播学、社会学、经济学、精神病学、统计学、以及文学等等。心理学一方面尝试用大脑运作来解释个体基本的行为与心理机能，同时，心理学也尝试解释个体心理机能在社会行为与社会动力中的角色。心理学家从事基础研究的目的是描述、解释、预测和控制行为。应用心理学家还有第五个目的——提高人类生活的品质。这些目标构成了心理学事业的基础。 早期的心理学家为了研究人类的行为，会对动物进行残忍实验，以推测环境、生理（如：大脑损伤、运动是否能增加多巴胺等）以及一些特定因素对人产生的影响。但这种实验方法一直以来受到讨论与争议。然而，随着科技的进步，人们使用核磁共振、断层扫描、及发展较成熟的问卷调查等方式来研究人类的心理。有时会有脑部部分损伤的病人，心理学家也借由观察这些人的脑部活动，去了解脑袋各部位的功能为何。 👆←🗎[1] 在本站中，通常会将&thinsp;[&thinsp;主要涉及&thinsp;心理学&thinsp;]&thinsp;的知识划分到【心理学】的[标签]之中。 📖参看 主要参看📖 Psychology - Wikipedia 心理学 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;心理学 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"（社会）（心理学）梁宏达解读洗脑术","date":"2021-04-22T16:14:02.000Z","url":"/2021/04/22/%EF%BC%88%E7%A4%BE%E4%BC%9A%EF%BC%89%EF%BC%88%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%89%E6%A2%81%E5%AE%8F%E8%BE%BE%E8%A7%A3%E8%AF%BB%E6%B4%97%E8%84%91%E6%9C%AF/","tags":[["社会","/tags/Society/"],["心理学","/tags/Psychology/"]],"categories":[["社会","/categories/Society/"]],"content":" 老梁解读洗脑术 过瘾！！ - YouTube 598,212次观看•2020年3月20日 👆←🗎[1] View on YouTube 📖参看 主要参看📖 老梁 - YouTube 梁宏达 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;老梁解读洗脑术-过瘾！！ - YouTube 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"《Thinking in Java》","date":"2021-04-16T20:14:45.000Z","url":"/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["《Thinking in Java》","/tags/%E3%80%8AThinking-in-Java%E3%80%8B/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" Thinking in Java (ISBN 978-0131872486) is a book about the Java programming language, written by Bruce Eckel and first published in 1998. Prentice Hall published the 4th edition of the work in 2006. The book represents a print version of Eckel’s “Hands-on Java” seminar. Bruce Eckel wrote “On Java8” as a sequel for Thinking in Java and it is available in Google Play as an ebook. 👆←🗎[1] Java 经典著作。本站专门做了对该著作的整理笔记。 手册 《Thinking in Java》（第4版） ← 整理手册 📖参看 主要参看📖 【电子书】Thinking in Java, 4th Edition (Bruce Eckel) 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Thinking in Java - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"《Thinking in Java》（第4版） ← 整理手册","date":"2021-04-16T18:53:02.000Z","url":"/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["《Thinking in Java》","/tags/%E3%80%8AThinking-in-Java%E3%80%8B/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":"目录 第1章 面向对象导论 1.1 抽象过程 1.2 每个对象都有一个接口 1.3 每个对象都提供服务 1.4 被隐藏的具体实现 1.5 复用具体实现 1.6 继承 1.6.1 “是一个”与“像是一个”的关系 1.7 伴随多态的可互换对象 1.8 单根继承结构 1.9 容器 1.9.1 参数化类型 1.10 对象的创建和生命周期 1.11 异常处理：错误处理 1.12 并发编程 1.13 Java与Internet 1.13.1 Web是什么 1.13.2 客户端编程 1.13.3 服务器端编程 1.14 总结 第2章 一切都是对象 2.1 用引用操纵对象 2.2 必须由你创建所有对象【底层存储】 2.2.1 存储到什么地方【对象的存储】 2.2.2 特例：基本类型 2.2.3 Java中的数组 2.3 永远不需要销毁对象 2.4 创建新的数据类型 2.5 方法、参数和返回值 2.6 构建一个Java程序 2.7 你的第一个Java程序 2.8 注释和嵌入式文档 2.9 编码风格 2.10 总结 2.11 练习 第3章 操作符 3.1 更简单的打印语句 3.2 使用Java操作符 3.3 优先级 3.4 赋值 3.4.1 方法调用中的别名问题 3.5 算数操作符 3.5.1 一元加减操作符 3.6 自动递增和递减 3.7 关系操作符 3.7.1 测试对象的等价性 3.8 逻辑操作符 3.8.1 短路 3.9 直接常量 3.9.1 指数记数法 3.10 按位操作符 3.11 移位操作符 3.12 三元操作符if-else 3.13 字符串操作符+和= 3.14 使用操作符时常犯的错误 3.15 类型转换操作符 3.15.1 截尾和舍入 3.15.2 提升 3.16 Java没有sizeof 3.17 操作符小结 3.18 总结 第4章 控制执行流程 第5章 初始化与清理 5.1 用构造器确保初始化 5.2 方法重载 5.3 默认构造器 5.4 this关键字 5.4.1 在构造器中调用构造器 5.4.2 static的含义 5.5 清理：终结处理和垃圾回收 5.5.1 finalize()的用途何在 5.5.2 你必须实施清理 5.5.3 终结条件 5.5.4 垃圾回收器如何工作 5.6 成员初始化 5.6.1 指定初始化 5.7 构造器初始化 5.7.1 初始化顺序 5.7.2 静态数据的初始化 5.7.3 显式的静态初始化 5.7.4 非静态实例初始化 5.8 数组初始化 5.8.1 可变参数列表 5.9 枚举类型 5.9.1 枚举类（enum）——基本概念 5.9.2 枚举类的使用 5.10 总结 第6章 访问权限控制 6.1 包：库单元 6.1.1 代码组织 6.1.2 创建独一无二的包名 6.1.3 定制工具库 6.1.4 用import改变行为 6.1.5 对使用包的忠告 6.2 Java访问权限修饰词 6.3 接口和实现 6.4 类的访问权限 6.5 总结 第7章 复用类 7.1 组合语法 7.2 继承语法 7.2.1 初始化基类 【拓展】7.2.2 重写 7.3 代理 7.4 结合使用组合和继承 7.4.1 确保正确清理 7.4.2 名称屏蔽 7.5 在组合与继承之间选择 7.6 protected关键字 7.7 向上转型 7.7.1 为什么称为向上转型 7.7.2 再论组合与继承 7.8 final关键字 7.8.1 final数据 7.8.2 final方法 7.8.3 final类 7.8.4 有关final的忠告 7.9 初始化类及类的加载 7.10 总结 第8章 多态 8.1 再论向上转型 8.2 转机 8.3 构造器和多态 8.4 协变返回类型 8.5 用继承进行设计 8.5.1 纯继承与拓展 8.5.2 向下转型与运行时类型识别 8.6 总结 第9章 接口 9.1 抽象类和抽象方法 9.2 接口 9.3 完全解耦 9.4 Java中的多重继承 9.5 通过继承来拓展接口 9.6 适配接口 9.7 接口中的域 9.8 嵌套接口 9.9 接口与工厂 9.10 总结 第10章 内部类 10.1 创建内部类 10.2 链接到外部类 10.3 使用.this与.new 10.4 内部类与向上转型 10.5 在方法和作用域内的内部类 10.6 匿名内部类 10.7 嵌套类 10.8 为什么需要内部类 10.9 内部类的继承 10.10 内部类可以被覆盖吗 10.11 局部内部类 10.12 内部类标识符 10.13 总结 第11章 持有对象 11.1 泛型和类型安全的容器 11.2 基本概念 11.3 添加一组元素 11.4 容器的打印 11.5 List（原理 &amp; 简介） 11.6 迭代器 11.7 LinkedList 11.8 Stack 11.9 Set 11.10 Map 11.11 Queue 11.12 Collection和Iterator 11.13 Foreach与迭代器 11.13.1 适配器方法惯用法→示例源码说明 11.14 总结 第12章 通过异常处理错误 12.1 概念 12.2 基本异常 12.2.1 捕获异常参数 12.3 捕获异常 12.3.1 try块 12.3.2 异常处理程序 12.4 创建自定义异常 12.4.1 异常与记录日志 12.5 异常说明 12.6 捕获所有异常 12.6.1 栈轨迹 12.6.2 重新抛出异常 12.6.3 异常链 12.7 Java标准异常 12.7.1 特例：RuntimeException 12.8 使用finally进行清理 12.8.1 finally用来做什么 12.8.2 在return中使用finally 12.8.3 缺憾：异常缺失 12.9 异常的限制 12.10 构造器 12.11 异常匹配 12.12 其他可选方式 12.12.1 历史 12.12.2 观点 12.12.3 把异常传递给控制台 12.12.4 把“被检查的异常”转换为“不检查的异常” 12.13 异常使用指南 12.14 总结 第13章 字符串 13.1 不可变String 13.2 重载“+”与StringBuilder 13.3 无意识的递归 13.4 String上的操作 13.5 格式化输出 13.5.4 格式化说明符 13.6 正则表达式 13.7 扫描输入 13.8 StringTokenizer（已废弃） 13.9 总结 第14章 类型信息（RTTI） 14.1 为什么需要RTTI 14.2 Class对象 14.2.1 类字面量 14.2.2 泛化的Class引用 14.2.3 类的转换（原：新的转型语法） 14.3 类型转换前先做检查 14.4 注册工厂 14.5 instanceof与Class的等价性 14.6 反射：运行时的类信息 14.6.1 类方法提取器 14.7 动态代理 14.8 空对象 14.8.1 模拟对象与桩 14.9 接口与类型信息 14.10 总结 第15章 泛型 15.1 与C++比较 15.2 简单泛型 15.2.1 一个元祖类库 15.2.2 一个堆栈类 15.2.3 RandomList 15.3 泛型接口 15.4 泛型方法 15.4.1 杠杆利用类型参数判断 15.4.2 可变参数与泛型方法 15.4.3 用于Generator的泛型方法 15.4.4 一个通用的Generator 15.4.5 简化元祖的使用 15.4.6 一个Set实用工具 15.5 匿名内部类 15.6 构建复杂模型 15.7 擦除的神秘之处 15.7.1 C++的方式 15.7.2 迁移兼容性 15.7.3 擦除的问题 15.7.4 边界处的动作 15.8 擦除的补偿 15.8.1 创建类型实例 15.8.2 泛型数组 15.9 边界 15.10 通配符 15.10.1 编译器有多聪明 15.10.2 逆变 15.10.3 无界通配符 15.10.4 捕获转换（通配符捕获） 15.11 问题 15.11.1 任何基本类型都不能作为类型 15.11.2 实现参数化接口 15.11.3 转型和警告 15.11.4 重载 15.11.5 基类劫持了接口 15.12 自限定的类型 15.12.1 古怪的循环泛型 15.12.2 自限定 15.12.3 参数协变 15.13 动态类型安全 15.14 异常 15.15 混型 15.15.1 C++中的混型 15.15.2 与接口混合 15.15.3 使用装饰器模式 15.15.4 与动态代理混合 15.16 潜在类型机制 15.17 对缺乏潜在类型机制的补偿 15.17.1 反射 15.17.2 将一个方法应用于序列 15.17.3 当你并为碰巧拥有正确的接口时 15.17.4 用适配器仿真潜在类型机制 15.18 将函数对象用作策略 15.19 总结：转型真的如此之糟吗？ 15.19.1 进阶读物 第16章 数组 16.1 数组为什么特殊 16.2 数组是第一级对象 16.3 返回一个数组 16.4 多维数组 16.5 数组与泛型 16.6 创建测试数据 16.6.1 Arrays.fill() 16.6.2 数据生成器 16.6.3 从Generator中创建数组 16.7 Arrays实用功能 16.7.1 复制数组 16.7.2 数组的比较 16.7.3 数组元素的比较 16.7.4 数组排序 16.7.5 在已排序的数组中查找 16.8 总结 第17章 容器深入研究 17.1 完整容器分类法 17.2 填充容器 17.2.1 一种Generator解决方案 17.2.2 Map生成器 17.2.3 使用Abstract类 17.3 Collection的功能方法 17.4 可选操作 17.4.1 未获支持的操作 17.5 List的功能方法 17.6 Set和存储排序 17.6.1 SortedSet 17.7 队列 17.7.1 优先级队列 17.7.2 双向队列 17.8 理解Map 17.8.1 性能 17.8.2 SortedMap 17.8.3 LinkedHashMap 17.9 散列与散列码 17.9.1 理解hashCode() 17.9.2 为速度而散列 17.9.3 覆盖hashCode() 17.10 选择接口的不同实现 17.10.1 性能测试框架 17.10.2 对List的选择 17.10.3 微基准测试的危险 17.10.4 对Set的选择 17.10.5 对Map的选择 17.11 实用方法 17.11.1 List的排序和查询 17.11.2 设定Collection或Map为不可修改 17.11.3 Collection或Map的同步控制 17.12 持有引用 17.12.1 WeakHashMap 17.13 Java 1.0-1.1的容器 17.13.1 Vector和Enumeration 17.13.2 Hashtable 17.13.3 Stack 17.13.4 BitSet 17.14 总结 第18章 Java IO系统 18.1 File类 18.1.1 目录列表器 18.1.2 目录实用工具 18.1.3 目录的检查及创建 18.2 输入（Input）和输出（Output） 18.2.1 InputStream类型 18.2.2 OutputStream类型 18.3 添加属性和有用的接口 18.3.1 通过FilterInputStream从InputStream读取数据 18.3.2 通过FilterOutputStream从OutputStream写入 18.4 Reader和Writer 18.4.1 数据的来源和去处（字节流和字符流类库的关联） 18.4.2 更改流的行为 18.4.3 未发生变化的类 18.5 自我独立的类：RandomAccessFile 18.6 IO流的典型使用方式 18.6.1 缓冲输入文件 18.6.2 从内存输入 18.6.3 格式化的内存输入 18.6.4 基本的文件输出 18.6.5 存储和恢复数据 18.6.6 随机读写访问文件 18.6.7 管道流 18.7 文件读写的实用工具 18.7.1 读取二进制文件 18.8 标准IO 18.8.1 从标准输入中读取 18.8.2 将System.out转换成PrintWriter 18.8.3 标准IO重定向 18.9 进程控制 18.10 新IO 18.10.1 转换数据 18.10.2 获取基本类型 18.10.3 视图缓冲器 18.10.4 用缓冲器操纵数据 18.10.5 缓冲器的细节 18.10.6 内存映射文件 18.10.7 文件加锁 18.11 压缩 18.11.1 用GZIP进行简单压缩 18.11.2 用Zip进行多文件保存 18.11.3 Java档案文件 18.12 对象序列化 18.12.1 寻找类 18.12.2 序列化的控制 18.12.3 使用“持久性” 18.13 XML 18.14 Preferences 18.15 总结 第19章 枚举类型 19.1 基本enum特性 19.1.1 将静态导入用于enum 19.2 向enum中添加新方法 19.2.1 覆盖enum的方法 19.3 switch语句中的enum 19.4 values()的神秘之处 19.5 实现而非继承 19.6 随机选取 19.7 使用接口组织枚举 19.8 使用EnumSet替代标志 19.9 使用EnumMap 19.10 常量相关的方法（枚举类的抽象方法） 19.10.1 使用enum的职责链 19.10.2 使用enum的状态机 19.11 多路分发 19.11.1 使用enum分发 19.11.2 使用常量相关的方法 19.11.3 使用EnumMap分发 19.11.4 使用二维数组 19.12 总结 第20章 注解 20.1 基本语法 20.1.1 定义注解 20.1.2 元注解 20.2 编写注解处理器 20.2.1 注解元素 20.2.2 默认值限制 20.2.3 生成外部文件 20.2.4 注解不支持继承 20.2.5 实现处理器 20.3 使用apt处理注解 20.4 将观察者模式用于apt 20.5 基于注解的单元测试 20.5.1 将@Unit用于泛型 20.5.2 不需要任何“套件” 20.5.3 实现@Unit 20.5.4 移除测试代码 20.6 总结 第21章 并发 21.1 并发的多面性 21.2 基本的线程机制 21.3 共享受限资源 21.4 终结任务 21.5 线程之间的协作 21.6 死锁 21.7 新类库中的构件 21.8 仿真 21.9 性能调优 21.10 活动对象 21.11 总结 第22章 图形化用户界面 第1章 面向对象导论面向对象程序设计（Object-oriend Programming，OOP）。本章将介绍包括开发方法概述在内的&thinsp;OOP&thinsp;的基本概念。 相关资料：🗎[1]🗎[2] 基础概念面向对象程序设计（OOP）是一种具有对象概念的程序编程规范，同时也是一种程序开发的抽象方针。 它可以包含数据、属性、代码&thinsp;与&thinsp;方法。 在面向对象程序设计（OOP）中，计算机程序会被设计成彼此相关的&thinsp;对象。 这种在程序中包含各种独立而又相互调用的对象的思想，与传统编程思想正好相反：传统的程序设计主张把程序看成一系列函数的集合，或者直接对计算机下达的指令。 OOP&thinsp;中的每个对象都应该能接受和处理数据，并且能将数据传达给其他对象。 OOP = 对象 + 类 + 继承 + 多态 + 消息，其中的核心概念是类和对象。 其中，对象&thinsp;指的是&thinsp;类的实例。 对象是程序的基本单元，将程序的数据封装在其中，以提高软件的重用性、灵活性和拓展性。对象里的程序可以访问和修改该对象相关联的数据。 主要特征：封装性、继承性、多态性 封装性：封装是指将计算机程序的数据，以及此数据相关的一切操作语言（即描述对象的属性和行为的代码）组装到一起，一并封装到一个有机实体（也就是“类”）中。 封装的最基本单位是对象。 封装增强了软件结构的模块性，是软件在结构上实现“高内聚，低耦合”的基础。 封装的原则：隐藏对象的属性和实现细节，仅对外提供公共访问方式。 封装的好处： （1）高内聚：将变化隔离，提高安全性； （2）低耦合：便于使用，提高重用性。 继承性：继承是一种多种类之间的联系和区别关系。在面向对象中，继承是指一类对象针对另一类对象的某些特点和能力进行复制或者延续。 父类又称为基类、超类；子类又称为派生类。子类可以直接访问父类中的非私有的属性和行为。关键字为extends。 按照继承源进行划分，继承可以分为单继承和多继承。 按照继承中包含的内容进行划分，继承可以分为4类，分别为取代继承、包含继承、受限继承、特化继承。 继承的好处： 多态性：在面向对象技术中—— 从宏观角度来讲，多态是指当不同的对象同时接收到同一个完全相同的消息时，所表现出来的动作是各不相同的，具有多种形态。 从微观角度来讲，多态是指在一个类中，调用同一个函数名，使用不同的参数（注：参数列表，包括参数数量和参数类型），得到不同的执行效果。 多态实现的前提条件： （1）有继承关系； （2）有方法重写； （3）有父类引用指向子类对象。 多态有三种体现形式： （1）类多态； （2）抽象类多态； （3）接口多态。 多态的优点：提高软件的拓展性和可维护性。 多态的缺点（？）：父类引用不能使用子类特有的功能。 多态在类型转换中的体现： （1）基本类型：隐式转换（小到大），强制转换（大到小）； （2）引用类型：向上转型（小到大），向下转型（大到小）。 设计优点面向对象出现以前，结构化程序设计是程序设计的主流，结构化程序设计又称为面向过程的程序设计。在面向过程程序设计中，问题被看作一系列需要完成的任务，函数（在此泛指例程、函数、过程）用于完成这些任务，解决问题的焦点集中于函数。其中函数是面向过程的，即它关注如何根据规定的条件完成指定的任务。 比较面向对象程序设计和面向过程程序设计，还可以得到面向对象程序设计的其他优点： 数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少甚至避免对外界的干扰； 通过继承大幅减少冗余的代码，并可以方便地扩展现有代码，提高编码效率，也减低了出错概率，降低软件维护的难度； 结合面向对象分析、面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中中间环节的转换过程； 通过对对象的辨别、划分可以将软件系统分割为若干相对为独立的部分，在一定程度上更便于控制软件复杂度； 以对象为中心的设计可以帮助开发人员从静态（属性）和动态（方法）两个方面把握问题，从而更好地实现系统； 通过对象的聚合、联合可以在保证封装与抽象的原则下实现对象在内在结构以及外在功能上的扩充，从而实现对象由低到高的升级。 设计缺陷 运行效率较低。 类的大量加载会牺牲系统性能，降低运行速度。虽然CPU速度在提高，内存容量在增加，但这一问题仍会随着系统规模变大而逐渐显示出来，变得越发严重。 类库庞大。 由于类库都过于庞大，程序员对它们的掌握需要一段时间，从普及、推广的角度来看，类库应在保证其功能完备的基础上进行相应的缩减。 类库可靠性。 越庞大的系统必会存在我们无法预知的问题隐患，程序员无法完全保证类库中的每个类在各种环境中百分之百的正确，当使用的类发生了问题，就会影响后续工作，程序员也有可能推翻原来的全部工作。 名词解释 面向对象程序设计中的概念主要包括：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递。通过这些概念面向对象的思想得到了具体的体现。 （1）对象（Object）： 可以对其做事情的一些东西。对象有3种属性：状态、行为、标识。 （2）类（Class）： 一个共享相同结构和行为的对象的集合。类（Class）定义了一件事物的抽象特点。通常来说，类定义了事物的属性和它可以做到的（它的行为）。举例来说，“狗”这个类会包含狗的一切基础特征，例如它的孕育、毛皮颜色和吠叫的能力。类可以为程序提供模版和结构。一个类的方法和属性被称为“成员”。 （3）封装（Encapsulation）： 第一层意思：将数据和操作捆绑在一起，创造出一个新的类型的过程。第二层意思：将接口与实现分离的过程。 （4）继承： 类之间的关系，在这种关系中，一个类共享了一个或多个其他类定义的结构和行为。继承描述了类之间的“是一种”关系。子类可以对基类的行为进行扩展、覆盖、重定义。 （5）组合： 既是类之间的关系也是对象之间的关系。在这种关系中一个对象或者类包含了其他的对象和类。 （6）多态： 类型理论中的一个概念，一个名称可以表示很多不同类的对象，这些类和一个共同超类有关。因此，这个名称表示的任何对象可以以不同的方式响应一些共同的操作集合。 （7）动态绑定： 也称动态类型，指的是一个对象或者表达式的类型直到运行时才确定。通常由编译器插入特殊代码来实现。与之对立的是静态类型。 （8）静态绑定： 也称静态类型，指的是一个对象或者表达式的类型在编译时确定。 （9）消息传递： 指的是一个对象调用了另一个对象的方法（或者称为成员函数）。 （10）方法： 也称为成员函数，是指对象上的操作，作为类声明的一部分来定义。方法定义了可以对一个对象执行那些操作。 第1章-1 抽象过程所有编程语言都提供抽象机制。可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。所谓的“类型”指的是“所抽象的是什么”。 汇编语言是对底层机器的轻微抽象。接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。…… 另一种对机器建模的方式就是只针对待解决问题建模。…… 面向对象方式通过向程序员提供表示问题空间中的元素的工具而更近了一步。…… Alan Kay&thinsp;曾经总结了第一个[成功的面向对象语言、同时也是&thinsp;Java&thinsp;所基于的语言之一的&thinsp;Smalltalk&thinsp;的]五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式： (1)&ensp;万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件（示例：狗、建筑物、服务等），将其表示为程序中的对象。 (2)&ensp;程序是对象的集合，它们通过发送消息来告知彼此所要做的。…… (3)&ensp;每个对象都有自己的由其他对象所构成的存储。…… (4)&ensp;每个对象都拥有其类型。…… (5)&ensp;某一特定类型的所有对象都可以接收同样的消息。…… Booch&thinsp;对&thinsp;对象&thinsp;提供了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（它们给出了该&thinsp;对象的状态）和方法（它们产生&thinsp;对象的行为），并且每一个对象都可以唯一地与其他对象区分开来（标识），具体说来，就是每一个对象在其内存中都有一个唯一的地址。 第1章-2 每个对象都有一个接口亚里士多德是第一个深入研究类型（type）的哲学家，他曾提出过鱼类和鸟类这样的概念。所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所属的类的一部分。这种思想被直接应用于第一个面向对象语言&thinsp;Simula-67，它在程序中使用基本关键字class来引入新的类型。 Simula，就像其名字一样，是为了开发诸如经典的“银行出纳员问题”（bank teller problem）这样的仿真程序而创建的。…… 所以，尽管我们在面向对象程序设计中实际上进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class这个关键词来表示数据类型。……因为类（class）描述了相同特性（数据元素）和行为（功能）的对象集合，所以一个类（class）实际上就是一个数据类型，例如所有的浮点型数字都具有相同的特性和行为集合。………… UML（Unified Modelling Language，统一建模语言）形式的图，…… 第1章-3 每个对象都提供服务…… 第1章-4 被隐藏的具体实现将程序开发人员按照角色分为类创建者（创建新数据类型的程序员）和客户端程序员（在应用程序中使用数据类型的类消费者）是大有裨益的。客户端程序员的目标，是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，同时隐藏其他部分。构建类的只向客户端程序员暴露必需部分而隐藏其他部分的设计，能保证类的稳定安全，避免人为攻击，减少程序&thinsp;Bug。 明确边界：在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。…… 因此，访问控制的存在原因： （1）让客户端程序员无法触及他们不应该接触的部分&thinsp;——&thinsp;这部分对数据类型的内部操作是必需的，但是对于解决问题所需的接口的一部分。 （2）允许库设计者可以改变&thinsp;类内部&thinsp;的工作方式，同时不用担心会影响到客户端程序员。 Java&thinsp;用3个关键字在类的内部设定边界：public，private，protected。这些访问指定词（access specifier）决定了紧跟其后被定义的东西可以被谁使用。……Java&thinsp;还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为&thinsp;包访问权限，在这种权限下，类可以访问在同一个包中的其他类的成员。 第1章-5 复用具体实现一旦类被设计创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。……。代码复用是面向对象程序设计语言提供的最了不起的优点之一。 最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为“创建一个成员对象”。新的类可以由任意数量、任意类型的其他对象，以任意可以实现新的类中想要的功能的方式所组成。…… …… 第1章-6 继承对象这种概念，本身就是十分方便的工具，方便你通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于&thinsp;必须使用底层机器语言。这些概念用关键字class来表示，它们形成了编程语言中的基本单位。 当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括&thinsp;现有类型的所有成员（尽管private成员被隐藏了起来，并且不可被访问），而且更重要的是它复制了&thinsp;基类的接口。也就是说，所有可以发送给基类对象的消息同时也能发送给派生类对象。由于通过发送给类的消息类型可以判断类的类型，所以派生类与基类具有相同的类型。 …… 第1章-6-1 “是一个”与“像是一个”的关系对于继承可能会引发某些争论：继承是否应该只覆盖基类的方法，而并不添加在基类中没有的新方法？ 略（原文此处论述太过智障）。 第1章-7 伴随多态的可互换对象在处理类型的层次结构时，经常想把一个对象不当作的它所属的特定类型来看待，而是将其当作其基类的对象来处理。这使得程序员可以编写出不依赖于特定类型的代码。 泛化（generic），涉及到向上转型。泛化处理的负面作用是导致编译器无法明确实际执行的代码，而代码的执行只能在编译完成后运行时才能确定。 因为面向对象程序设计语言使用了&thinsp;后期绑定&thinsp;的概念——当向对象发送消息时，被调用的代码直到运行时才能确定：编译器确保被调用的方法的存在，并对调用参数和返回值执行类型检查（无法提供此类语言保证的语言被称为&thinsp;弱类型语言），但是不能确定将被执行的确切代码。 为了执行&thinsp;后期绑定，Java&thinsp;使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址（这个过程将在第八章中体现）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道通过这条消息应该做什么。 在某些语言中，必须明确地声明某个方法具备后期绑定属性所带来的灵活性（C++是使用virtual关键字来实现的）。在这些语言中，方法在默认情况下不是动态绑定的。而在&thinsp;Java&thinsp;中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。 示例：多态的表现 - 示例 第1章-8 单根继承结构 在&thinsp;OOP（面向对象编程）中，自&thinsp;C++&thinsp;面世以来就令人关注的一个问题：是否所有的类最终都继承自同一个基类。在&thinsp;Java&thinsp;中（事实上还包括&thinsp;C++&thinsp;以外的所有&thinsp;OOP&thinsp;语言），答案是&thinsp;yes &ensp; ，这个终极基类是&thinsp;Object。 事实证明，单根继承结构&thinsp;带来了很多好处。 在&thinsp;单根继承结构&thinsp;中，所有对象都具有一个共用接口，所以它们归根结底都是相同的基本类型。 单根继承结构&thinsp;保证所有对象都具备某些功能，可以在每个对象上执行基本操作。所有对象都很容易地在[&thinsp;堆（Heap）]上创建，同时&thinsp;参数的传递&thinsp;也被极大地简化。 单根继承结构&thinsp;使得垃圾回收器的实现变得容易很多，而垃圾回收器正是&thinsp;Java&thinsp;相对&thinsp;C++&thinsp;的重要改进之一。由于所有对象都保证具有其自身的类型信息，因此不会因为无法确定对象的类型而陷入僵局；这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。 在另一种（C++所提供的）非单根继承结构中…… 在另一种（C++所提供的）非单根继承结构中，无法确保所有的对象都属于同一个基本类型，从向后兼容的角度来看，这么做能够更好地适应C模型，且受限较少；除此以外不值得…… 第1章-9 容器第1章-9-1 参数化类型第1章-10 对象的创建和生命周期第1章-11 异常处理：错误处理第1章-12 并发编程第1章-13 Java与Internet第1章-13-1 Web是什么第1章-13-2 客户端编程第1章-13-3 服务器端编程第1章-14 总结第2章 一切都是对象第2章-1 用引用操纵对象 每种编程语言都会有自己的操纵内存中元素的方式。很多时候，程序员必须注意将要处理的数据是什么类型。是选择直接操纵元素，还是用某种基于特殊语法的间接表示（）来操纵对象？ 所有这一切在&thinsp;Java&thinsp;里得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操纵的标识符实际上是对象的一个“引用”（reference） 第2章-2 必须由你创建所有对象【底层存储】一旦创建了一个引用，我们通常希望它能够与一个新的对象关联。通常使用new操作符来实现这一目的。new关键字的意思是“分配一个新对象”。 上述代码不仅表示“分配一个新的字符串”，还通过给构造方法提供的初始字符串，确定了如何构建这个String对象的信息。 这是&thinsp;Java&thinsp;程序设计中的一项基本行为。 第2章-2-1 存储到什么地方【对象的存储】 程序运行时…… 程序运行时，对象是怎么进行存放安排的呢？特别是内存是怎样分配的呢？对这些方面的了解对程序员会有很大的帮助。 有五个不同的地方可以存储数据： 寄存器。位于&thinsp;处理器内部。 这是&thinsp;最快的存储区。因为它位于不同于其他存储区的地方&thinsp;——&thinsp;处理器内部。 但是&thinsp;寄存器的数量&thinsp;极其有限，所以寄存器&thinsp;根据需求进行分配，且&thinsp;Java&thinsp;不允许程序员直接或间接地控制寄存器，甚至屏蔽寄存器的存在概念。⤴&ensp;（另一方面，C&thinsp;和&thinsp;C++&thinsp;允许程序员向编译器建议寄存器的分配方式） 堆栈（Heap）。位于通用&thinsp;RAM（随机访问存储器）&thinsp;中。 通过&thinsp;堆栈指针&thinsp;可以从&thinsp;处理器&thinsp;那里获得&thinsp;直接支持。 堆栈指针，若向下移动，则分配新的内存；若向上移动，则释放已分配的内存。 堆栈（Heap）是一个快速存储区域，存取效率仅次于&thinsp;寄存器。 堆栈（Heap）中存放的数据&thinsp;必须明确其&thinsp;数据大小&thinsp;和&thinsp;生命周期&thinsp;，导致&thinsp;堆栈（Heap）区&thinsp;的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作不灵活。 在&thinsp;Java&thinsp;中，堆栈（Heap）用来存放&thinsp;基本类型数据&thinsp;和&thinsp;对象的引用（对象句柄）。 堆（Stack）。位于&thinsp;RAM&thinsp;中；是一种&thinsp;通用内存池。 堆（Stack）中的数据不需要明确&thinsp;数据大小&thinsp;和&thinsp;生命周期，相比于&thinsp;堆栈（Heap）&thinsp;具有很好的灵活性。 但相应的代价是：堆（Stack）的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作，相比于&thinsp;堆栈（Heap），速度慢很多。 在&thinsp;Java&thinsp;中，堆（Stack）用于存放&thinsp;所有的&thinsp;Java&thinsp;对象。 常量存储（常量池）。通常位于&thinsp;程序代码内部，随着&thinsp;JDK&thinsp;的迭代而存在不同的设计。（另外在嵌入式系统中，常量会和其他部分隔离，此时可以选择&thinsp;ROM&thinsp;作为常量存储区） 常量存储（常量池）位于&thinsp;堆（Heap）&thinsp;中。 JDK&thinsp;7&thinsp;之前的版本 运行时常量池&thinsp;是&thinsp;方法区&thinsp;的一部分。Class文件中除了有&thinsp;类的版本、字段、方法、接口&thinsp;等描述信息外，还有&thinsp;常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然&thinsp;运行时常量池&thinsp;是&thinsp;方法区&thinsp;的一部分，自然受到&thinsp;方法区内存&thinsp;的限制，当&thinsp;常量池&thinsp;无法再申请到内存时会抛出OutOfMemoryError异常。 JDK&thinsp;7&thinsp;及之后的版本 JDK&thinsp;7&thinsp;及之后的版本中，JVM&thinsp;已经将&thinsp;运行时常量池&thinsp;从&thinsp;方法区&thinsp;中移了出来，并在&thinsp;堆（Heap）&thinsp;中开辟了一块区域存放&thinsp;运行时常量池。 常量存储（常量池）&thinsp;用于存储&thinsp;常量。⤷&ensp;因为常量是永远不会被改变的，所以&thinsp;Java&thinsp;中将&thinsp;常量池&thinsp;设置在&thinsp;程序内部&thinsp;的设计是安全的。 非RAM存储。在&thinsp;非&thinsp;RAM&thinsp;存储&thinsp;中，存储的数据的生命周期不受程序本身的生命周期影响。⤷&ensp;其中两个基本的例子是&thinsp;流对象&thinsp;和&thinsp;持久化对象。 在&thinsp;流对象&thinsp;中，对象被转化为字节流（Bit Stream）；通常被发送给另一台机器。 在&thinsp;持久化对象&thinsp;中，对象被存放于磁盘上，对象的存储形式与其存储媒介有关。⤷&ensp;在需要时，可以将&thinsp;持久化对象&thinsp;从&thinsp;具体的存储形式&thinsp;恢复成&thinsp;常规的、基于&thinsp;RAM&thinsp;的对象。 Java 提供了对&thinsp;轻量级持久化&thinsp;的支持…… Java&thinsp;提供了&thinsp;对&thinsp;轻量级持久化&thinsp;的支持。诸如&thinsp;JDBC&thinsp;和&thinsp;Hibernate&thinsp;这样的机制，提供了&thinsp;更加复杂的、对数据库中的对象信息的&thinsp;存取支持。 第2章-2-2 特例：基本类型基本类型对象&thinsp;直接存储“值”，而不是引用；基本类型对象直接存储于&thinsp;堆栈（Heap）&thinsp;中，所以其所占空间大小是确定的。 Java&thinsp;要确定每种&thinsp;基本类型&thinsp;所占空间大小。它们的大小不会随着机器硬件架构的变化而变化，这种&thinsp;所占存储空间大小的不变性&thinsp;是&thinsp;Java&thinsp;可移植性&thinsp;好的原因之一。 基本类型 中文名称 数据大小(单位：位) 最小值 最大值 对应包装器类型 boolean 布尔型 —— —— —— Boolean char 字符型 16 bit Unicode 0 Unicode 2^16-1 Character byte 字节型 8 bit -2^7（-128） +2^7-1（127） Byte short 短整型 16 bit -2^15 +2^15-1 Character int 整型 32 bit -2^31 +2^31-1 Integer long 长整型 64 bit -2^63 +2^63-1 Long float 浮点型 32 bit IEEE754 IEEE754 Character double 双精度浮点型 64 bit IEEE754 IEEE754 Double void 字符型 —— —— —— Void boolean&thinsp;类型所占空间大小没有明确地指定，仅定义为能够取字面值true或false。 所有的&thinsp;数值类型&thinsp;都有&thinsp;符号，所以不要去寻找无符号的&thinsp;数值类型。 第2章-2-3 Java中的数组第2章-3 永远不需要销毁对象第2章-4 创建新的数据类型第2章-5 方法、参数和返回值第2章-6 构建一个Java程序第2章-7 你的第一个Java程序第2章-8 注释和嵌入式文档第2章-9 编码风格第2章-10 总结第2章-11 练习第3章 操作符在最底层，Java&thinsp;中的数据是通过使用&thinsp;操作符&thinsp;来操作的。 第3章-1 更简单的打印语句第3章-2 使用Java操作符 操作符&thinsp;接受一个或多个&thinsp;参数，并生成一个新值。 参数的形式&thinsp;与普通的&thinsp;方法调用&thinsp;不同，但效果是相同的。 加号和一元的正号+、减号和一元的负号-、乘号*、除号/以及赋值号=的用法与其他编程语言类似。 操作符&thinsp;用于操作&thinsp;数，生成一个新值。 另外，有些操作符可能会改变&thinsp;操作数自身的值，这被称为“副作用”。 那些能改变其操作数的操作符，最普遍的用途就是用来产生副作用；但要记住，使用此类操作符生成的值，与使用无副作用的操作符生成的值，没有什么区别。 几乎所有的&thinsp;操作符&thinsp;都只能操作“基本类型”。 例外的操作符是=、==和!=：这些操作符能操作所有的对象（这也是&thinsp;对象&thinsp;易令人糊涂的地方）。 除此之外，String类支持+和+=：操作String类的+和+=意味着字符串拼接，并且如果必要（被操作的对象不属于String类），编译器会先尝试将非String类型的对象转换为String类型对象，再进行字符串拼接的操作。 注意：操作String类型对象的+和+=操作符，必须要小心使用（…），显式执行（？），杜绝在&thinsp;循环体&thinsp;中使用+=操作String造成内存的不可控使用（最坏结果：内存溢出）。 第3章-3 优先级 当一个&thinsp;表达式&thinsp;中存在多个&thinsp;操作符&thinsp;时，操作符的优先级&thinsp;就决定了各部分的计算顺序。Java&thinsp;对&thinsp;计算顺序&thinsp;做了特别的规定。 第3章-4 赋值第3章-4.1 方法调用中的别名问题第3章-5 算数操作符第3章-5-1 一元加减操作符第3章-6 自动递增和递减第3章-7 关系操作符 关系操作符生成的是一个boolean（布尔）类型结果，计算的是&thinsp;操作数的值之间的关系。如果关系是真实的，则关系表达式会生成true（真），否则生成false（假）。 关系操作符包括：小于&lt;、大于&gt;、小于或等于&lt;=、大于或等于&gt;=、等于==、不等于!=。 其中等于==、不等于!=适用于所有的&thinsp;基本数据类型，而其他比较符适用于&thinsp;除boolean类型以外的&thinsp;基本数据类型。 因为boolean值只能为true或false，对于&thinsp;大于&thinsp;和&thinsp;小于&thinsp;的逻辑来说没有实际意义。 第3章-7-1 测试对象的等价性关系操作符==和!=适用于所有对象。 注意：关系运算符&thinsp;比较的是&thinsp;对象的值。 若要比较&thinsp;对象的引用，可以使用&thinsp;对象的equals方法（来自Object）实现。 第3章-8 逻辑操作符 逻辑操作符：与&amp;&amp;、或||、非!。 逻辑操作符&thinsp;能根据&thinsp;参数的逻辑关系，生成一个&thinsp;布尔值boolean（true或false）。 在&thinsp;Java&thinsp;中，逻辑操作符（与&amp;&amp;、或||、非!）只可应用于&thinsp;布尔值boolean。 而在&thinsp;C&thinsp;和&thinsp;C++&thinsp;中，不可将一个&thinsp;布尔值&thinsp;当做&thinsp;非布尔值&thinsp;在&thinsp;逻辑表达式&thinsp;中使用。 注意：如果在使用String值的地方使用布尔值，该布尔值会自动转换为String形式。 第3章-8-1 短路当使用逻辑运算符时，我们会遇到一种“短路”现象：一旦能够明确无误地确定&thinsp;整个表达式的值，就不再计算表达式的余下部分。 示例： 【应用】我们可以借助“短路”这种设计，节省不必要的代码，使业务逻辑的实现（在编码层面）更精简方便。 第3章-9 直接常量第3章-9-1 指数记数法第3章-10 按位操作符第3章-11 移位操作符第3章-12 三元操作符if-else第3章-13 字符串操作符+和=第3章-14 使用操作符时常犯的错误第3章-15 类型转换操作符第3章-15-1 截尾和舍入第3章-15-2 提升第3章-16 Java没有sizeof第3章-17 操作符小结第3章-18 总结第4章 控制执行流程第5章 初始化与清理随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。初始化&thinsp;和&thinsp;清理（cleanup）&thinsp;正是涉及安全的两个问题。 许多&thinsp;C&thinsp;程序的错误都源于程序员忘记&thinsp;初始化变量。特别是在使用程序库，且用户不知道如何正确地初始化库的构件（或者是必须初始化的其他东西）时，更是如此。 清理&thinsp;也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记，导致这个元素占用的资源一直得不到释放，最终结果是资源（尤其是内存）用尽。 C++&thinsp;引入了&thinsp;构造器（constructor）&thinsp;的概念，这是一个&thinsp;在创建对象时&thinsp;被自动调用的特殊方法。Java&thinsp;中也采用了&thinsp;构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。 本章就讨论&thinsp;初始化&thinsp;和&thinsp;清理&thinsp;的相关问题，以及&thinsp;Java&thinsp;对它们的支持。 第5章-1 用构造器确保初始化 可以假想为编写的每个类都定义一个initialize()方法，该方法的名称提醒你在使用其对象之前，应首先调用initialize()。然而，这同时意味着用户必须记得自己去调用此方法。 在&thinsp;Java&thinsp;中，通过提供构造器，类的设计者可以确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，Java&thinsp;就会在用户能够操作对象之前自动调用相应的构造器，从而保证了初始化的顺利进行。 接下来的问题就是如何命名这个方法，2个考虑点：①&ensp;构造器按照方法命名规范所取的任何名字，都可能与类的某个成员名称冲突；②&ensp;调用构造器是编译器的责任，所以必须让编译器知道构造器对应哪一个方法。 C++&thinsp;中采用了的解决方案看起来是最简单且更符合逻辑的，所以&thinsp;Java&thinsp;中也采用了这种方案：构造器采用与类相同的名称（符合类的命名规范，但不符合方法的命名规范）。 注意，由于构造器名称必须与类名完全一致，所以“每个方法首字母小写”的编码风格并不适用于构造器。 以下是一个带有构造器的简单类…… 以下是一个带有构造器的简单类：……现在，在创建对象时： 将会为对象分配存储空间，并调用相应的构造器。这就保证了在你能操作对象之前，它已经被恰当地初始化了。 默认构造器（无参构造器）：不接收形式参数的构造器。 有参构造器。如果Tree(int)是Tree类中唯一的构造器，那么编译器将不会允许你以其他任何方式创建Tree对象。 构造器&thinsp;有助于减少错误，并使代码更易阅读。从概念上讲，“初始化”与“创建”是彼此独立的，然而在上面的代码中，你却找不到对initialize()方法的明确调用。在&thinsp;Java&thinsp;中，“初始化”和“创建”是捆绑在一起，不可分离的。 构造器&thinsp;是一种特殊类型的方法，因为它没有返回值。这与&thinsp;返回值为空（void）&thinsp;明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西；构造器&thinsp;则不会返回任何东西，你别无选择（new&thinsp;表达式确实返回了对新建对象的引用，但构造器本身并没有返回任何值）。假如构造器具有返回值，并且允许程序员自行选择返回类型，那么势必得让编译器知道该如何处理此返回值。 第5章-2 方法重载 任何程序设计语言都具备一项重要特性，就是对名字的运用。 当创建一个对象时，也就是给这个对象分配到的存储空间取了一个名字。 所谓方法就是给某个动作取的名字。 通过使用名字，你可以引用所有的对象和方法。 名字起的好可以更易于理解和修改。 第5章-3 默认构造器默认构造器（又称&thinsp;无参构造器）是没有形式参数的，它的作用是创建一个默认对象。 如果一个类中没有构造器，则编译器会自动创建一个该类的默认构造器；而如果类中已经定义了构造器（无论是否有参数），则编译器不会再为该类创建默认构造器。 第5章-4 this关键字方法调用时，往往需要指定&thinsp;对象（static方法&thinsp;还可以直接指定&thinsp;类class）。 示例： …… 同一个类型的对象，a&thinsp;和&thinsp;b，想要让它们都能调用同一个方法peel()，该如何实现？ 在&thinsp;Java&thinsp;中，使用了简便且面向对象的语法来编写代码 —— 即“发送消息给对象”，编译器做了一些幕后处理 —— 它将“所操作对象的引用”作为第一个&thinsp;参数&thinsp;传递给&thinsp;方法。 所以，示例中的方法调用代码可以如下解释： ↓ 以下是内部的表现形式（注意：不符合编码规范，编译会报错） this&thinsp;关键字为此而生，它表示对“调用方法的那个对象”的引用，且只能在&thinsp;方法内部&thinsp;使用（指代发起方法调用时，该方法对应的对象）。 this&thinsp;的用法与其他对象引用并无不同。注意，如果在方法内部调用同一个类的另一个方法，不必使用&thinsp;this，直接调用即可。 只有当需要明确指出对当前对象的引用时，才需要使用&thinsp;this&thinsp;关键字。例如，当需要返回对当前对象的引用时，就可以这样写：…… this&thinsp;引用对于将当前对象传递给其他方法也很有用。…… 第5章-4-1 在构造器中调用构造器调用形式：this(参数类型列表) 例子： …… 在&thinsp;构造器&thinsp;中，最多只能调用一次&thinsp;构造器。（否则编译报错） 在&thinsp;构造器&thinsp;中，[&thinsp;调用构造器&thinsp;的代码&thinsp;]&thinsp;必须在&thinsp;最开始的地方。（否则编译报错） 这个例子中也展示了&thinsp;this&thinsp;的另一种用法&ensp;——&ensp;避免歧义。 由于参数s的名称和数据成员s的名称相同，同时使用会产生歧义；使用this.s来代表数据成员就能解决这个问题。 第5章-4-2 static的含义了解this关键字以后，就能更好地理解static（静态）方法的含义。 static方法&thinsp;中不能使用&thinsp;this。 使用static方法时，由于不存在this，所以它不是通过“向对象发送消息”来完成的。 static方法&thinsp;中不能（直接）调用&thinsp;非静态方法&thinsp;和&thinsp;非静态对象（涉及到底层加载顺序）；而&thinsp;非静态方法&thinsp;中可以调用&thinsp;静态方法&thinsp;和&thinsp;静态对象。 static方法&thinsp;的&thinsp;加载&thinsp;是依附于&thinsp;类class&thinsp;而不是&thinsp;类的对象Object：可以在没有创建任何对象的前提下，通过&thinsp;类本身&thinsp;来调用static方法，这正是static方法&thinsp;的主要用途。 static方法很像&thinsp;全局方法；Java&thinsp;中禁止使用全局方法，但你在static方法中就能访问其他static方法&thinsp;和&thinsp;static域。 第5章-5 清理：终结处理和垃圾回收在&thinsp;Java&thinsp;中，有&thinsp;垃圾回收器&thinsp;负责回收无用对象占据的内存资源。但也有特殊情况，由于&thinsp;垃圾回收器&thinsp;只能释放那些经由new分配的内存，所以那些不使用new获得的特殊内存将不会被垃圾回收器正常处理释放。 为了应对这种情况，Java&thinsp;允许在类中定义一个名为finalize()的方法。…… Java&thinsp;中的&thinsp;垃圾回收： 对象&thinsp;可能不被&thinsp;垃圾回收。 垃圾回收&thinsp;不等于“析构”。 垃圾回收&thinsp;只与&thinsp;内存&thinsp;有关。 …… 第5章-5-1 finalize()的用途何在此时，已经明确了不该将finalize()作为通用的清理方法，那么finalize()真正的用途是什么呢？ 垃圾回收只与内存有关…… 第5章-5-2 你必须实施清理…… 第5章-5-3 终结条件…… 第5章-5-4 垃圾回收器如何工作…… 第5章-6 成员初始化Java&thinsp;尽力保证：所有变量在使用前都能得到恰当的&thinsp;初始化。Java&thinsp;不允许使用&thinsp;方法的局部变量。…… 方法中定义的变量&thinsp;没有初值，但是&thinsp;类的数据成员（即字段）会有&thinsp;默认值。…… 在&thinsp;类&thinsp;中定义一个&thinsp;对象引用&thinsp;时，如果不将其&thinsp;初始化，此引用会获得一个特殊值null。类中定义的&thinsp;基本数据类型，会有&thinsp;对应类型的默认值。 第5章-6-1 指定初始化第5章-7 构造器初始化可以用构造器来进行初始化。 在运行时刻，可以调用方法或者执行某些动作来确定初值，这为编程带来了极大的便利性。 但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。 因此假如使用如下代码： 那么类Test的数据成员（字段）i会首先被置为0（默认值），然后被&thinsp;构造器&thinsp;置为7。运行结果： 对于所有&thinsp;基本类型&thinsp;和&thinsp;对象引用，包括&thinsp;在定义时&thinsp;直接指定初值的变量，这种情况都是成立的。 第5章-7-1 初始化顺序在[&thinsp;类的内部&thinsp;]，变量定义的顺序&thinsp;决定了&thinsp;初始化的顺序；并且，变量的初始化（默认值）&thinsp;会在&thinsp;任何方法（包括构造器）被调用之前。 示例： …… 第5章-7-2 静态数据的初始化无论创建多少个对象，静态数据&thinsp;都只占用一份存储区域。 static关键字不能应用于&thinsp;局部变量，因此它只能作用于&thinsp;域。 如果一个&thinsp;域&thinsp;是&thinsp;静态的基本类型域，且没有被&thinsp;初始化，那么它就会被自动赋予&thinsp;默认值（基本类型 → 对应类型的默认值，引用类型 → null）。 如果想在&thinsp;定义处&thinsp;进行初始化，采取的方法和&thinsp;非静态数据&thinsp;没什么不同。 要想了解静态存储区域是何时初始化的，需要用到下面这个例子： …… ……由输出可见，静态初始化&thinsp;只有在必要时刻才会进行。…… 初始化的顺序&thinsp;是先&thinsp;静态对象（如果它们尚未因排序在前的对象创建而被初始化），而后是&thinsp;非静态对象。…… 总结一下对象创建的过程（书中的总结不够好，详见习题） 假设有个名为&thinsp;Dog&thinsp;的类： 首次创建&thinsp;类型为Dog的&thinsp;对象&thinsp;时，或者Dog类的&thinsp;，静态方法&thinsp;/&thinsp;静态域&thinsp;首次被访问时，Java&thinsp;解释器&thinsp;将会查找类的路径，定位Dog.class文件。 载入Dog.class（后面章节会提及，这将&thinsp;创建一个对象），有关&thinsp;静态初始化&thinsp;的所有动作都会执行。 因此，静态初始化&thinsp;只在Class对象&thinsp;首次加载时&thinsp;进行一次。 当用new Dog()创建对象的时候： 首先，将&thinsp;在堆上&thinsp;为Dog对象&thinsp;分配&thinsp;足够的存储空间。🡇 这块存储空间会被清零，这就自动地将Dog对象中的&thinsp;所有基本类型数据&thinsp;都设置成了&thinsp;默认值。🡇 然后，执行所有出现于&thinsp;字段定义处&thinsp;的&thinsp;初始化动作。🡇 最后，执行&thinsp;构造器。正如第7章所看到的，这可能会涉及到很多动作，尤其是涉及到&thinsp;继承&thinsp;的时候。 第5章-7-3 显式的静态初始化Java&thinsp;允许将多个&thinsp;静态初始化动作&thinsp;组织成一个特殊的“静态子句”（有时也叫做“静态块”）。 语法形式： 尽管上面的代码看起来像个方法，但它实际上只是一段跟在static关键字后面的代码；与其他初始化动作一样，这段代码仅会执行一次。 示例： …… 第5章-7-4 非静态实例初始化Java&thinsp;中也有被称为&thinsp;实例初始化&thinsp;的类似语法，用来初始化每一个对象的&thinsp;非静态变量。 示例： 输出： ⤷你可以看到&thinsp;实例初始化子句： ⤷它看起来与静态初始化子句一样，只不过少了static关键字。这种语法对于支持“匿名内部类”（参见第10章）是必须的，但是它也使得无论你调用哪个显式构造器，某些操作都会发生。 从输出中可以看到，实例初始化子句&thinsp;是在两个&thinsp;构造器&thinsp;之前执行的。 第5章-8 数组初始化数组→概念数组&thinsp;是&thinsp;用一个&thinsp;标识符名称&thinsp;封装到一起的、相同类型的&thinsp;[&thinsp;一个&thinsp;对象序列&thinsp;或&thinsp;基本类型数据序列&thinsp;]。 数组→定义和使用数组&thinsp;是&thinsp;通过方括号下标操作符[]来&thinsp;定义和使用的。 要定义一个数组…… 要定义一个数组，只需在&thinsp;类型名&thinsp;后面加上一对方括号[]即可（或许更合理）：⤵ 也可以将方括号[]置于标识符后面（符合C和C++程序员的习惯）：⤵ 数组→特点 编译器不允许指定&thinsp;数组的大小。这是因为数组是一组&thinsp;对象的引用（Java&thinsp;中&thinsp;对象引用本身&thinsp;是不变的，但是&thinsp;所引用的对象&thinsp;是可变的），所以&thinsp;声明时&thinsp;无法指定数组的成员数量，但是&thinsp;创建时&thinsp;不受限制。 所有数组都有一个&thinsp;固有成员length…… 数组初始化的3种方式 （只能在&thinsp;创建数组的地方&thinsp;使用）花括号&#123;&#125;&ensp;+&ensp;数组成员。此时存储空间的分配（等价于使用new）将由编译器负责： new&ensp;+&ensp;类型说明&ensp;+&ensp;成员数量说明： 演示： 👆 输出⤵ 示例： 👆 …… 初始化进程说明&ensp;→&ensp;此时，即便使用new创建数组之后：⤵ ⤷&ensp;它还只是一个&thinsp;引用数组，直到通过创建新的Integer对象（本例中通过&thinsp;自动包装机制&thinsp;创建），并把&thinsp;对象&thinsp;赋值给&thinsp;引用，初始化进程&thinsp;才算结束。⤵ ⤷&ensp;如果忘记了创建对象，并且试图使用数组中的空引用，就会出现运行时异常。 new&ensp;+&ensp;类型说明&ensp;+&ensp;花括号&#123;&#125;&ensp;+&ensp;数组成员：⤵ 演示： 输出：⤵ 第5章-8-1 可变参数列表 “new&ensp;+&ensp;类型说明&ensp;+&ensp;花括号&#123;&#125;&ensp;+&ensp;数组成员”形式的&thinsp;数组初始化方法，可以用于Object数组实现与&thinsp;C&thinsp;的&thinsp;可变参数列表&thinsp;一样的效果。⤵ ⤷&ensp;示例： ⤷&ensp;输出：⤵ 在&thinsp;Java&thinsp;SE&thinsp;5&thinsp;之前，通常使用上例来实现；而从&thinsp;Java&thinsp;SE&thinsp;5&thinsp;开始，提供了对&thinsp;可变参数&thinsp;的语法支持。有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上将会自动填充数组。⤵ ⤷&ensp;示例： 输出：⤵ 在&thinsp;可变参数列表&thinsp;中，可以使用&thinsp;任何类型的参数，包括&thinsp;基本类型（涉及到&thinsp;自动包装机制）。 如果&thinsp;可变参数列表&thinsp;中&thinsp;没有任何参数（包括为空），则&thinsp;参数传递时&thinsp;转变为&thinsp;数据尺寸为0的&thinsp;指定类型数组。同样，可变参数列表&thinsp;也能直接接受&thinsp;对应类型的数组（此时编译期间将不会再做不必要的数据转换）。 ⤷&ensp;示例： 输出：⤵ 可变参数列表&thinsp;不依赖于&thinsp;自动包装机制&ensp;🡄&ensp;实际上使用的是&thinsp;基本类型⤷&ensp;见示例最后一行→创建并打印出来的int数组（其中的I表示&thinsp;基本数据类型）。 然而，可变参数列表&thinsp;与&thinsp;自动包装机制&thinsp;可以和谐共处。 ⤷&ensp;示例： 输出：⤵ 注意：你可以在&thinsp;单一类型的参数列表&thinsp;中&thinsp;将类型混合在一起，而&thinsp;自动包装机制&thinsp;将有选择地将int参数提升为Integer。 可变参数列表&thinsp;使得&thinsp;重载过程&thinsp;变得复杂了，尽管乍一看似乎足够安全。 ⤷&ensp;示例： 输出：⤵ ⤷&ensp;在每一种情况中，编译器都会使用&thinsp;自动包装机制&thinsp;来匹配&thinsp;重载方法。⤷&ensp;但是在上例中，不传递参数，调用f()时，编译器就无法确定该调用哪个方法（编译不通过）。 可以考虑添加&thinsp;非可变参数&thinsp;来解决&thinsp;重载方法之间&thinsp;可变参数列表混淆&thinsp;的问题。 【设计原则】 如果是&thinsp;有必要在&thinsp;重载方法&thinsp;中使用&thinsp;可变参数列表，请保证&thinsp;至多在重载方法的一个版本中&thinsp;使用&thinsp;可变参数列表，或者不使用它。 某些情况下，可以考虑使用&thinsp;恰当类型的数组&thinsp;来替代&thinsp;可变参数列表。 第5章-9 枚举类型在&thinsp;Java&thinsp;SE&thinsp;5&thinsp;中添加了一个看似很小的新特性&ensp;——&ensp;enum关键字，它使得我们需要群组并使用&thinsp;枚举类型集&thinsp;时，可以很方便地处理。 C&thinsp;/&thinsp;C++&thinsp;都有&thinsp;枚举类型，现在&thinsp;Java&thinsp;也拥有&thinsp;枚举类型&thinsp;且比它们的要完备得多。 额外参考资料 枚举类 - 廖雪峰的官方网站 Java 中的枚举 (enum) - 简书 Java 枚举(enum) 详解7种常见的用法_请叫我大师兄-CSDN博客_枚举 第5章-9-1 枚举类（enum）——基本概念 枚举类：一种&thinsp;特殊的类，其&thinsp;实例对象&thinsp;是&thinsp;有限且固定的。 枚举类（enum）的特点 枚举类&thinsp;和普通的类（class）一样，有自己的&thinsp;成员变量、成员方法、构造器（因为&thinsp;设计时&thinsp;限定使用private访问修饰符，故无法&thinsp;从外部&thinsp;调用&thinsp;枚举类的构造器，只能&thinsp;在构造枚举值时&thinsp;调用&thinsp;对应枚举类的构造器）。 与普通类（class）一样，一个&thinsp;Java&thinsp;源文件中最多只能有一个public类型的&thinsp;枚举类，且&thinsp;该&thinsp;Java&thinsp;源文件的名称&thinsp;必须与&thinsp;该枚举类的名称&thinsp;相同。 枚举类（enum）默认继承了java.lang.Enum类，并实现了 java.lang.Seriablizable和java.lang.Comparable两个接口。 ⤷&ensp;枚举类&thinsp;是非抽象的，且不能再派生出子类。 尽管&thinsp;枚举类&thinsp;不能被继承，但是可以有&thinsp;抽象方法&ensp;🡆&ensp;枚举类的抽象方法&thinsp;必须必需被其每一个&thinsp;枚举值&thinsp;实现。 所有的&thinsp;枚举值&thinsp;都是&thinsp;限定public static final修饰的。 在&thinsp;Java&thinsp;中，使用enum关键字来定义&thinsp;枚举类；其地位与class和interface相同。 枚举类的&thinsp;所有实例，必须在&thinsp;枚举类的第一行&thinsp;显式地列出；否则这个&thinsp;枚举类&thinsp;将&thinsp;不能生成实例。⤷&ensp;同时，编译器会自动地为&thinsp;枚举值&thinsp;添加public static final修饰，无需程序员显式添加。 第5章-9-2 枚举类的使用…… 参看项目&thinsp;[&thinsp;SuiteLHY/DingDing - githun.com&thinsp;]&thinsp;代码 第5章-10 总结 类（class）的&thinsp;初始化顺序： 父类的&thinsp;静态成员变量&thinsp;和&thinsp;静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 子类的&thinsp;静态成员变量&thinsp;和&thinsp;静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 父类的&thinsp;非静态成员变量&thinsp;和&thinsp;非静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 父类的&thinsp;构造方法；🡇 子类的&thinsp;非静态成员变量&thinsp;和&thinsp;非静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 子类的&thinsp;构造方法。 第6章 访问权限控制访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。…… 为了解决这一问题，Java&thinsp;提供了&thinsp;访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的。 访问权限的控制等级，从最大权限到最小权限依次为：public&ensp;🡆&ensp;protected&ensp;🡆&ensp;[&thinsp;包访问权限&thinsp;]（没有关键词）&ensp;🡆&ensp;private。 ……对于这一点，Java&thinsp;用关键字package加以控制；而&thinsp;访问权限修饰词&thinsp;会因为&thinsp;类class是否在同一个包下&thinsp;而受到影响。 …… 第6章-1 包：库单元包package内包含有一组&thinsp;[&thinsp;类class&thinsp;/&thinsp;接口interface&thinsp;/&thinsp;枚举enum&thinsp;]，它们&thinsp;在单一的名字空间下&thinsp;被组织在了一起。…… 第6章-1-1 代码组织 当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件；该输出文件的名称与.java文件中的每个类的名称相同，且后缀名为.class。因此，在编译少量的.java文件之后，会得到大量的.class文件。 如果用编译型语言编写过程序，就会清楚：在传统的编译型语言中，编译器产生一个中间文件（通常是一个obj文件），然后再与通过链接器（用于创建一个可执行文件）或类库产生器（librarian，用以创建一个类库）产生的其他同类文件捆绑在一起。 然而&thinsp;Java&thinsp;的可运行程序，是一组可以打包并压缩为一个&thinsp;Java&thinsp;文档文件（JAR，使用&thinsp;Java&thinsp;的&thinsp;jar&thinsp;文档生成器）的.class文件。⤷&ensp;Java&thinsp;解释器&thinsp;负责这些文件的&thinsp;查找、装载&thinsp;和&thinsp;解释。 类库&thinsp;实际上是一组类文件.class。其中每个文件都有一个public类，以及&thinsp;任意数量的&thinsp;非public类；因此每个文件都有一个构件。如果希望这些构件（每一个都有它们自己独立的.java和.class文件）从属于同一个群组，可以使用关键字package。 如果使用package语句，它必须是&thinsp;文件中&thinsp;除注释以外的&thinsp;第一行程序代码。在&thinsp;文件起始处&thinsp;写：⤵ ⤷&ensp;（请注意，Java&thinsp;包的命名规则是&thinsp;全部使用小写字母，包括中间的字母也是如此） 注意：关键字import与通配符*搭配，不能定位到命名空间下的包（不能保证没有冲突）。 第6章-1-2 创建独一无二的包名 既然一个包&thinsp;从未真正地将&thinsp;被打包的东西&thinsp;包装成&thinsp;单一的文件，并且一个包可以由许多.class文件构成；那么仅仅是这样，就可能出现名称完全相同的.class文件混淆在一起。 ⤷&ensp;为了避免这种情况，Java&thinsp;将每个包的所有.class文件都置于独一无二的目录下。…… 冲突…… 注意：import关键字&thinsp;和&thinsp;通配符*，不能定位指定命名空间下的包（package），因为没有分配资源去进行&thinsp;唯一性的校验，无法避免&thinsp;包名冲突。 第6章-1-3 定制工具库…… 第6章-1-4 用import改变行为…… 第6章-1-5 对使用包的忠告务必记住，无论何时创建&thinsp;包（package），都已经在给定&thinsp;包的名称&thinsp;的时候隐式地指定了目录结构。 第6章-2 Java访问权限修饰词…… 第6章-3 接口和实现 访问权限的控制&thinsp;常被称为是&thinsp;具体实现的隐藏。 封装：把&thinsp;数据&thinsp;和&thinsp;方法&thinsp;包装进&thinsp;类（class）&thinsp;中，隐藏&thinsp;类（class）的具体实现。其结果是&thinsp;生成一个&thinsp;带有特征和行为的&thinsp;数据类型。 使用封装的原因（好处）在结构中建立内部机制，将公开的接口和具体实现分离。⤴&ensp;隐藏实现细节，提供公共的访问方式。⤵ 提高代码的可维护性。 提高代码的可重用性。 提高数据的安全性。 第6章-4 类的访问权限在&thinsp;Java&thinsp;中，访问权限修饰词&thinsp;也可以用于&thinsp;确定库中的哪些类对于该库的使用者是可用的。 如果希望某个类可以为客户端程序员所用，就可以通过把关键字public作用于整个类的定义来实现。这样做甚至可以控制客户端程序员是否能创建一个该类的对象。 实现形式： …… 访问权限修饰词&thinsp;还有一些额外的限制： 每个编译单元（文件）都只能有一个public类。⤷&ensp;这表示，每个编译单元&thinsp;都有一个&thinsp;唯一的公共接口，通过public实现。 public类的名称必须完全与含有该编译单元的文件名一致（包括大小写）。 虽然不是很常用，但编译单元内完全不带public类也是可以的。⤷&ensp;此时文件的命名不受限制。 第6章-5 总结…… 第7章 复用类 复用代码&thinsp;是&thinsp;Java&thinsp;众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它必须能够做更多的事情。 在&thinsp;Java&thinsp;中，所有问题的解决都是围绕着&thinsp;类（class）&thinsp;展开的。可以通过创建新类来复用代码。此方法的窍门在于使用&thinsp;类&thinsp;而不破坏现有程序代码。 第1种实现方法非常直观：只需在新的类中创建现有类的对象。该方法只是复用了现有程序代码的功能，而非它的形式。由于新的类是由现有类的对象所组成，所以这种方法称为&thinsp;组合。 第2种方法则更细致一些，它按照现有类的类型来创建新类，无需改变现有类的形式，采用现有类的形式，并在其基础上添加新的代码，这种方法被称为&thinsp;继承。编译器完成其中绝大部分的工作。继承&thinsp;是面向对象的基础之一。 第7章-1 组合语法使用组合技术，只需要将对象引用置于新的类中即可。对于&thinsp;基本类型数据，可以直接定义；而对于&thinsp;非基本类型的对象，必须将其&thinsp;引用&thinsp;置于新的类中。 编译器并不会为每一个引用都创建默认对象，为的是避免不必要的负担（现在Java之父后悔了！声称：当初是因为实现简单才这样设计的；后来的使用中造成了至少10亿美元的损失）。 如果想要初始化引用，可以在下列位置中进行： 定义对象的地方。这意味着它们总是能够在被构造器调用之前被初始化。 类的构造器中。 在使用这些对象的代码之前，这种方式被称为惰性初始化。&ensp;在声明的引用不必每次都生成对象的情况下，可以避免不必要的负担。 使用实例初始化。 示例： …… 第7章-2 继承语法继承是所有&thinsp;OOP&thinsp;语言不可缺少的组成部分。 当创建一个类时，总是在&thinsp;继承；除非明确地指出要从其他类中继承，否则就是在隐式地从&thinsp;Java&thinsp;的标准根类Object进行继承。 继承的语法：……关键字extends 第7章-2-1 初始化基类继承&thinsp;涉及到&thinsp;基类（被继承的类，又称&thinsp;父类、超类）和&thinsp;派生类（继承的类，又称&thinsp;子类、导出类）2个类。 从外部看，派生类的对象&thinsp;就像是一个&thinsp;与基类具有相同接口的新类，或许还会有一些额外的&thinsp;方法&thinsp;和&thinsp;域。但&thinsp;继承&thinsp;并不只是单纯地复制基类的接口。 Java会自动在派生类的构造器中插入对基类构造器的调用。 当通过继承创建了一个派生类的对象时，该对象包含了一个基类（超类）的子对象。⤷&ensp;其中，对基类的子对象的正确初始化也是至关重要的，而且有且仅有一种方法来保证这一点：在&thinsp;派生类构造器&thinsp;中调用&thinsp;基类构造器&thinsp;来执行初始化，且&thinsp;必须&thinsp;在派生类构造器中&thinsp;最开始执行。 在设计上，基类的构造器&thinsp;具有&thinsp;执行基类初始化所需要的&thinsp;所有知识和能力，包括&thinsp;超类对象的&thinsp;构造器调用所必需的能力。 示例： …… 带参数的构造器 上例中各个类均含有默认的构造器，即不带参数的构造器。 如果没有&thinsp;默认的&thinsp;基类构造器，或者想要&thinsp;调用一个&thinsp;带参数的&thinsp;基类构造器，就必须&thinsp;使用关键字super&thinsp;显式地编写&thinsp;调用基类构造器的语句，同时配以适当的&thinsp;参数列表。 需要格外注意的是：在&thinsp;子类构造器&thinsp;中，对&thinsp;超类构造器&thinsp;的（显式）调用动作&thinsp;必须在最开始定义。 示例： …… 【拓展】第7章-2-2 重写 参考资料：【runoob.com】Java 重写(Override)与重载(Overload) 重写（Override）&thinsp;是&thinsp;子类对&thinsp;[&thinsp;父类中&thinsp;允许子类访问的方法&thinsp;]&thinsp;的实现过程&thinsp;进行重新编写（方法名、返回值、形参列表&thinsp;都保持一致，访问权限&thinsp;和&thinsp;抛出异常&thinsp;符合重写规则）。 在面向对象原则里，重写（Override）意味着可以重写任何现有的方法。 重写（Override）的好处 子类可以根据自己的需要，定义特定于自己的行为（即子类能够根据需要实现父类的方法）。 重写（Override）规则 参数列表&thinsp;必须&thinsp;与&thinsp;被重写的方法&thinsp;完全相同（参数个数、参数类型&thinsp;及其&thinsp;排列方式）。 访问权限&thinsp;对比&thinsp;父类中被重写的方法&thinsp;更高&thinsp;或&thinsp;相等。⤷&ensp;例如：如果一个&thinsp;父类的方法&thinsp;被声明为public，那么&thinsp;子类中对应的重写方法&thinsp;就不能声明为protected。 父类中的方法&thinsp;只能&thinsp;被它的子类&thinsp;重写。 声明为final的方法&thinsp;不能被重写。 声明为static的方法&thinsp;不能被重写，但是能够&thinsp;被再次声明。 static方法&thinsp;仅与&thinsp;类（class）&thinsp;绑定，而不与&thinsp;类的具体对象&thinsp;绑定； 继承&thinsp;是描述&thinsp;对象之间的关系&thinsp;的概念。 ⤷&ensp;所以&thinsp;static方法&thinsp;与&thinsp;重写（Override）的概念&thinsp;搭不上边。 构造方法&thinsp;不能被重写。 如果不能&thinsp;继承&thinsp;一个方法，则不能&thinsp;重写&thinsp;这个方法。 如果&thinsp;子类和父类&thinsp;在同一个包中，那么&thinsp;子类&thinsp;可以重写&thinsp;[&thinsp;父类中&thinsp;除了声明为private或final的&thinsp;其他所有方法&thinsp;]。 如果&thinsp;子类和父类&thinsp;在不同的包中，那么&thinsp;子类&thinsp;只能够重写&thinsp;[&thinsp;父类中&thinsp;声明为public或protected的、非final修饰的&thinsp;所有方法&thinsp;]。 重写的方法&thinsp;能够抛出&thinsp;任何非强制异常，无论&thinsp;被重写的方法&thinsp;是否抛出异常；⤷&ensp;不能抛出&thinsp;新的强制性异常，或者&thinsp;[&thinsp;比&thinsp;被重写的方法&thinsp;声明得更广泛的&thinsp;强制性异常&thinsp;]。 Super关键字的使用 当需要&thinsp;在子类中&thinsp;调用&thinsp;父类的被重写方法&thinsp;时，要使用super关键字（类似this关键字；代替&thinsp;父类指针）。 重写（Override）与重载（Overload）之间的区别 区别点 重载（Overload） 重写（Override） 参数列表 必须修改 必须一致 返回类型 可以修改 必须一致 访问权限 可以修改 可以&thinsp;保持一致&thinsp;或&thinsp;降低限制，不能做更严格的限制（访问权限&thinsp;不能提高） 抛出异常 可以修改 可以&thinsp;减少&thinsp;或&thinsp;删除，不能抛出&thinsp;新的&thinsp;或者&thinsp;范围更广泛的&thinsp;强制性异常 重写（Override）与重载（Overload）之间的联系 方法的&thinsp;重写（Override）和&thinsp;重载（Overload）&thinsp;是&thinsp;Java&thinsp;多态性&thinsp;的不同表现 重写（Override）&thinsp;是&thinsp;父类与子类之间&thinsp;多态性的一种表现； 重载（Overload）&thinsp;可以理解成多态的具体表现形式。 第7章-3 代理第7章-4 结合使用组合和继承同时使用组合和继承是很常见的事。…… 第7章-4-1 确保正确清理Java&thinsp;中没有&thinsp;C++&thinsp;中&thinsp;析构函数&thinsp;的概念。 析构函数&thinsp;是一种&thinsp;在对象被销毁时&thinsp;可以被自动调用的函数。 ⤷&ensp;其原因可能是在&thinsp;Java&thinsp;的设计中，销毁对象的操作&thinsp;由&thinsp;垃圾回收器&thinsp;进行控制执行。 ⤷&ensp;通常这样做是好事，但有时&thinsp;类（class）&thinsp;可能要&thinsp;在生命周期内&thinsp;执行一些必需的&thinsp;清理活动。…… 第7章-4-2 名称屏蔽如果&thinsp;Java&thinsp;的基类&thinsp;拥有某个&thinsp;已被多次重载（Overload）的方法名称，那么&thinsp;在派生类中&thinsp;重新定义该方法名称时，并不会&thinsp;屏蔽&thinsp;其&thinsp;在基类中的&thinsp;任何版本。⤷&ensp;因此，无论在该层还是在它的基类中进行定义，重载（Overload）机制都可以正常工作。 ……（C++&thinsp;中设计&thinsp;重写（Override）时&thinsp;屏蔽&thinsp;基类的重载机制&thinsp;的原因之一&ensp;——&ensp;防止程序员犯错误） Java&thinsp;SE&thinsp;5&thinsp;新增加了@Override注解，它并不是关键字，但是可以被当做关键字使用。 @Override注解的作用：在编译时进行&thinsp;重写（Override）检验的&thinsp;编译检查⤷&ensp;防止意外地&thinsp;重载（Override）。 第7章-5 在组合与继承之间选择组合（Composition）&thinsp;和&thinsp;继承（extends）&thinsp;都允许&thinsp;在新的类中&thinsp;放置&thinsp;子对象。组合（Composition）&thinsp;是&thinsp;显式地&thinsp;执行；继承（extends）&thinsp;是&thinsp;隐式地&thinsp;执行。 要想使用好&thinsp;组合&thinsp;和&thinsp;继承，我们需要明确：二者之间的区别何在？怎样在二者之间做出选择？ 组合和继承的区别 在底层实现层面上，继承（extends）&thinsp;实际上是&thinsp;在&thinsp;组合（Composition）的基础上&thinsp;封装实现的抽象逻辑。 在抽象逻辑层面上： 组合（Composition）&thinsp;是“has-a”（有一个）关系的表达； 继承（extends）&thinsp;是“is-a”（是一个）关系的表达。 在&thinsp;Java&thinsp;中，继承（extends）&thinsp;支持&thinsp;从派生类向基类进行&thinsp;向上转型。 在组合和继承之间的选择 组合（Composition）&thinsp;通常用于&thinsp;在新的类中&thinsp;使用&thinsp;现有类的功能&ensp;🡄&ensp;而非现有类的接口。 继承（extends）&thinsp;往往用于&thinsp;在新的类中&thinsp;实现&thinsp;现有类的接口。 第7章-6 protected关键字 理解了&thinsp;继承，关键字protected才具有意义。 protected关键字的作用：限制&thinsp;对&thinsp;类（class）的成员&thinsp;的访问，仅允许&thinsp;[&thinsp;该类的派生类&thinsp;和&thinsp;同一个包下的&thinsp;]&thinsp;任何类&thinsp;访问。 第7章-7 向上转型 “为新的类提供方法”并不是&thinsp;继承&thinsp;技术中最重要的方面，其最重要的方面是&thinsp;表现新的类和基类之间的所属关系，这种关系可以概括为“新的类是现有类的一种类型”。 第7章-7-1 为什么称为向上转型 该术语的使用有其历史原因，并且是以传统的&thinsp;类继承图&thinsp;的绘制方法为基础：将根置于页面的顶端，然后逐渐向下。 由&thinsp;派生类&thinsp;生成&thinsp;基类，在&thinsp;继承图&thinsp;上是向上移动的，因此称为&thinsp;向上转型。 第7章-7-2 再论组合与继承 在&thinsp;OOP&thinsp;中，生成和使用程序代码最有可能采用的方法是&thinsp;组合 &ensp;🡆&ensp;直接将数据和方法包装进一个类中，并使用该类的对象。 判断是否应该使用&thinsp;继承，最清晰的标准是&thinsp;是否需要&thinsp;从派生类向基类进行&thinsp;向上转型。 第7章-8 final关键字根据&thinsp;上下文环境，Java&thinsp;的关键字final的含义存在细微的差别，通常它指的是“这是无法改变的”。 ⤷&ensp;不想改变可能出于2种理由：设计&thinsp;或&thinsp;效率（Java&thinsp;SE&thinsp;5&thinsp;之后不需要考虑，交由&thinsp;JVM&thinsp;来优化）。 ⤷&ensp;由于这2个原因相差很远，因此关键字final有可能被误用。 下面讨论可能使用到final的3种情况：数据、方法、类。 第7章-8-1 final数据许多编程语言都有某种方法，来向编译器告知一块数据是&thinsp;恒定不变的。 对于&thinsp;数据的恒定不变，有2种情况： 一个&thinsp;永不改变的&thinsp;编译时常量：以final关键字修饰，且&thinsp;值&thinsp;为&thinsp;基本数据类型的数据（总之就是&thinsp;编译期&thinsp;能够确定值的对象）。 对于&thinsp;编译常量&thinsp;这种情况，编译器可以将该&thinsp;常量值&thinsp;代入任何可能用到它的计算式中。即&thinsp;在编译时&thinsp;执行计算式，减轻运行时负担。 在&thinsp;Java&thinsp;中，这类&thinsp;常量&thinsp;必须是&thinsp;基本数据类型，并且以final关键字修饰。 一个&thinsp;运行时常量&ensp;——&ensp;在运行时&thinsp;被初始化的值，且不希望它被改变。 在&thinsp;Java&thinsp;中，当final关键字修饰&thinsp;对象引用&thinsp;时，该&thinsp;对象引用&thinsp;会恒定不变（一旦该引用被初始化指向一个对象，就不会再被更改为其他对象）；然而，该引用所指向的对象，其自身是可以被修改的。 Java&thinsp;并未提供&thinsp;使任何对象恒定不变&thinsp;的途径（可以自己编写&thinsp;类&thinsp;以实现&thinsp;使对象恒定不变的效果）。 一个既是static又是final的域，只占据一段不能改变的存储空间（……）。 示例： 下面的示例示范了final域的情况。注意，根据惯例，既是static又是final的域（……）将用&thinsp;大写字母&thinsp;表示，并使用下划线_分隔各个单词。 …… 空白finalJava&thinsp;允许生成“空白final”，所谓空白final是指：被声明为final，但又未给定初值的域。无论什么情况，编译器都确保空白final在使用前被初始化。 空白final在final关键字的使用中提供了更大的灵活性&ensp;——&ensp;一个类中的final域可以根据对象而有所不同，却还能保持其恒定不变的特性。 示例： …… final参数Java&thinsp;允许&thinsp;在参数列表中&thinsp;以声明的方式将&thinsp;参数&thinsp;指明为final。这意味着你无法在方法中更改参数引用&ensp;——&ensp;在方法中可以读参数，但不能修改参数。 这一特性主要用来向&thinsp;匿名内部类&thinsp;传递数据。 第7章-8-2 final方法第7章-8-3 final类第7章-8-4 有关final的忠告第7章-9 初始化类及类的加载第7章-10 总结第8章 多态第8章-1 再论向上转型第8章-2 转机第8章-3 构造器和多态第8章-4 协变返回类型第8章-5 用继承进行设计第8章-5-1 纯继承与拓展第8章-5-2 向下转型与运行时类型识别第8章-6 总结第9章 接口第9章-1 抽象类和抽象方法第9章-2 接口第9章-3 完全解耦第9章-4 Java中的多重继承第9章-5 通过继承来拓展接口第9章-6 适配接口第9章-7 接口中的域第9章-8 嵌套接口第9章-9 接口与工厂第9章-10 总结第10章 内部类第10章-1 创建内部类第10章-2 链接到外部类第10章-3 使用.this与.new第10章-4 内部类与向上转型第10章-5 在方法和作用域内的内部类第10章-6 匿名内部类第10章-7 嵌套类第10章-8 为什么需要内部类第10章-9 内部类的继承第10章-10 内部类可以被覆盖吗第10章-11 局部内部类第10章-12 内部类标识符第10章-13 总结第11章 持有对象第11章-1 泛型和类型安全的容器第11章-2 基本概念第11章-3 添加一组元素第11章-4 容器的打印第11章-5 List（原理 &amp; 简介）第11章-6 迭代器第11章-7 LinkedList第11章-8 Stack第11章-9 Set第11章-10 Map第11章-11 Queue第11章-12 Collection和Iterator第11章-13 Foreach与迭代器第11章-13-1 适配器方法惯用法→示例源码说明第11章-14 总结第12章 通过异常处理错误第12章-1 概念第12章-2 基本异常第12章-2-1 捕获异常参数第12章-3 捕获异常第12章-3-1 try块第12章-3-2 异常处理程序第12章-4 创建自定义异常第12章-4-1 异常与记录日志第12章-5 异常说明第12章-6 捕获所有异常第12章-6-1 栈轨迹第12章-6-2 重新抛出异常第12章-6-3 异常链第12章-7 Java标准异常第12章-7-1 特例：RuntimeException第12章-8 使用finally进行清理第12章-8-1 finally用来做什么第12章-8-2 在return中使用finally第12章-8-3 缺憾：异常缺失第12章-9 异常的限制第12章-10 构造器第12章-11 异常匹配第12章-12 其他可选方式第12章-12-1 历史第12章-12-2 观点第12章-12-3 把异常传递给控制台第12章-12-4 把“被检查的异常”转换为“不检查的异常”第12章-13 异常使用指南第12章-14 总结第13章 字符串第13章-1 不可变String第13章-2 重载“+”与StringBuilder第13章-3 无意识的递归第13章-4 String上的操作第13章-5 格式化输出第13章-5-4 格式化说明符第13章-6 正则表达式第13章-7 扫描输入第13章-8 StringTokenizer（已废弃）第13章-9 总结第14章 类型信息（RTTI）第14章-1 为什么需要RTTI第14章-2 Class对象第14章-2-1 类字面量第14章-2-2 泛化的Class引用第14章-2-3 类的转换（原：新的转型语法）第14章-3 类型转换前先做检查第14章-4 注册工厂第14章-5 instanceof与Class的等价性第14章-6 反射：运行时的类信息第14章-6-1 类方法提取器第14章-7 动态代理第14章-8 空对象第14章-8-1 模拟对象与桩第14章-9 接口与类型信息第14章-10 总结第15章 泛型第15章-1 与C++比较第15章-2 简单泛型第15章-2-1 一个元祖类库第15章-2-2 一个堆栈类第15章-2-3 RandomList第15章-3 泛型接口第15章-4 泛型方法第15章-4-1 杠杆利用类型参数判断第15章-4-2 可变参数与泛型方法第15章-4-3 用于Generator的泛型方法第15章-4-4 一个通用的Generator第15章-4-5 简化元祖的使用第15章-4-6 一个Set实用工具第15章-5 匿名内部类第15章-6 构建复杂模型第15章-7 擦除的神秘之处第15章-7-1 C++的方式第15章-7-2 迁移兼容性第15章-7-3 擦除的问题第15章-7-4 边界处的动作第15章-8 擦除的补偿第15章-8-1 创建类型实例第15章-8-2 泛型数组第15章-9 边界第15章-10 通配符第15章-10-1 编译器有多聪明第15章-10-2 逆变第15章-10-3 无界通配符第15章-10-4 捕获转换（通配符捕获）第15章-11 问题第15章-11-1 任何基本类型都不能作为类型第15章-11-2 实现参数化接口第15章-11-3 转型和警告第15章-11-4 重载第15章-11-5 基类劫持了接口第15章-12 自限定的类型第15章-12-1 古怪的循环泛型第15章-12-2 自限定第15章-12-3 参数协变第15章-13 动态类型安全第15章-14 异常第15章-15 混型第15章-15-1 C++中的混型第15章-15-2 与接口混合第15章-15-3 使用装饰器模式第15章-15-4 与动态代理混合第15章-16 潜在类型机制第15章-17 对缺乏潜在类型机制的补偿第15章-17-1 反射第15章-17-2 将一个方法应用于序列第15章-17-3 当你并为碰巧拥有正确的接口时第15章-17-4 用适配器仿真潜在类型机制第15章-18 将函数对象用作策略第15章-19 总结：转型真的如此之糟吗？第15章-19-1 进阶读物第16章 数组第16章-1 数组为什么特殊第16章-2 数组是第一级对象第16章-3 返回一个数组第16章-4 多维数组第16章-5 数组与泛型第16章-6 创建测试数据第16章-6-1 Arrays.fill()第16章-6-2 数据生成器第16章-6-3 从Generator中创建数组第16章-7 Arrays实用功能第16章-7-1 复制数组第16章-7-2 数组的比较第16章-7-3 数组元素的比较第16章-7-4 数组排序第16章-7-5 在已排序的数组中查找第16章-8 总结第17章 容器深入研究第17章-1 完整容器分类法第17章-2 填充容器第17章-2-1 一种Generator解决方案第17章-2-2 Map生成器第17章-2-3 使用Abstract类第17章-3 Collection的功能方法第17章-4 可选操作第17章-4-1 未获支持的操作第17章-5 List的功能方法第17章-6 Set和存储排序第17章-6-1 SortedSet第17章-7 队列第17章-7-1 优先级队列第17章-7-2 双向队列第17章-8 理解Map第17章-8-1 性能第17章-8-2 SortedMap第17章-8-3 LinkedHashMap第17章-9 散列与散列码第17章-9-1 理解hashCode()第17章-9-2 为速度而散列第17章-9-3 覆盖hashCode()第17章-10 选择接口的不同实现第17章-10-1 性能测试框架第17章-10-2 对List的选择第17章-10-3 微基准测试的危险第17章-10-4 对Set的选择第17章-10-5 对Map的选择第17章-11 实用方法第17章-11.1 List的排序和查询第17章-11.2 设定Collection或Map为不可修改第17章-11.3 Collection或Map的同步控制第17章-12 持有引用第17章-12.1 WeakHashMap第17章-13 Java 1.0-1.1的容器第17章-13.1 Vector和Enumeration第17章-13.2 Hashtable第17章-13.3 Stack第17章-13.4 BitSet第17章-14 总结第18章 Java IO系统第18章-1 File类第18章-1-1 目录列表器第18章-1-2 目录实用工具第18章-1-3 目录的检查及创建第18章-2 输入（Input）和输出（Output）第18章-2-1 InputStream类型第18章-2-2 OutputStream类型第18章-3 添加属性和有用的接口第18章-3-1 通过FilterInputStream从InputStream读取数据第18章-3-2 通过FilterOutputStream从OutputStream写入第18章-4 Reader和Writer第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）第18章-4-2 更改流的行为第18章-4-3 未发生变化的类第18章-5 自我独立的类：RandomAccessFile第18章-6 IO流的典型使用方式第18章-6-1 缓冲输入文件第18章-6-2 从内存输入第18章-6-3 格式化的内存输入第18章-6-4 基本的文件输出第18章-6-5 存储和恢复数据第18章-6-6 随机读写访问文件第18章-6-7 管道流第18章-7 文件读写的实用工具第18章-7-1 读取二进制文件第18章-8 标准IO第18章-8-1 从标准输入中读取第18章-8-2 将System.out转换成PrintWriter第18章-8-3 标准IO重定向第18章-9 进程控制第18章-10 新IO第18章-10-1 转换数据第18章-10-2 获取基本类型第18章-10-3 视图缓冲器第18章-10-4 用缓冲器操纵数据第18章-10-5 缓冲器的细节第18章-10-6 内存映射文件第18章-10-7 文件加锁第18章-11 压缩第18章-11-1 用GZIP进行简单压缩第18章-11-2 用Zip进行多文件保存第18章-11-3 Java档案文件第18章-12 对象序列化第18章-12-1 寻找类第18章-12-2 序列化的控制第18章-12-3 使用“持久性”第18章-13 XML第18章-14 Preferences第18章-15 总结第19章 枚举类型第19章-1 基本enum特性第19章-1-1 将静态导入用于enum第19章-2 向enum中添加新方法第19章-2-1 覆盖enum的方法第19章-3 switch语句中的enum第19章-4 values()的神秘之处第19章-5 实现而非继承第19章-6 随机选取第19章-7 使用接口组织枚举第19章-8 使用EnumSet替代标志第19章-9 使用EnumMap第19章-10 常量相关的方法（枚举类的抽象方法）第19章-10-1 使用enum的职责链第19章-10-2 使用enum的状态机第19章-11 多路分发第19章-11-1 使用enum分发第19章-11-2 使用常量相关的方法第19章-11-3 使用EnumMap分发第19章-11-4 使用二维数组第19章-12 总结第20章 注解第20章-1 基本语法第20章-1-1 定义注解第20章-1-2 元注解第20章-2 编写注解处理器第20章-2-1 注解元素第20章-2-2 默认值限制第20章-2-3 生成外部文件第20章-2-4 注解不支持继承第20章-2-5 实现处理器第20章-3 使用apt处理注解第20章-4 将观察者模式用于apt第20章-5 基于注解的单元测试第20章-5-1 将@Unit用于泛型第20章-5-2 不需要任何“套件”第20章-5-3 实现@Unit第20章-5-4 移除测试代码第20章-6 总结第21章 并发第21章-1 并发的多面性第21章-2 基本的线程机制第21章-3 共享受限资源第21章-4 终结任务第21章-5 线程之间的协作第21章-6 死锁第21章-7 新类库中的构件第21章-8 仿真第21章-9 性能调优第21章-10 活动对象第21章-11 总结第22章 图形化用户界面 📖参看 主要参看📖 Java | 夜与花海 Java教程 - 廖雪峰的官方网站 《Thinking-in-Java》 | 夜与花海 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;面向对象程序设计 - 维基百科，自由的百科全书 ^&ensp;面向对象程序设计（一种计算机编程架构）_百度百科 🔗外部链接 Wikipedia’s external link ltr-icon Java 重写(Override)与重载(Overload) | 菜鸟教程 Java 中的枚举 (enum) - 简书 Java 枚举(enum) 详解7种常见的用法_请叫我大师兄-CSDN博客_枚举 SuiteLHY/DingDing: Instant Messaging System, Microservice Architecture, DDD (Domain-driven design); Spring, Spring MVC, Spring Data JPA, Hibernate, Spring Cloud, Spring Cloud Alibaba 枚举类 - 廖雪峰的官方网站 "},{"title":"实践手册","date":"2021-04-16T02:49:53.000Z","url":"/2021/04/16/%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/","tags":[["实践手册","/tags/PracticeManual/"]],"categories":[["手册","/categories/Handbook/"]],"content":"在本站中，通常会将&thinsp;[&thinsp;属于【手册】类型且以解决&thinsp;实践过程中遇到的问题&thinsp;为主干进行编纂编撰&thinsp;]&thinsp;的知识划分到【实践手册】的[标签]之中。 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"使用手册（Tutorial）","date":"2021-04-16T02:48:14.000Z","url":"/2021/04/16/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","tags":[["使用手册","/tags/Tutorial/"]],"categories":[["手册","/categories/Handbook/"]],"content":" A tutorial, in education, is a method of transferring knowledge and may be used as a part of a learning process. More interactive and specific than a book or a lecture, a tutorial seeks to teach by example and supply the information to complete a certain task. A tutorial can be taken in many forms, ranging from a set of instructions to complete a task to an interactive problem solving session (usually in academia). 👆←🗎[1] 在本站中，通常会将&thinsp;[&thinsp;属于【手册】类型且以功能为主干进行编纂编撰&thinsp;]&thinsp;的知识划分到【使用手册】的[标签]之中。 📖参看 主要参看📖 Tutorial - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Tutorial - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"理论手册（Theory Handbook）","date":"2021-04-16T00:39:46.000Z","url":"/2021/04/16/%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/","tags":[["理论手册","/tags/TheoryHandbook/"]],"categories":[["手册","/categories/Handbook/"]],"content":"在本站中，通常会将&thinsp;[&thinsp;属于【手册】类型且以理论数据为主干进行编纂编撰&thinsp;]&thinsp;的知识划分到【理论手册】的[标签]之中。 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"Java 理论手册","date":"2021-04-15T23:22:56.000Z","url":"/2021/04/15/Java-%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["理论手册","/tags/TheoryHandbook/"]],"categories":[["计算机科学","/categories/ComputerScience/"],["手册","/categories/ComputerScience/Handbook/"]],"content":" Java 是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。 👆←🗎[1] Java ← 定位 Java | 夜与花海 基础知识延伸知识拓展知识Java &amp; 设计模式 iluwatar/java-design-patterns: Design patterns implemented in Java Java ← 相关著作《Thinking in Java》 《Thinking in Java》（第4版） ← 整理手册 📖参看 主要参看📖 java · GitHub Topics 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Java - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon iluwatar/java-design-patterns: Design patterns implemented in Java java · GitHub Topics Snailclimb/JavaGuide: 「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！ "},{"title":"Java","date":"2021-04-15T02:30:04.000Z","url":"/2021/04/15/Java/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["编程语言","/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" Java&thinsp;是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级&thinsp;Web&thinsp;应用开发和移动应用开发。 任职于&thinsp;Sun&thinsp;微系统的詹姆斯·高斯林等人于1990年代初开发&thinsp;Java&thinsp;语言的雏形，最初被命名为&thinsp;Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，太阳计算机系统（Sun&thinsp;公司）放弃了该项计划。随着1990年代互联网的发展，Sun&thinsp;公司看见&thinsp;Oak&thinsp;在互联网上应用的前景，于是改造了&thinsp;Oak，于1995年5月以&thinsp;Java&thinsp;的名称正式发布。Java&thinsp;伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。 Java编程语言的风格十分接近&thinsp;C++&thinsp;语言。继承了&thinsp;C++&thinsp;语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了&thinsp;C++&thinsp;中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在&thinsp;Java SE 1.5&thinsp;版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun&thinsp;微系统对&thinsp;Java&thinsp;语言的解释是：“Java&thinsp;编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”。 Java&thinsp;不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了&thinsp;Java&thinsp;程序的运行效率。但在&thinsp;J2SE1.4.2&thinsp;发布后，Java&thinsp;的运行速度有了大幅提升。 与传统类型不同，Sun&thinsp;公司在推出&thinsp;Java&thinsp;时就将其作为开放的技术。全球的&thinsp;Java&thinsp;开发公司被要求所设计的&thinsp;Java&thinsp;软件必须相互兼容。“Java&thinsp;语言靠群体的力量而非公司的力量”是&thinsp;Sun&thinsp;公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的&thinsp;.NET&thinsp;平台以及模仿&thinsp;Java&thinsp;的&thinsp;C#&thinsp;语言。后来&thinsp;Sun&thinsp;公司被甲骨文公司并购，Java&thinsp;也随之成为甲骨文公司的产品。 现时，移动操作系统&thinsp;Android&thinsp;大部分的代码采用&thinsp;Java&thinsp;编程语言编程。 👆←🗎[1] 官方资源 Java SE 文档 — API 和文档 | Oracle 中国 百科 &thinsp;维基百科&ensp;👆 历史早期的Java 语言最开始只是Sun计算机（Sun MicroSystems）公司在1990年12月开始研究的一个内部项目。Sun计算机公司的一个叫做帕特里克·诺顿的工程师被公司自己开发的C++和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth计划”的项目的机会。 “Stealth计划”后来改名为“Green计划”，詹姆斯·高斯林和麦克·舍林丹（Mike Sheridan）也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，Sun公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C++语言，但是很多成员包括Sun的首席科学家比尔·乔伊，发现C++和可用的API在某些方面存在很大问题。 工作小组使用的是嵌入式系统，可以用的资源极其有限。很多成员发现C++太复杂以至很多开发者经常错误使用。他们发现C++缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。 根据可用的资金，乔伊决定开发一种集C语言和Mesa语言大成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议Sun公司的工程师应该在C++的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C++的功能，他自己称这种新语言为C++ ++，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的橡树命名。 就像很多开发新技术的秘密工程一样，工作小组没日没夜地工作到了1993年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库及其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。 同年11月，Green计划被转化成了“FirstPerson有限公司”，一个Sun公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度交互的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Request for proposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多的控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司被并回Sun公司。 Java和“Java” 由于商标搜索显示Oak已被一家显卡制造商注册。于是同年，Oak被改名为Java。当使用十六进制编辑器打开由Java源代码编译出的二进制文件（.class文件）的话，最前面的32位将显示为CA FE BA BE，即词组“CAFE BABE”（咖啡屋宝贝）。 Java和互联网 1994年6月，在同约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·施密特经历了一场历时三天的头脑风暴后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。 1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java 1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年3月23日SunWorld大会上进行的。升阳公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，Sun公司成立了Java业务集团，专门开发Java技术。 在流行几年之后，Java在浏览器中的地位被逐步侵蚀。它在简单交互性动画方面的用途已经完全被Adobe公司的Flash排挤，2005年Java倾向只被用于雅虎游戏那样的更为复杂的应用程序。Java同时遭受到来自微软的反对，他们决定在新版本的Internet Explorer和Windows中不再附带Java平台。 与此相反，在万维网的服务器端和手持设备上，Java变得更加流行。很多网站在后端使用JSP和其他的Java技术。 在桌面系统上，独立的Java程序还是相对少见这是因为Java平台的运行开销较大，而许多人的电脑上没有安装Java，由于网络带宽在以前较小，下载Java曾经是个耗时的事情。但是随着计算机计算能力、网络带宽在10年中获取了很大的进步，同时虚拟机和编译器的质量得到了提高，许多应用程序得到了广泛的使用，包括： 开源软件 NetBeans和Eclipse等软件开发工具 Android操作系统 JEdit Azureus BitTorrent客户端。 JNode操作系统 Apache软件基金会的Ant、Derby、Hadoop、Jakarta、POI和Tomcat JBoss和GlassFish应用服务器 商业软件 EIOffice（永中Office） Minecraft 纯Java 3D游戏合金战士Chrome IBM Websphere、ColdFusion和WebLogic IntelliJ IDEA 目前Java提供以下三个版本： Java Platform, Enterprise Edition（Java EE：Java平台企业版） Java Platform, Standard Edition（Java SE：Java平台标准版） Java Platform, Micro Edition（Java ME：Java平台微型版） Java Platform, Card Edition Java开放源代码项目 2006年SUN在JavaOne公布Java 开放源代码项目，并推出OpenJDK计划。Java虚拟机、Java编译器和Java类库以GNU通用公共许可证公开。 版本历史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年12月，SUN公司发布Java EE 6 2010年11月，由于Oracle公司对于Java社区的不友善，因此Apache扬言将退出JCP 2011年7月28日，Oracle公司发布Java SE 7 2014年3月18日，Oracle公司发表Java SE 8 2017年9月21日，Oracle公司发表Java SE 9 2018年3月21日，Oracle公司发表Java SE 10 2018年9月25日，Java SE 11发布 语言特性 Java之所以被开发，是要达到以下五个目的： 应当使用面向对象程序设计方法学 应当允许同一程序在不同的计算机平台执行 应当包括内建的对计算机网络的支持 应当被设计成安全地执行远端代码 应当易于使用，并借鉴以前那些面向对象语言（如C++）的长处。 Java技术主要分成几个部分：Java语言、Java运行环境、类库。一般情况下说Java时并不区分指的是哪个部分。 Java在1.5版本时，做了重大改变，Sun公司并1.5版本重命名为Java 5.0。 面向对象 Java的特点之一就是面向对象，是程序设计方法的一种。“面向对象程序设计语言”的核心之一就是开发者在设计软件的时候可以使用自定义的类型和关联操作。代码和数据的实际集合体叫做“对象”。一个对象可以想象成绑定了很多“行为（代码）”和“状态（数据）”的物体。对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。 跨平台性 跨平台性是Java主要的特性之一，跨平台使得用Java语言编写的程序可以在编译后不用经过任何更改，就能在任何硬件设备条件下运行。这个特性经常被称为“一次编译，到处运行”。 执行Java应用程序必须安装Java 运行时环境（Java Runtime Environment，JRE），JRE包括Java虚拟机（Java Virtual Machine，JVM），以及Java平台核心类和基础Java 平台库。通过JVM才能在电脑系统执行Java应用程序（Java Application），这与.Net Framework的情况一样，所以电脑上没有安装JVM，那么这些java程序将不能够执行。 实现跨平台性的方法是大多数编译器在进行Java语言程序的编码时候会生成一个用字节码写成的“半成品”，这个“半成品”会在Java虚拟机（解释层）的帮助下运行，虚拟机会把它转换成当前所处硬件平台的原始代码。之后，Java虚拟机会打开标准库，进行数据（图片、线程和网络）的访问工作。主要注意的是，尽管已经存在一个进行代码翻译的解释层，有些时候Java的字节码代码还是会被JIT编译器进行二次编译。 有些编译器，比如GCJ，可以自动生成原始代码而不需要解释层。但是这些编译器所生成的代码只能应用于特定平台。并且GCJ目前只支持部分的Java API。 甲骨文公司对于Java的许可是“全兼容的”，这也导致了微软和升阳关于微软的程序不支持RMI和JNI接口、并且增加特性为己所用的法律争端。升阳最终赢得了官司，获得了大约两千万美元的赔偿，法院强制要求微软执行升阳公司关于Java的许可要求。作为回应，微软不再在Windows系统中捆绑Java，最新的Windows版本，Windows Vista和Internet Explorer 7.0版本也不再提供对于Java应用程序和控件的支持。但是升阳公司和其他使用Java运行时系统的公司在Windows操作系统下对用户提供无偿的第三方插件和程序支持。 Java语言使用解释层最初是为了轻巧性。所以这些程序的运行效率比C语言和C++要低很多，用户也对此颇有微词。很多最近的调查显示Java的程序运行速度比几年前要高出许多，有些同样功能的程序的效率甚至超过了C++和C语言编写的程序。 Java语言在最开始应用的时候是没有解释层的，所有需要编译的代码都直接转换成机器的原始代码。这样做虽然使程序获得了最佳的性能，但是导致程序异常臃肿。从JIT技术开始，Java的程序都经过一次转换之后才变成机器码。很多老牌的第三方虚拟机都使用一种叫做“动态编译”的技术，也就是说虚拟机实时监测和分析程序的运行行为，同时选择性地对程序所需要的部分进行编译和优化。所有这些技术都改善了代码的运行速度，但是又不会让程序的体积变得失常。 程序的轻便性事实上是软件编写很难达到的一个目标，Java虽然成功地实现了“一次编译，到处运行”，但是由于平台和平台之间的差异，所编写的程序在转换代码的时候难免会出现微小的、不可察觉的错误和意外。有些程序员对此非常头疼，他们嘲笑Java的程序不是“一次编译，到处运行”，而是“一次编译，到处调试”。以Java AWT为例，早期Java AWT内提供的按钮、文字区等均是以计算机系统所默认的样式而显示。这令Java程序在有些没有提供图案的计算机系统产生错误（在Microsoft Windows设有窗口管理器，在一些Linux distribution则没有）。后来SUN公司针对Java AWT一些问题而推出Java Swing。 平台无关性让Java在服务器端软件领域非常成功。很多服务器端软件都使用Java或相关技术创建。 自动垃圾回收（Garbage Collection） C++语言被用户诟病的原因之一是大多数C++编译器不支持垃圾收集机制。通常使用C++编程的时候，程序员于程序中初始化对象时，会在主机存储器堆栈上分配一块存储器与地址，当不需要此对象时，进行析构或者删除的时候再释放分配的存储器地址。如果对象是在堆栈上分配的，而程序员又忘记进行删除，那么就会造成存储器泄漏（Memory Leak）。长此以往，程序运行的时候可能会生成很多不清除的垃圾，浪费了不必要的存储器空间。而且如果同一存储器地址被删除两次的话，程序会变得不稳定，甚至崩溃。因此有经验的C++程序员都会在删除之后将指针重置为NULL，然后在删除之前先判断指针是否为NULL。 C++中也可以使用“智能指针”（Smart Pointer）或者使用C++托管扩展编译器的方法来实现自动化存储器释放，智能指针可以在标准类库中找到，而C++托管扩展被微软的Visual C++ 7.0及以上版本所支持。智能指针的优点是不需引入缓慢的垃圾收集机制，而且可以不考虑线程安全的问题，但是缺点是如果不善使用智能指针的话，性能有可能不如垃圾收集机制，而且不断地分配和释放存储器可能造成存储器碎片，需要手动对堆进行压缩。除此之外，由于智能指针是一个基于模板的功能，所以没有经验的程序员在需要使用多态特性进行自动清理时也可能束手无策。 Java语言则不同，上述的情况被自动垃圾收集功能自动处理。对象的创建和放置都是在存储器堆栈上面进行的。当一个对象没有任何引用的时候，Java的自动垃圾收集机制就发挥作用，自动删除这个对象所占用的空间，释放存储器以避免存储器泄漏。 注意程序员不需要修改finalize方法，自动垃圾收集也会发生作用。但是存储器泄漏并不是就此避免了，当程序员疏忽大意地忘记解除一个对象不应该有的引用时，存储器泄漏仍然不可避免。 不同厂商、不同版本的JVM中的存储器垃圾回收机制并不完全一样，通常越新版本的存储器回收机制越快，IBM、BEA、SUN等等开发JVM的公司都曾宣称过自己制造出了世界上最快的JVM，JVM性能的世界纪录也在不断的被打破并提高。 IBM有一篇有关Java存储器回收机制比不激活垃圾收集机制的C++存储器处理快数倍的技术文章，而著名的Java技术书籍《Java编程思想》（Thinking in Java）也有一段论述Java存储器及性能达到甚至超过C++的章节。 基本语法 编写Java程序前应注意以下几点： 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如MyFirstJavaClass。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod。 源文件名：源文件名必须和文件内名字唯一且公开(由public关键词修饰)的类名相同。当保存文件的时候，你应该使用该类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java程序由public static void main(String[] args)方法开始执行。 Java关键字下面列出了Java关键字。这些关键字不能用于常量、变量、和任何标识符的名称。 类别 关键字 说明 访问控制 private 私有的 protected 受保护的 public 公共的 类、方法和变量修饰符 abstract 声明抽象 class 类 extends 扩充,继承 final 最终值,不可改变的 implements 实现（接口） interface 接口 native 本地，原生方法（非Java实现） new 新,创建 static 静态 strictfp 严格,精准 synchronized 线程,同步 transient 短暂 volatile 易失 程序控制语句 break 跳出循环 case 定义一个值以供switch选择 continue 继续 default 默认 do 运行 else 否则 for 循环 if 如果 instanceof 实例 return 返回 switch 根据值选择执行 while 循环 错误处理 assert 断言表达式是否为真 catch 捕捉异常 finally 有没有异常都执行 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 try 捕获异常 包相关 import 引入 package 包 基本类型 boolean 布尔型 byte 字节型 char 字符型 double 双精度浮点 float 单精度浮点 int 整型 long 长整型 short 短整型 null 空 变量引用 super 父类,超类 this 本类 void 无返回值 保留关键字 goto 是关键字，但不能使用 const 是关键字，但不能使用 注释 注释的作用：标识程序是干什么的，以及它是如何构建的。注释帮助程序员进行相互沟通以及理解程序。注释不是程序设计语言，所以编译器编译程序时忽略它们。 接口和类别 Java自带了创建接口的类别，可以这样使用： 这段代码的意思是任何实现（implement）Deleteable接口的类别都必须实现delete()方法。每个类别对这个方法的实现可以自行定制。由此概念可以引出很多种使用方法，下面是一个类别的例子： 在另外一个类别中，可以使用这样的代码： 因为队列中所有的对象都可以使用delete()方法。Deleteable队列中包含Fred对象的引用，而这个类别和其他Deleteable类别在使用deleteAll()方法时候不需要进行任何改变。 之所以这样做就是为了在接口的执行和其代码之间进行区别。举例来说，一个名叫Collection的接口可以包含任何对象所需要的引入、转换和存储数据的方法，其他的类都可以使用这个接口。但是这个接口可以是一个可重定义大小的队列、一个链表或者是其他功能的集合。 这种特性其实是一种折中的办法。Java的设计者们不想让Java有多重继承的特性，因为C++的多重继承显示了这种特性的困难。Java的接口功能可以提供同样的功能，但是又不会很复杂。 应用程序开发接口 在Java语言中，应用程序接口（API）化身成类，并且分组成为包。每个包中包含有相关的接口和类。对于不同的平台，Java提供了不同版本的包。API的设定由sun公司和其他公司通过JCP（Java社区程序）决定。任何公司和个人都可以参与这个工程，对API进行设计。2004年，IBM和BEA公司准备联合对官方的Java开源软件工程进行支持，但是2005年初，sun公司拒绝了这个支持。 Hello World 下面这个程序显示“Hello, world!”然后结束运行，注意java.lang包是自动加载的，所以不需要在程序之前加入import java.lang.*; 关于Java的批评 Java试图通过新的方式解决软件编写的复杂性。很多人认为Java语言做到了它承诺的一切。但是Java并不是一门完美的语言。 整体性问题 并不是所有的工程和环境需要企业等级的复杂性，比如一个简单的个人网站或者独自编程的程序师所写的程序。这些程序师会发现Java的复杂管理对于自己要做的程序来说过于强大了。一些人觉得Java在面向对象上面做的没有Ruby和Smalltalk纯粹。但是最新出现的用Java实现的语言Groovy解决了这些问题。 作为一种已经创建的新技术，Java显然综合了很多语言的特性，比如C++、C语言、Python等等。一些对于Java的评论认为Java的不变性在动摇。 语言问题 有些程序师不喜欢原始类型（primitive type）和类别（class）的分离，尤其是那些曾经使用过Smalltalk和Ruby的程序员。Java的代码相对于其他的代码来说过于冗长，这与它的轻便化声明相违背。此外Java一般也会默认式的自动植入过多的标准库代码,导致整体运行会出现缓慢 Java是一种单继承的语言。这也导致了程序师在试图使用多重继承时候的不便，而很多语言都可以使用这个特性。但是Java可以使用接口类，把多重继承可能导致的风险减少到最小。Java不支持运算符重载，这是为了防止运算符重载使得代码的功能变得不清晰。但是用Java实现的语言Groovy可以进行运算符重载。过去Java对于文本的操作和其他语言，比如Perl和PHP相比差的较多，但Java在1.4版本时候引入了正则表达式。 至Java 1.7为止，Java语言不支持闭包（closure）和混入（mixin）特性。Java 1.8加入lambda表达式（Lambda Expressions）。 类库问题 使用Swing平台编写的带有GUI（图形用户界面）的程序和其他原始程序非常不同。选用AWT工具包编写程序的程序师看到的都是原始接口，而且也无法获得先进的GUI编程支持，如果使用的话，就要提供每个平台上面所需的API，这将是一项庞大的工程。Swing则是完全用Java语言所写的程序，避免了接口元素重复的问题，只使用所有平台都支持的最基本的绘图机制。但是很多用户不知道如何在Java风格和Windows风格之间进行转换，结果造成了Java程序的接口在很多程序中非常特殊。苹果计算机已经提供了优化过的Java运行时程序，包含了Mac OS X的经典Aqua接口风格。 在IBM捐赠给Eclipse基金会的SWT界面框架中，用户会看到熟悉的本地风格界面。但这又引起了不同喜好的开发人员之间的争论。 性能问题 由于Java编译器和虚拟机的不同对Java代码的性能影响比语言本身的影响大的多，所以统一讨论Java的程序的性能经常是有误导性的。据IBM的资料，在同样的硬件上2001年时的IBM JDK版本的性能是1996年的JDK版本的十倍左右。而即使是在同一时期，不同公司的JDK和JRE的性能也不一样，比如SUN、IBM、BEA等公司都有自己开发的JDK和JRE。 Java语言的一些特性不可避免的有额外的性能代价，例如数组范围检查、运行时类型检查等等。Java程序的性能还会因为不同的动态复杂性和垃圾处理机制使用的多少而各有不同。如果JVM的实现比较优化的话，那么这些功能甚至可以增加存储器分配的性能。这和总是使用STL或者托管C++的程序的情况类似。 尽管如此，仍然有许多人认为Java的性能低。这部分归因于Sun公司最初的JVM实现使用未优化的解释机制来运行字节码。一些新版本的JVM使用Just-In-Time（JIT）编译器，在加载字节码的时候将其编译成针对运行环境的本地代码来实现一些本地编译器的优化特性。Just-In-Time机制和本地编译的性能比较仍旧是一个有争议的话题。JIT编译需要很多时间，对于运行时间不长或者代码很多的大型程序并不适宜。但是不算JIT编译阶段的话，程序的运行性能在很多JVM下可以和本地编译的程序一争短长，甚至在一些计算比较密集的数值计算领域也是这样。目前，Java已经使用更先进的HotSpot技术来代替JIT技术，Java的性能有了更进一步的提升。另外，在使用-server选项运行Java程序时，也可以对Java进行更深入的优化，比如在运行时将调用较多的方法内联（inline）到程序中来提高运行速度，这就是所谓的“动态优化”，而本地编译器是无法做到这一点的；这也是一些Java代码比对应用C/C++等语言编写的本地代码运行的更快的原因之一。微软的.NET平台也使用JIT编译器，所以也有类似问题。 Java的设计目的主要是安全性和可携性，所以对于一些特性，比如对硬件架构和存储器地址访问的直接访问都被去除了。如果需要间接调用这些底层功能的话，就需要使用JNI（Java本地接口）来调用本地代码，而间接访问意味着频繁调用这些特性时性能损失会很大，微软的.NET平台也有这样的问题。所以到目前为止，性能敏感的代码，例如驱动程序和3D电子游戏，还是大多使用本地编译，甚至直接以不直接支持面向对象的C语言或机器代码编写。但最近已经有了许多用纯Java编写的3D游戏，其效果与用C语言编写的不相上下，例如“合金战士”（英文名：Chrome）。这主要是因为新版的Java 3D技术已经能像C++一样调用硬件加速，也就是使用显卡来加速，无论是C++还是Java语言写的3D游戏都是使用显卡及GPU来处理，从而使得CPU可以专注于其他方面的工作。 用途 桌面GUI应用程序： Java通过抽象窗口工具包（AWT），Swing和JavaFX等多种方式提供GUI开发。虽然AWT包含许多预先构建的组件，如菜单，按钮，列表以及众多第三方组件，但Swing（一个GUI小部件工具包）还提供某些高级组件，如树，表格，滚动窗格，选项卡式面板和列表。JavaFX是一组图形和媒体包，提供了Swing互操作性，3D图形功能和自包含的部署模型，可以快速编写Java小应用程序和应用程序的脚本。[21] 移动应用程序： Java Platform，Micro Edition（Java ME或J2ME）是一个跨平台框架，用于构建可在所有Java支持的设备（包括功能手机和智能手机）上运行的应用程序。此外，最受欢迎的移动操作系统之一的Android应用程序通常使用Android软件开发工具包（SDK）或其他环境在Java中编写脚本。 嵌入式系统： 从微型芯片到专用计算机的嵌入式系统是执行专门任务的大型机电系统的组件。诸如SIM卡，蓝光光盘播放器，公用事业仪表和电视机等多种设备都使用嵌入式Java技术。据甲骨文公司称，100％的蓝光光盘播放器和1.25亿台电视设备都采用Java技术。 Web应用程序： Java通过Servlets，Struts或JSP提供对Web应用程序的支持。编程语言提供的简单编程和更高的安全性使得大量政府应用程序可用于基于Java的健康，社会安全，教育和保险。Java也可以使用Broadleaf等开源电子商务平台开发电子商务Web应用程序。 Web服务器和应用程序服务器： 今天的Java生态系统包含多个Java Web服务器和应用程序服务器。虽然Apache Tomcat，Simple，Jo !, Rimfaxe Web服务器（RWS）和Project Jigsaw占据了Web服务器空间，但WebLogic，WebSphere和Jboss EAP在商业应用服务器领域占据重要地位[22]。 企业应用程序： Java企业版（Java EE）是一种流行的平台，为脚本和运行企业软件（包括网络应用程序和Web服务）提供API和运行时环境。甲骨文宣称Java在97％的企业计算机上运行。Java中更高的性能保证和更快的计算能力导致像Murex这样的高频交易系统被编入脚本中。它也是各种银行应用程序的中枢，它们将Java从前端用户端运行到后端服务器端。 科学应用：Java是许多软件开发人员用于编写涉及科学计算和数学运算的应用程序的选择。这些程序通常被认为是快速和安全的，具有更高的便携性和低维护性。像MATLAB这样的应用程序使用Java来交互用户界面和作为核心系统的一部分。 手册 站内手册 Java 理论手册 | 夜与花海 《Thinking in Java》（第4版） ← 整理手册 相关著作 《Thinking in Java》 📖参看 主要参看📖 Java (programming language) - Wikipedia Java - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Java - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon Java SE 文档 — API 和文档 | Oracle 中国 "},{"title":"Git理论手册","date":"2021-04-15T02:21:43.000Z","url":"/2021/04/15/Git%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/","tags":[["Git","/tags/Git/"],["手册","/tags/Handbook/"],["计算机科学","/tags/ComputerScience/"]],"categories":[["计算机科学","/categories/ComputerScience/"],["手册","/categories/ComputerScience/Handbook/"]],"content":" 👆←🗎[1] 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"Git使用手册","date":"2021-04-15T01:48:17.000Z","url":"/2021/04/15/Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","tags":[["Git","/tags/Git/"],["手册","/tags/Handbook/"],["信息技术","/tags/InformationTechnology/"]],"categories":[["信息技术","/categories/InformationTechnology/"],["手册","/categories/InformationTechnology/Handbook/"]],"content":" 👆←🗎[1] 📖参看 主要参看📖 Git远程操作详解 - 阮一峰的网络日志 常用 Git 命令清单 - 阮一峰的网络日志 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） 使用GitHub - 廖雪峰的官方网站 ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"Git","date":"2021-04-13T22:55:44.000Z","url":"/2021/04/13/Git/","tags":[["Git","/tags/Git/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. 👆←🗎[1] git（/ɡɪt/， &thinsp;音频[帮助&thinsp;·&thinsp;信息]，吉特）是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以&thinsp;GPL&thinsp;发布。最初目的是为更好地管理&thinsp;Linux&thinsp;内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似&thinsp;Norton Commander&thinsp;界面的文件管理器）不同。 git&thinsp;最初的开发动力来自于&thinsp;BitKeeper&thinsp;和&thinsp;Monotone。git&thinsp;最初只是作为一个可以被其他前端（比如&thinsp;Cogito&thinsp;或&thinsp;Stgit）包装的后端而开发的，但后来&thinsp;git&thinsp;内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用&thinsp;git&thinsp;进行版本控制，其中包括&thinsp;Linux&thinsp;内核、X.Org&thinsp;服务器和&thinsp;OLPC&thinsp;内核等项目的开发流程。 👆←🗎[2] Git是一个免费的开源 分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。 官方资源 &ensp; &ensp; 官方文档 百科 &thinsp;维基百科&ensp;👆 历史 自2002年开始，林纳斯·托瓦兹决定使用BitKeeper作为Linux内核主要的版本控制系统用以维护代码。因为BitKeeper为专有软件，这个决定在社区中长期遭受质疑。在Linux社区中，特别是理查德·斯托曼与自由软件基金会的成员，主张应该使用开放源代码的软件来作为Linux内核的版本控制系统。林纳斯·托瓦兹曾考虑过采用现成软件作为版本控制系统（例如Monotone），但这些软件都存在一些问题，特别是性能不佳。现成的方案，如CVS的架构，受到林纳斯·托瓦兹的批评。 2005年，安德鲁·垂鸠写了一个简单程序，可以连接BitKeeper的存储库，BitKeeper著作权拥有者拉里·麦沃伊认为安德鲁·垂鸠对BitKeeper内部使用的协议进行逆向工程，决定收回无偿使用BitKeeper的许可。Linux内核开发团队与BitMover公司进行磋商，但无法解决他们之间的歧见。林纳斯·托瓦兹决定自行开发版本控制系统替代BitKeeper，以十天的时间编写出git第一个版本。 👆←🗎[3] 主要功能 git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。 👆←🗎[4] 更多👆 实际上内核开发团队决定开始开发和使用git来作为内核开发的版本控制系统的时候，世界上开源社区的反对声音不少，最大的理由是git太艰涩难懂，从git的内部工作机制来说，的确是这样。但是随着开发的深入，git的正常使用都由一些友善的命令来执行，使git变得非常好用。现在，越来越多的著名项目采用git来管理项目开发，例如：wine、U-boot等。 作为开源自由原教旨主义项目，git没有对版本库的浏览和修改做任何的权限限制，通过其他工具也可以达到有限的权限控制，比如：gitosis、CodeBeamer MR。原本git的使用范围只适用于Linux/Unix平台，但在Windows平台下的使用也日渐成熟，这主要归功于Cygwin、msysgit环境，以及TortoiseGit这样易用的GUI工具。git的源代码中也已经加入了对Cygwin与MinGW编译环境的支持且逐渐完善，为Windows用户带来福音。 实现原理 git和其他版本控制系统（如CVS）有不小的差别，git本身关心文件的整体性是否有改变，但多数的版本控制系统如CVS或Subversion系统则在乎文件内容的差异。git拒绝保持每个文件的版本修订关系。因此查看一个文件的历史需要遍历各个history快照；git隐式处理文件更名，即同名文件默认为其前身，如果没有同名文件则在前一个版本中搜索具有类似内容的文件。 git更像一个文件系统，直接在本机上获取资料，不必连线到主机端获取资料。 每个开发者都可有全部开发历史的本地副本，changes从这种本地repository复制给其他开发者。这些changes作为新增的开发分支被导入，可以与本地开发分支合并。 分支是非常轻量级的，一个分支仅是对一个commit的引用。 git是用C语言开发的，以追求最高的性能。git自动完成垃圾回收，也可以用命令git gc –prune直接调用。 git存储每个新创建的object作为一个单独文件。为了压缩存储空间占用， packs操作把很多文件（启发式类似名字的文件往往具有类似内容）使用差分压缩入一个文件中（packfile），并创建一个对应的索引文件，指明object在packfile中的偏移值。新创建的对象仍然作为单独文件存在。repacks操作非常费时间，git会在空闲时间自动做此操作。也可用命令git gc来直接启动repack。packfile与索引文件都用SHA-1作为校验和并作为文件名。git fsck命令做校验和的完整性验证。 Git服务器典型的TCP监听端口为9418。 👆←🗎[5] 库目录 hooks：存储钩子的文件夹 refs：存储指向各个分支的指针（SHA-1标识）文件 objects：存放git对象 config：存放各种设置文档 HEAD：指向当前所在分支的指针文件路径，一般指向refs下的某文件 数据结构 Git有两种数据结构：可变的索引（index或stage或cache)用于缓冲工作目录信息与下一次提交的版本信息；不变的、仅追加的对象数据库。 对象数据库包含4类对象： blob (二进制大对象)是使用zlib压缩算法对一个文件的内容压缩后的结果。Blobs没有保存文件名、时间戳或其他元数据。Git将其存储在位于隐藏的.git/objects文件夹中。文件的名称为使用SHA-1哈希函数对原文件内容生成的哈希值。这些对象文件称为Blob，每次将新文件添加到存储库时会创建Blob对象。 tree对象对应于文件目录。包含文件名列表以及文件的类型比特（包含许可权）、到blob（对应于文件）或tree对象的引用。tree对象是源树(source tree)的快照。用默克尔树实现。 commit对象链接tree对象在一起而成为history，包含顶层源目录的tree对象名字、一个时间戳、log信息、0个或多个父commit对象的名字。用于保存特定版本的树型文件夹结构以及提交作者，电子邮件地址，日期和描述性提交消息。 tag对象是一个容器，包含了到另一个对象的引用，也可以增加关于另外对象的元数据。通常它保存需要追溯的特定版本数据的一个commit对象的数字签名。 以上4类的对象用其内容的SHA-1 hash值标识：hash值的前两个字符作为存放的目录名字，其余hash字符作为这个对象的文件名。 👆←🗎[6] 更多👆 Git数据库中不变引用的对象将会被垃圾回收清除。Git命令可以创建、移动、删除引用。”git show-ref”列出所有引用。某些引用类型： heads: 引用一个本地对象，是commit的指针。每个head可以指任意一个这样的指针。可以包含任意数量的heads。而”HEAD”（全部大写），仅仅指的是当前有效的head。默认情况下，在每个仓库下都有一个head，叫做master。remotes: 引用远程repository中的一个对象stash: 引用一个还没有committed的一个对象meta: 例如一个bare repository中的一个配置, 用户权限; refs/meta/config名字空间等tags:某些操作（例如，将提交推送到远程存储库，存储太多对象或手动运行Git的垃圾收集命令）可能会导致Git将对象重新打包为打包文件，在打包过程中，采用反向差异并进行压缩以消除多余的内容并减小尺寸。该过程将生成包含对象内容的.pack文件，每个文件都有一个对应的.idx索引文件，其中包含对打包对象及其在打包文件中位置的引用。当将分支推送到远程存储库或从远程存储库拉出分支时，这些打包文件将通过网络传输。提取或获取分支时，将打包文件解压缩以在对象存储库中创建松散对象。 移植性 在Windows平台上有msysgit与TortoiseGit可使用。TortoiseGit还提供有GUI。 git也提供windows版本下载。 Visual Studio 自 2013 版本开始内置 Git 功能。 👆←🗎[7] GIT GUI 客户端 GitHub Desktop：可用于第三方Git仓库网站 Git for Windows TortoiseGit SourceTree GitEye 👆←🗎[8] 📖参看 主要参看📖 分布式版本控制 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Git&thinsp;官方网站 ^&ensp;git - 维基百科，自由的百科全书 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#歷史 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#主要功能 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#实现原理 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#数据結構 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#移植性 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#GIT_GUI客户端 🔗外部链接 Wikipedia’s external link ltr-icon En-us-git.ogg - Wikipedia File:En-us-git.ogg - Wikipedia git/git: Git Source Code Mirror - This is a publish-only repository and all pull requests are ignored. Please follow Documentation/SubmittingPatches procedure for any of your improvements. Help:媒体帮助 - 维基百科，自由的百科全书 帮助:英语国际音标 - 维基百科，自由的百科全书 "},{"title":"法律","date":"2021-04-13T15:38:28.000Z","url":"/2021/04/13/%E6%B3%95%E5%BE%8B/","tags":[["法律","/tags/Law/"]],"categories":[["undefined",""]],"content":"心无良知，行不道德，谈何法律！ 法律（英语：Law） 是一种由规则组成的体系，经由社会组织来施予强制力量，规范个人行为。法律是一系列的规则，通常需要经由一套制度来落实。但在不同的地方，法律体系会以不同的方式来阐述人们的法律权利与义务。其中一种区分的方式便是分为欧陆法系和英美法系两种。有些国家则会以他们的宗教法条为其法律的基础。 学者们从许多不同的角度来研究法律，包括从法制史和哲学，或从如经济学与社会学等社会科学的方面来探讨。法律的研究来自于对何为平等、公正和正义等问题的讯问，这并不都总是简单的。 在一个典型的三权分立国家中，创造和解释法律的核心机构为政府的三大部门：公正不倚的司法、民主的立法和负责的行政。而官僚、军事和警力则是执行法律，并且让法律为人民服务时相当重要的部分。除此之外，若要支持整个法律系统的运作，同时带动法律的进步，则独立自主的法律专业人员和充满生气的公民社会也是不可或缺的一部分。 古希腊哲学家亚里斯多德于公元前350年写道：“法治比任何一个人的统治来得更好。” 👆←🗎[1] 宪法和行政法管理著国家的事务。宪法关注于行政、立法与司法间的关系，以及人权或国家内个人的公民自由。大多数的国家，如美国和法国等国家都只有一部成文宪法，并辅以权利法案。而中华民国宪法则于宪法成文法典条文本文规制人民之基本权。但少部分如英国之类的国家并没有这样的条文；在这些国家里，宪法是由法条、判例和惯例所构成的。在一名为恩蒂克诉卡林顿案一案中，描述了一个普通法里的宪法原则。恩蒂克的房子被卡林顿警长搜索并拿走了一个东西。当恩蒂克在法庭上控诉时，卡林顿警长回驳说他有政府首长的授权。但是，并没有成文的法令条文或法院授权。主审法官查理斯·普拉特说： “ 人们进入社会的重大目的是为了保全他们的财产。这个权利在任何时刻都是神圣且不可侵犯的，亦不会因公法上所谓的公众利益而被夺取或缩减…若不能找到或形成任何的原因，书本的沉默将会是对被告的职权，而原告必然会得到一个决断。 ” 由约翰·洛克提出的一个基本的宪法原则为：个人可以做任何事情，除非法律禁止；且政府不能做任何事情，除非法律许可。行政法是人民监督政权的主要方法。人民可以对地方议会、公共服务或政府部门的作为或决定提出司法审查，以确定它们是否有遵行法律。之后，第一个专门的行政法院——法国行政院议会成立于1799年，正值拿破仑夺权之时。 👆←🗎[2] 在本站中，【法律】[标签]往往和【道德】[标签]一起使用；通常情况下，主要涉及[&thinsp;法律&thinsp;]&thinsp;的知识将会被划分到【法律】的[标签]之中。 ※参考和引用 ^&ensp;法律 - 维基百科，自由的百科全书 ^&ensp;[&ensp;法律 - 维基百科，自由的百科全书&ensp;]#憲法與行政法 Law - Wikipedia 更多👆 中华人民共和国宪法 - 维基百科，自由的百科全书 中华人民共和国宪法修正案 (2018年) - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Conscience - Wikipedia Morality - Wikipedia 道德 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 良知 - 维基百科，自由的百科全书 "},{"title":"良心","date":"2021-04-13T14:47:15.000Z","url":"/2021/04/13/%E8%89%AF%E5%BF%83/","tags":[["良心","/tags/Conscience/"]],"categories":[["undefined",""]],"content":" Conscience is a cognitive process that elicits emotion and rational associations based on an individual’s moral philosophy or value system. Conscience stands in contrast to elicited emotion or thought due to associations based on immediate sensory perceptions and reflexive responses, as in sympathetic central nervous system responses. In common terms, conscience is often described as leading to feelings of remorse when a person commits an act that conflicts with their moral values. An individual’s moral values and their dissonance with familial, social, cultural and historical interpretations of moral philosophy are considered in the examination of cultural relativity in both the practice and study of psychology. The extent to which conscience informs moral judgment before an action and whether such moral judgments are or should be based on reason has occasioned debate through much of modern history between theories of modern[clarification needed] in juxtaposition to the theories of romanticism and other reactionary movements after the end of the Middle Ages. 👆←🗎[1] 在本站中，【良心】作为一个重要的[标签]，往往和【道德】[标签]一起使用，且在一定程度上会影响对应文章的[分类]；只要涉及[&thinsp;良心&thinsp;]&thinsp;的知识都会被划分到【良心】的[标签]之中。 ※参考和引用 ^&ensp;Conscience - Wikipedia 良知 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Ethics - Wikipedia Morality - Wikipedia 道德 - 维基百科，自由的百科全书 伦理学 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 "},{"title":"伦理","date":"2021-04-13T02:13:16.000Z","url":"/2021/04/13/%E4%BC%A6%E7%90%86/","tags":[["伦理","/tags/Ethics/"]],"categories":[["undefined",""]],"content":" 伦理学（英语：Ethics 或 Moral Philosophy）也称为道德哲学或道德学，是一门哲学学科，主要探讨道德价值；在此，“道德”被定义为一群人或一种文化所认可的所有行为准则。伦理学试图从理论层面建构一种指导行为的法则体系，并且对其进行严格的评判。 伦理学涉及捍卫并鼓励对的行为，并劝阻错的行为。伦理学领域与美学又一起涉及了价值问题，因此也构成了另一个称为价值论的哲学分支。 伦理学旨在定义诸如：善与恶、对与错、美德与恶习、正义与犯罪等概念来解决道德问题，也探讨什么是聪明或愚蠢。作为一个知识探究领域，道德哲学也与道德心理学（Moral psychology）、描述伦理学和价值观有关。 👆←🗎[1] 在本站中，【伦理】作为一个重要的[标签]，往往和【道德】[标签]一起使用，且在一定程度上会影响对应文章的[分类]；只要涉及[&thinsp;伦理&thinsp;]&thinsp;的知识都会被划分到【伦理】的[标签]之中。 ※参考和引用 ^&ensp;伦理学 - 维基百科，自由的百科全书 Ethics - Wikipedia 伦理学 - MBA智库百科 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Conscience - Wikipedia Morality - Wikipedia 道德 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 良知 - 维基百科，自由的百科全书 "},{"title":"道德","date":"2021-04-13T02:11:58.000Z","url":"/2021/04/13/%E9%81%93%E5%BE%B7/","tags":[["道德","/tags/Moral/"]],"categories":[["undefined",""]],"content":" 道德（英语：moral，源自拉丁语:moralitas, 文学上”举止，品质，适当的行为”）是依据一定社会或阶级（生活形态）的价值观、社会舆论、传统习俗和人的内心信念的力量（生产能力）来调整对他人和自己之间的行为进行善恶、荣辱、正当或不正当等的相互关系（生产关系）的评价和断定的行为规范标准。有着通过确立一定的善恶标准和行为准则，来约束人们的相互关系和个人行为，调节社会关系，并与法律一起对社会生活的正常秩序起保障作用。道德贯串于社会生活的各个方面，如社会公德、婚姻家庭道德、职业道德等。 在英语中，Moral是指那些杰出的人之间的意图、决定和行动的区分，即是正确的还是不正确的及其相关的观念准则。道德可以是源自于特定哲学、宗教或文化的行为准则中衍生出来的一系列标准或原则，也可以源于一个人所相信的普遍价值。道德是一种“非正式公共机制”，非正式即指无法律或权威能判定其正确与否，而公共机制指所有场合都能套用的准则。 一些研究认为，对道德情操的注重，存在于所有的人类社会当中，道德情操是普世文化通则的一部分；而一些研究更认为，像是诚实、助人、宽容、忠诚、责任、社会公正、平等、家庭与国家安全、社会秩序的稳定、报恩等等和道德相关的行为，是普世价值的一部分，也就是说，这些行为可能是所有社会普遍认可的德行，提倡此种原则的伦理学立场称为道德普遍主义。不过道德相对主义的哲学则与道德普遍原则对立，道德相对主义认为不存在普遍的道德原则。 👆←🗎[1] 简而言之，道德属于社会属性，主要是指&thinsp;在社会中的人类个体&thinsp;对[&thinsp;人自身&thinsp;以及&thinsp;人与人之间的关系&thinsp;]的&thinsp;价值评判&thinsp;和&thinsp;看法。道德普遍存在，且作为重要组成部分于[社会中的人与人的交流之中&thinsp;形成并完善的&thinsp;价值标准和行为规范]；具体来说可以是：善恶、荣辱，美丑，文化，法律&thinsp;等等。 （广义上的）道德是社会形成的基础之一，是社会形成的&thinsp;必要不充分条件。 在本站中，【道德】作为一个重要的[标签]，在一定程度上会影响对应文章的[分类]；只要涉及[&thinsp;道德&thinsp;]&thinsp;的知识都会被划分到【道德】的[标签]之中。 ※参考和引用 ^&ensp;道德 - 维基百科，自由的百科全书 Morality - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Conscience - Wikipedia Morality - Wikipedia 伦理学 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 良知 - 维基百科，自由的百科全书 "},{"title":"其他🗒","date":"2021-04-12T23:20:43.000Z","url":"/2021/04/12/%E5%85%B6%E4%BB%96-%E6%9A%82%E6%9C%AA%E5%88%86%E7%B1%BB/","categories":[["其他🗒","/categories/Other/"]],"content":"在本站中，[&thinsp;最终难以分类&thinsp;或者&thinsp;所属类型与本站的定位相差很大&thinsp;]&thinsp;的信息，将会被划归到【其他】/【其他🗒】/【其他(暂未分类)】的[分类]之中。分类中的垃圾箱 需要注意的是，类型【其他🗒】与所有其他的类型互斥；对于【其他🗒】类型之下的文章，其标签的定义&thinsp;在一定程度上&thinsp;会受到影响。 ※参考和引用 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗒 - 螺旋笔记本 表情符号: U+1F5D2 - Unicode 字符百科 "},{"title":"手册","date":"2021-04-12T22:55:38.000Z","url":"/2021/04/12/%E6%89%8B%E5%86%8C/","tags":[["手册","/tags/Handbook/"]],"categories":[["手册","/categories/Handbook/"]],"content":" A handbook is a type of reference work, or other collection of instructions, that is intended to provide ready reference. The term originally applied to a small or portable book containing information useful for its owner, but the Oxford English Dictionary defines the current sense as “any book…giving information such as facts on a particular subject, guidance in some art or occupation, instructions for operating a machine, or information for tourists.” A handbook is sometimes referred to as a vade mecum (Latin, “go with me”) or pocket reference. It may also be referred to as an enchiridion. Handbooks may deal with any topic, and are generally compendiums of information in a particular field or about a particular technique. They are designed to be easily consulted and provide quick answers in a certain area. For example, the MLA Handbook for Writers of Research Papers is a reference for how to cite works in MLA style, among other things. Examples of engineering handbooks include Perry’s Chemical Engineers’ Handbook, Marks Standard Handbook for Mechanical Engineers, and the CRC Handbook of Chemistry and Physics. 👆←🗎[1] 手册是&thinsp;一种参考书，或者&thinsp;特定信息的集合。手册可以用于处理任何问题，通常是&thinsp;在特定领域或特定技术中&thinsp;作为&thinsp;信息纲要。手册的设计特点是&thinsp;易于查询，能够&thinsp;在特定领域&thinsp;提供快速准确的有效信息。 在本站中，【手册】作为&thinsp;次级分类；通常会将&thinsp;[&thinsp;对&thinsp;特定领域的重要信息&thinsp;进行&thinsp;整理编排&thinsp;并&thinsp;提供快速索引&thinsp;]&thinsp;的知识划分到【手册】的[分类或标签]之中。 ※参考和引用 ^&ensp;Handbook - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗎 - 文献: U+1F5CE - Unicode 字符百科 "},{"title":"站点记录","date":"2021-04-12T22:25:45.000Z","url":"/2021/04/12/%E7%AB%99%E7%82%B9%E8%AE%B0%E5%BD%95/","tags":[["站点记录","/tags/SiteRecord/"]],"categories":[["站点记录","/categories/SiteRecord/"]],"content":"在本站中，会将&thinsp;[&thinsp;关于本站点的各种&thinsp;记录信息&thinsp;]&thinsp;划分到【站点记录】的[分类和标签]之中。 📖参看 主要参看📖 Java (programming language) - Wikipedia Java - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;[Java - 维基百科，自由的百科全书][Wikipedia_zh__Java] 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"生命","date":"2021-04-12T16:47:37.000Z","url":"/2021/04/12/%E7%94%9F%E5%91%BD/","tags":[["生命","/tags/Life/"]],"categories":[["生命","/categories/Life/"]],"content":" 生命是一种特征，物质存在的一种活跃形式。目前对于生命的定义在学术界还无共识，较流行的定义是一类维持体内平衡、具有生命周期和稳定的物质和能量代谢现象、能对刺激做反应、能进行自我复制或和繁殖、进化的半开放物质系统。由细胞组成，能够成长，适应环境。其他定义有时包括非细胞生命形式，如病毒和类病毒。 生命是生物学的基本概念，而生物学是研究生命的科学。生命具有生物进程(如信号传递和自我维持过程)的物理实体与那些没有生物进程的实体区分开来。如果生物过程的功能已经停止(死亡)，或者它们从来没有这样的功能则会被归类为无生命。 生命包含所有“生物的特性”，生命个体一定会经历出生、成长、衰老和死亡。生命种群则在一代代个体的更替中经过自然选择发生进化以适应环境。生物学则是以研究生命为中心的科学。 生命的最小单位是生物，生物是由一个或多个细胞组成，能够新陈代谢，维持恒定性，可以成长，回应刺激，可以繁殖甚至演化，以适应外界环境，继续繁殖并产生后代。生命以各种形式存在，如植物、动物、真菌、原生生物、古菌和细菌。在地球的生物圈内可以找到许多不同的生物，在这些生物中都有共同的特征，都是由以碳和水为基础的细胞构成，有其组织以及可以遗传的基因资讯。 👆←🗎[1] 在本站中，通常会将&thinsp;[&thinsp;主要对&thinsp;生命&thinsp;的记录、思考和表达等方面 &thinsp;]&thinsp;的知识划分到【生命】的[分类和标签]之中，其中包括且不限于&thinsp;人与自然、人与人（在生命层面的思考和表达）、动物以及植物。 ※参考和引用 ^&ensp;生命 - 维基百科，自由的百科全书 Life - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗎 - 文献: U+1F5CE - Unicode 字符百科 "},{"title":"日常记录","date":"2021-04-12T15:58:16.000Z","url":"/2021/04/12/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","tags":[["日常记录","/tags/DailyRecord/"]],"categories":[["日常记录","/categories/DailyRecord/"]],"content":" 日记是以日期为排列顺序的笔记。 一开始的日记是人们用日记来记录天气、事件一直到个人心理感受以及思想深处。 日记可以是记录将要做的事情的，也能记录已经发生的事情和心情。 👆←🗎[1] 本站的[分类或标签]所定义的【日常记录】包括且不仅限于&thinsp;日记。 【日常记录】所对应的分类，作为本站的&thinsp;次级&thinsp;分类甚至可以归类于【其他(暂未分类)】。 在本站中，通常会将&thinsp;[&thinsp;没有明确主题，且以&thinsp;日常事件&thinsp;为&thinsp;内容或讨论对象&thinsp;]&thinsp;的知识划分到【日常记录】的[分类和标签]之中。 ※参考和引用 ^&ensp;日记 - 维基百科，自由的百科全书 Diary - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 "},{"title":"社会","date":"2021-04-12T15:12:28.000Z","url":"/2021/04/12/%E7%A4%BE%E4%BC%9A/","tags":[["社会","/tags/Society/"]],"categories":[["社会","/categories/Society/"]],"content":" 社会一词并没有太正式明确定义，一般是指由自我繁殖的个体构建而成的群体，占据一定的空间，具有其独特的文化和风俗习惯。由于社会通常被认为是人类组成的，所以社会和人类社会一般具有相同的含义，但在科学研究或科幻小说里面，有时亦可出现“蚂蚁社会”、“外星社会”等词语。 狭义的社会，也叫“社群”，可以只指群体人类活动和聚居的范围，例如是：乡、村、镇、城市、聚居点等等；广义的社会则可以指一个国家、一个大范围地区或一个文化圈，例如是中国社会、英国社会、东亚社会、东南亚或西方世界，均可作为社会的广义解释，也可以引申为他们的文化习俗。 以人类社会为研究对象的学科叫做社会学。 👆←🗎[1] 社会&thinsp;是共同生活的人们通过各种各样&thinsp;社会关系&thinsp;联合起来的集合。其中形成社会的最主要的社会关系包括家庭关系、共同文化以及传统习俗。微观上，社会强调同伴的意味，并且延伸到为了&thinsp;共同利益&thinsp;而形成联盟。宏观上，社会是由长期合作的社会成员，通过发展组织关系形成团体，进而形成&thinsp;机构、国家&thinsp;等&thinsp;组织形式。 👆←🗎[2] 在本站中，通常会将&thinsp;[&thinsp;主要涉及对&thinsp;社会&thinsp;的记录、思考和评价等方面&thinsp;]&thinsp;的知识划分到【社会】的[分类和标签]之中。 ※参考和引用 ^&ensp;社会 - 维基百科，自由的百科全书 ^&ensp;社会 - MBA智库百科 Society - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗎 - 文献: U+1F5CE - Unicode 字符百科 "},{"title":"知识","date":"2021-04-11T22:20:36.000Z","url":"/2021/04/11/%E7%9F%A5%E8%AF%86/","tags":[["知识","/tags/%E7%9F%A5%E8%AF%86/"]],"categories":[["知识","/categories/Knowledge/"]],"content":" 知识是对某个主题确信的认识，并且这些认识拥有潜在的能力为特定目的而使用。亦指透过经验或联想，而能够熟悉进而了解某件事情；这种事实或状态就称为知识，其包括认识或了解某种科学、艺术或技巧。此外，亦指透过研究、调查、观察或经验而获得的一整套知识或一系列资讯。 认知事物的能力是哲学中充满争议的中心议题之一，并且拥有它自己的分支—知识论。从更加实用的层次来看，知识通常被某些人的群体所共享，在这种情况下，知识可以通过不同的方式来操作和管理。 简而言之，目前为止学术上对[ 知识 ]这个概念还没有具体、明确且统一的定义（就很迷…）。 个人认为：（狭义[1]上）知识是人类通过[ 自身认识世界的方式 ][在思想上]所[产生并认可]的经验[2]（记忆[3]和想法[4]）。 在本站中，通常会将&thinsp;[&thinsp;主要涉及[对&thinsp;知识&thinsp;←&thinsp;（抽象）概念&thinsp;的思考]或[对&thinsp;被归类的知识&thinsp;的管理]等方面&thinsp;]&thinsp;的知识划分到【知识】的[分类和标签]之中。 ※参考和引用 ^&ensp;定义 - 维基百科，自由的百科全书 ^&ensp;经验 - 维基百科，自由的百科全书 ^&ensp;记忆 - 维基百科，自由的百科全书 ^&ensp;想法 - 维基百科，自由的百科全书 Knowledge - Wikipedia 知识 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） 思想 - 维基百科，自由的百科全书 "},{"title":"博客","date":"2021-04-11T02:44:21.000Z","url":"/2021/04/11/%E5%8D%9A%E5%AE%A2/","tags":[["博客","/tags/Blog/"]],"categories":[["博客","/categories/Blog/"]],"content":" 博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息[1]。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 许多博客作者专注评论特定的课题或新闻，其他则作为个人日记。一个典型的博客结合了文字、图像、其他博客或网站的超链接、及其它与主题相关的媒体。能够让读者以互动的方式留下意见，是许多博客的重要要素。大部分的博客内容以文字为主，也有一些博客专注艺术、摄影、视频、音乐、播客等各种主题。 博客是社交媒体网络的一部分。 本站就属于[ 博客 ]的范畴，具体来说是一个以分享信息为主的博客。 在本站中，通常会将&thinsp;[&thinsp;主要涉及博客本身的设计、管理、评价等方面&thinsp;]&thinsp;的知识划分到【博客】的[分类和标签]之中。 📖参看 主要参看📖 Java (programming language) - Wikipedia Java - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 Blog - Wikipedia 博客 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"欢迎来到【夜与花海】！","date":"2021-04-10T22:35:31.000Z","url":"/2021/04/10/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E3%80%90%E5%A4%9C%E4%B8%8E%E8%8A%B1%E6%B5%B7%E3%80%91%EF%BC%81/","tags":[["HelloWorld🐣","/tags/HelloWorld/"],["博客","/tags/Blog/"],["站点记录","/tags/SiteRecord/"]],"categories":[["HelloWorld🐣","/categories/HelloWorld/"]],"content":"๑乛◡乛๑🌹(●´∀ `●)✨ |･ω･｀) |✦▽≦) |o￩ܫ￩o)♪ |´ ˘ `*)♥|д•´)ฅ!! &ensp; &ensp; 欢迎来到【夜与花海】本站作为个人博客，主要用来分享技术积累、社会看法以及对生命的思考。 如果有所收获👆 欢迎来Github点亮小星星๑乛◡乛๑ 关于本站的主题本站使用的是 Candinya (小姐姐🍭)开源分享的 Kratos-Rebirth 主题，喜欢的话就请给小姐姐🍭点亮小星星🌟，谢谢大家啦！~(●´∀ `●) 关于本站的初衷很久以前，就觉得需要一个能够辅助自己整理和分享知识的平台。那时候还没法方便地科学上网，国内各大博客平台底下一泡污…本着宁缺勿滥的思想，于是这事情就“咕”置了 到了现在，这个博客不得不承载着[输出自产自囤多年的笔记]的重任…（哭晕在厕所今天也是干劲满满呢√） 关于本站的搭建本站基于 Hexo 框架，使用 Github - Travis CI 进行发布。 搭建不是5分钟完事了吗（白嫖狂喜.jpg）在没有足够经验的情况下，一个完整的博客从开始搭建到正式版本的上线，实际耗时远比看上去的要长（亿点点）。 本站搭建的相关填坑开发记录请移步本站的搭建记录 那就酱吧，祝各位食用愉快！~ "},{"title":"Hello, World🐣","date":"2021-04-09T19:58:39.000Z","url":"/2021/04/09/HelloWorld/","tags":[["HelloWorld🐣","/tags/HelloWorld/"]],"categories":[["HelloWorld🐣","/categories/HelloWorld/"]],"content":"“Hello, World”是最流行的一段语句，代表着一种🐣[&thinsp;对这个世界&thinsp;]🌹[&thinsp;积极的态度&thinsp;]。 “Hello, World”精神🐣 生命本就是积极的，无论何种姿态，都是在为更好的生活所前行。 生活也正是简简单单，每天醒来“Hello, World”——新的一天👉奥~里~给！（又或者“长醉不复醒，不枉来一遭”） 今天吃啥(๑´ڡ`๑) / 还有好多番没有看(´◓Д◔`) / 更新啦更新啦ε===(っ≧ω≦)っ / 带带我鸭_(:3」∠)_ / 又摸了一天鱼，好累呀~٩(๑´0`๑)۶ Hello, World是指在电脑屏幕显示“Hello, World!”（你好，世界！）字符串的计算机程序。 相关的程序通常都是每种电脑编程语言最基本、最简单的程序，也会用作示范一个编程语言如何运作。同时它亦可以用来确认一个编程语言的编译器、程序开发环境及运行环境是否已经安装妥当。 因为写法简单可见，这也是很多初学者首次接触编程语言时会撰写的程序。 在本站中，符合“Hello, World”精神🐣的知识将划分到【HelloWorld🐣】的[分类和标签]之中。 同名电影 《Hello World》，2019年9月20日在日本发行的动画电影；由 Graphinica 制作，[伊藤智彦]指导执导。（View on Wikipedia） 简介👆 Hello World is a 2019 Japanese animated sci-fi romantic drama film directed by Tomohiko Itō and produced by Graphinica.It was released in Japan on September 20, 2019.Its cast include Takumi Kitamura, Tōri Matsuzaka, and Minami Hamabe.A three-episode spin-off anime titled Another World premiered on September 13, 2019. ※参考和引用 “Hello, World!” program - Wikipedia Hello World - 维基百科，自由的百科全书 更多👆 HelloWorld的箴言 - 简书 Hello World (电影) "},{"title":"计算机工程","date":"2021-04-09T17:56:47.000Z","url":"/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/","tags":[["计算机工程","/tags/ComputerEngineering/"]],"categories":[["计算机工程","/categories/ComputerEngineering/"]],"content":" 计算机工程（英语：Computer engineering）一个以电机工程学和计算机科学的部分交叉领域为内容的工程学，其主要任务是设计及实现计算机系统。 计算机工程师通常受过专业的电子工程（或其他与计算机工程有关的电机工程学分支）、软件设计和软硬件集成综合技能的培训。计算机工程师的工作涉及了许多有关计算机的硬件和软件，其关注范围包括微处理器、个人电脑、超级计算机和电路设计（特别是集成电路的设计）等。计算机工程并不仅仅关注计算机系统本身的工作，还致力于多个计算机组成更大规模的分布式系统。 简而言之，计算机工程是一个&thinsp;[&thinsp;专注于对计算机硬件的理论和应用研究 &thinsp;]&thinsp;的[工程学]概念。 在本站中，通常会将&thinsp;[&thinsp;主要对计算机硬件的理论和应用研究&thinsp;]&thinsp;的知识划分到【计算机工程】的[分类和标签]之中。 ※参考和引用 Computer engineering - Wikipedia 计算机工程 - 维基百科，自由的百科全书 更多👆 计算机科学(Computer Science)和信息技术(IT)的区别是什么？ - 知乎 "},{"title":"计算机科学","date":"2021-04-09T17:28:48.000Z","url":"/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/","tags":[["计算机科学","/tags/ComputerScience/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" 计算机科学（英语：computer science，有时缩写为CS）是系统性研究信息与计算的理论基础以及它们在计算机系统中如何实现与应用的实用技术的学科。 它通常被形容为对那些创造、描述以及转换信息的算法处理的系统研究。 计算机科学包含很多分支领域；有些强调特定结果的计算，比如计算机图形学；而有些是探讨计算问题的性质，比如计算复杂性理论；还有一些领域专注于怎样实现计算，比如编程语言理论是研究描述计算的方法，而程序设计是应用特定的编程语言解决特定的计算问题，人机交互则是专注于怎样使计算机和计算变得有用、好用，以及随时随地为人所用。 简而言之，计算机科学是一个&thinsp;[&thinsp;侧重于对计算机知识的理论研究&thinsp;]&thinsp;的[学科]概念。 在本站中，一定程度上会将&thinsp;[&thinsp;侧重于对计算机知识的理论研究&thinsp;]&thinsp;的知识划分到【计算机科学】的[分类和标签]之中。 ※参考和引用 Computer science - Wikipedia 计算机科学 - 维基百科，自由的百科全书 更多👆 计算机科学(Computer Science)和信息技术(IT)的区别是什么？ - 知乎 "},{"title":"信息技术","date":"2021-04-09T16:28:04.000Z","url":"/2021/04/09/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/","tags":[["信息技术","/tags/InformationTechnology/"]],"categories":[["信息技术","/categories/InformationTechnology/"]],"content":" 信息技术（英语：Information Technology，缩写：IT）也称信息和通信技术（Information and Communications Technology，ICT），是主要用于管理和处理信息所采用的各种技术总称，主要是应用计算机科学和通信技术来设计、开发、安装和部署信息系统及应用软件。 简而言之，信息技术（IT）是一个&thinsp;[&thinsp;侧重于对计算机知识的应用&thinsp;]&thinsp;的[技术]概念。 在本站中，一定程度上会将&thinsp;[&thinsp;侧重于对计算机知识的应用&thinsp;]&thinsp;的知识划分到【信息技术】的[分类和标签]之中。 ※参考和引用 Information technology - Wikipedia 信息技术 - 维基百科，自由的百科全书 更多👆 计算机科学(Computer Science)和信息技术(IT)的区别是什么？ - 知乎 "},{"title":"本站的搭建记录","date":"2021-04-09T00:32:39.000Z","url":"/2021/04/09/%E6%9C%AC%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","tags":[["Git","/tags/Git/"],["信息技术","/tags/InformationTechnology/"],["站点记录","/tags/SiteRecord/"],["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"],["Github","/tags/Github/"],["Hexo","/tags/Hexo/"]],"categories":[["信息技术","/categories/InformationTechnology/"],["站点记录","/categories/InformationTechnology/SiteRecord/"]],"content":"本站从零开始的填坑搭建记录 Hexo &ensp; &ensp; Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1. 从零开始到发布本地服务📔 Hexo插件站点功能拓展文章书写功能拓展 hexo-markmap Innsert a mindmap by markdown in your hexo blog by markmap. 在你的博客中使用markdown插入思维导图，使用markmap。 hexo-tag-hint hexo-tag-hint is a simplistic plugin for Hexo which enables presenting a floating bubble containing the hint text when the content text gets hovered or clicked (yes, mobile-ready!). 文本浮动气泡插件 ※搭建过程中的参考资料 主要参看📖 Hexo 官方文档 Hexo 插件库 Markdown 教程 | 菜鸟教程 Markdown → [ 基本撰写和格式语法 - GitHub Docs ] 本站主题作者 Candinya🍭 编写的使用指南 —— [Kratos-Rebirth食用说明 | 糖菓·部落] 常用 Git 命令清单 - 阮一峰的网络日志 分类：解决问题✅ Hexo引用站内文章 | Recording 【★】[ Private Dependencies GitHub - Travis CI ]#API Token 【★】(……) [译] Hexo git deployer 删除了提交历史记录该怎么整？ - SegmentFault 思否 【★】🐣 - 孵化小鸡 表情符号: U+1F423 - Unicode 字符百科 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com 【☆】Google 翻译 【☆】[ HTML style tag ] - w3schools.com HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 markdown-cheatsheet-online | guides.github.com markdown 需要转义的字符 - 简书 Sentence spacing in digital media - Wikipedia 【★】Unicode 字符百科 【★】软件版本号规范与命名原则 - 简书 分类：其他（二度及以上关联☌） Best Practices in Securing Your Data - Travis CI [ Getting started with the REST API - GitHub Docs ]#Authentication Github 中 Markdown 锚点链接如何写 - 码蚁de天空 - OSCHINA - 中文开源技术交流社区 Hexo 搭建个人博客 #04 主题的安装与自定义样式 | 杨斌的博客 Hexo使用攻略：（四）Hexo的分类和标签设置 | { GoonX } html - How to display and using markdown? - Stack Overflow 【★】持续集成服务 Travis CI 教程 - 阮一峰的网络日志 个人博客如何设计分类和标签 - 知乎 六度分隔理论 - 维基百科，自由的百科全书 将通用代码添加为git子模块的问题：“索引中已存在” | 码农家园 如何规划blog的标签（tag）和分类 - 心内求法 - 博客园 如何解决 Git 仓库嵌套问题 - Jartto’s blog (……) Hexo 搭建个人博客 #05 利用 Travis CI 帮你自动部署 - SegmentFault 思否 (……) 关于 git-submodule 的一些基本操作 - SegmentFault 思否 "}]