[{"title":"2020年全国两会-国务院总理李克强回答中外记者提问_2020年5月28日","date":"2021-05-01T02:23:18.000Z","url":"/2021/05/01/2020%E5%B9%B4%E5%85%A8%E5%9B%BD%E4%B8%A4%E4%BC%9A-%E5%9B%BD%E5%8A%A1%E9%99%A2%E6%80%BB%E7%90%86%E6%9D%8E%E5%85%8B%E5%BC%BA%E5%9B%9E%E7%AD%94%E4%B8%AD%E5%A4%96%E8%AE%B0%E8%80%85%E6%8F%90%E9%97%AE-2020%E5%B9%B45%E6%9C%8828%E6%97%A5/","tags":[["社会","/tags/Society/"],["国家","/tags/Country/"],["政治","/tags/Politics/"]],"categories":[["社会","/categories/Society/"]],"content":" 2020年5月28日（星期四）下午十三届全国人大三次会议闭幕后，国务院总理李克强在人民大会堂三楼金色大厅出席记者会并回答中外记者提问。为有效防控疫情，共同维护公共卫生与健康，记者会采用网络视频形式进行。 新华网、中国政府网进行现场直播。 👆←🗎[1] 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 — - Em 长划: U+2014 mdash - Unicode 字符百科 连接号 - 维基百科，自由的百科全书 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"2012年3月14日_国务院总理温家宝答中外记者问","date":"2021-04-30T18:22:42.000Z","url":"/2021/04/30/2012%E5%B9%B43%E6%9C%8814%E6%97%A5-%E5%9B%BD%E5%8A%A1%E9%99%A2%E6%80%BB%E7%90%86%E6%B8%A9%E5%AE%B6%E5%AE%9D%E7%AD%94%E4%B8%AD%E5%A4%96%E8%AE%B0%E8%80%85%E9%97%AE/","tags":[["社会","/tags/Society/"],["国家","/tags/Country/"],["政治","/tags/Politics/"]],"categories":[["社会","/categories/Society/"]],"content":" 2012年3月14日上午10时，北京，十一届全国人大五次会议举行闭幕会，大会闭幕后，国务院总理温家宝&thinsp;在人民大会堂金色大厅&thinsp;与中外记者见面&thinsp;并回答记者提问。 👆←🗎[1] 现场视频 媒体评论 BBC News | 中文 学者解读温家宝中外记者会问答 - BBC News 中文 学者解读温家宝中外记者会问答 2012年3月14日 中国总理温家宝周三（14日）在十一届全国人大五次会议闭幕后接受中外记者提问，涉及很多外界关注的话题，包括“文革”重新发生的危险，以及公开批评被称为“新左派实验室”的重庆市现政府。 著名社会学学者、香港科技大学社会学教授丁学良在接受BBC中文网记者采访时说，这是温家宝近几年关于中国政改和社会问题的讲话中最具体、最诚恳的一次，其中的内容信息值得多层次地解读。 温家宝在回答新加坡《联合早报》记者关于中国政改的提问时说，没有政治体制改革的成功，经济体制改革不可能进行到底，社会上新产生的问题也不能从根本上得到解决，文化大革命这样的历史悲剧还有可能重新发生。 承认文革回潮的危险中国大陆人现在已经不那么经常地提起文革，尤其是中国政府，多年来更是尽可能地回避提及文革，而温家宝总理这次的讲话，是近几届中国政府最高层领导人首次公开承认，中国社会确实存在可怕的、潜在的文革回潮危险。 丁学良教授认为，中国社会因贪污腐败、贫富不均和官员专权等导致的民怨和社会冲突越来越尖锐，在有识者呼吁用加大多元政治民主化和自下而上的制衡来应对社会矛盾的同时，也有人认为，只有用毛泽东的治国路线才能解决目前的社会冲突。 在学者们越来越担心中国社会出现用文革式的心态、手段和政策来对付社会矛盾的可能性之际，温家宝的答记者问则证实了一些中共高层领导人也看到了这一威胁。 警惕左派更左的建议而温家宝在回答路透社记者提出的关于重庆市前副市长王立军事件问题时的态度，就被一些分析人士看作是显示了中国高层权力之争白热化、毛派和左派失败的象征。 丁学良教授不赞同这种解读，他认为尽管出现了王立军事件，尽管温家宝现在批评薄熙来领导的重庆市现政府，但并不能说明试图用文革方式来解决当今社会矛盾的毛派和左派已经完全失败，这只能说是对他们的一次重大打击。 他说，王立军事件暴露了重庆市的真实情况，而且说明“新左派实验室”的重庆模式不仅在全国无法推广，就是在重庆实行，产生的后果也很可怕，因为连掌管重庆所有警察和公安权力的最高长官王立军都因此被逼上主动的、自杀性的极端道路。 丁学良教授在较高评价温家宝总理周三的这次答记者问的同时警告，要警惕左派们提出用更左的政策手段解决中国社会矛盾冲突的可能性，而这条路是走不通的，只会把中国引向绝路。 👆←🗎[2] 重庆日报头版全文刊登温家宝答中外记者问 - 腾讯新闻 📖参看 主要参看📖 国务院总理温家宝答中外记者问_2012年全国两会_中国政府网直播 温家宝 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 — - Em 长划: U+2014 mdash - Unicode 字符百科 连接号 - 维基百科，自由的百科全书 分类：其他（二度及以上关联☌） ErrorCode 错误码 on Twitter:&quot;@lvy01011 不是我们怀念上一届… lvy未央 on Twitter:”温家宝2012年3月14日答中外记者问：没… ※参考和引用 ^&ensp;视频回放：温家宝总理会见中外记者 - 2012两会 - 新华网 ^&ensp;学者解读温家宝中外记者会问答 - BBC News 中文 重庆日报头版全文刊登温家宝答中外记者问 - 腾讯新闻 🔗外部链接 Wikipedia’s external link ltr-icon  温家宝2012年3月14日答中外记者问 - 华夏画报 温家宝2012年3月14日答中外记者问 - 新快报 "},{"title":"政治(Politics)","date":"2021-04-30T14:21:43.000Z","url":"/2021/04/30/%E6%94%BF%E6%B2%BB/","tags":[["社会","/tags/Society/"],["政治","/tags/Politics/"]],"categories":[["社会","/categories/Society/"]],"content":" 政治（英语：Politics）是由各种团体进行集体决策的一个过程，也是各种团体或个人为了各自的领域所结成的特定关系，尤指对于社会群体的统治，例如统治一个国家，亦指对于一国内外事务之监督与管制。狭义来说，这个词多用来指政府、政党等治理国家的行为。然而社会学家也用来指涉包括各种利益机构、学校、宗教机构在内的相互之间的关系。 从人类社会学来讲，政治是人类社会中存在的一种非常重要的社会现象，它影响到人类生活的各个方面。这个社会现象非常复杂，因而在不同历史时期、不同文化、不同语言，以及从不同学科角度，不同的学者对他的论述也不相同。而且政治内涵的本身也在不断的变化，因此对政治的阐释也充满了争议，始终没有一个确切公认的定义。 政治学是专门以政治为研究对象的一门社会科学，研究政治行为的理论和考察权力的获得与行使。 👆←🗎[1] 在本站中，[&thinsp;涉及&thinsp;政治&thinsp;]&thinsp;的知识&thinsp;会被划分到【政治】的[标签]之中。 关于政治的格言 「暴力可以脅迫人們順服，可以恐嚇他們加入社會以尋求保護。但真正人類社會所具有的屬性是不能以暴力作為它團結的原則的。團結必須建立在同意的基礎上，而且這種同意，如果不是暫時的，便是任何民主的政治社會合乎邏輯的起點。正如洛克所說的，『人們表示同意建立一個社會或政府，因此，團結起來並組成國家。』」 —— 卡爾·柯恩《民主概論》 不作出任何（正面）回應 —— [香港政治] 独裁带来了枪口，这带来了沉闷。 科学只能在言论自由的氛围中蓬勃发展。 —— 阿尔伯特·爱因斯坦 “Die Diktatur bringt den Maulkorb und dieser die Stumpfheit. Wissenschaft kann nur gedeihen in einer Atmosphäre des Freien Wortes.” — Albert Einstein 「對每個國家的公民來說，這個國家所宣稱的目標，不論是愚昧的或崇高的，都是至關重要的。因為，憑藉他的公民權，他得以分享這些目標。在政治社會中，公民權說明一個人的身分，也說明他的法律地位。如果公民資格的取得是經過思考並足以自豪的，那也可部分說明他的道德水平，因為公民資格表示該社會的目標就是他的目標。在民主國家，公民權尤為重要，因在一個國家內，他的意見雖是許多意見中的一項，但該國的目標是由於公民的參與而產生的。」 —— 卡爾·柯恩《民主概論》 腐化落后的政治环境是一切腐化落后的思想的温床。 —— 柯灵 法律在中国的定义是：为统治阶级服务，用来约束被统治阶级的言行、举止。对违反规则的下层人士绳之以法，却为上层人士保驾护航，网开一面的一种明文条款。什么“王子犯法，与庶民同罪”。那是愚昧的被统治阶级对统治阶级一厢情愿的迷梦。在中国，官对付民，易如反掌；民要告官。难如登天。昂贵的诉讼费、复杂的法律手续、官官相护的政治潜规则。无一不击中你的要害，击毙你企图维护正义的愚蠢心态。 —— 曹极 管理众人的事便是政治。 —— 孙中山 讲到国家的政治，根本上要人民有权；至于管理政府的人，便要付之于有能的专家们。 —— 孙中山 能够在实际上为最大多数的治人者和治于人者创造最大的幸福的政治，便是最好的政治。 —— 欧文 人民（市民）的眼睛是雪亮的 —— [香港政治] 人应该有一种基本的自信，就是做人的自信，作为人类平等一员的自信。在专制政治下，人们的这种自信必然遭到普遍的摧毁。当所有的人都被迫跪下的时候，那惟一站着的人就成了神。 —— 周国平 我们赞赏那种真正的政治家，就像赞赏那种给我们写下了人间最宏伟的的诗篇的人一样。永远放眼未来，赶在命运的前头，超越于权利之上。 —— 巴尔扎克 我所以反对独裁者，就因为他们不近人情。因为不近人情者总是不好的。不近人情的宗教不能算是宗教；不近人情的政治是愚笨的政治，不近人情的艺术是恶劣的艺术；而不近人情的生活也就是畜类式的生活。 —— 林语堂 西方人心目中的中国形象，是近代史意义上的想象和历史的产物：想象中的神秘、扭曲、变形，再加上历史中的弱小和受辱，综合成了一个现实的、静止的“中国脸谱”。直到今天，在更多的西方人眼中，中国人的形象还是长辫子、瓜皮帽、目光呆滞、面带菜色。另一种形象就是，“政治波普”加上观念艺术造就的中国脸谱：清一色的军装军帽、恐慌而夸张的眼神、蕴涵着一股政治狂热，也就是“文化大革命”的脸谱。 —— 张柠 中国的环境问题不是专业问题，而是一个政治问题，根源是我们扭曲的发展观。 —— 潘岳 中国人消极避世的习惯有如英国人出门带雨伞，因为政治气候对那些试图做点冒险事业的人来说，总是不大正常的。 —— 林语堂 「政就是众人之事，治就是管理，管理众人之事，便是政治。」 —— 孙中山 《孙中山选集》 「在世界各地，民主的改進、普及，甚至保持，其嚴重障礙之一是不能實現民主的物質條件。政治社會中的民主如要取得長遠的成功，便需世界廣大群眾所達到的生活水平大大高於他們目前的水平，而且大大減少目前分裂他們的經濟上明顯的不平。」 —— 卡爾·柯恩《民主概論》 「在現實政治事務中，就人民這個詞本身的含義來說，是不能統治他們自己的。發號施令的政府可能來自人民的選擇，但人民並不制定或執行法律。統治者和被統治者二者之間的區別，至少在範圍較大的社會中，是不難劃分的。大多數人是被統治者，而非統治者。然而，自治一詞並非荒謬。當我們用這個詞描述某種情況時，看來還是講得通的。民主政體即自治政體，由人民自己治理。在某些情況下，這樣的政體確是現實存在的事物。」 —— 卡爾·柯恩《民主概論》 只要我还能有所选择，我就只想生活在这样的国家里，这个国家中所实行的是：公民、自由、宽容，以及在法律面前公民一律平等。公民自由意味着人们有用言语和文字表示其政治信念的自由；宽容意味着尊重别人可能有的任何信念。 —— 阿尔伯特·爱因斯坦 “As long as I have any choice in the matter, I shall live only in a country where civil liberty, tolerance, and equality of all citizens before the law prevail.” — Albert Einstein 👆←🗎[2] 战争不仅是一种政治行为，而且是一种真正的政治工具，是政治交往的继续，是政治交往通过另一种手段的实现。 —— 克劳塞维茨 战争不是达到政治目的手段，战争必须消除，而不仅仅是限制。 —— 勃兰特 政治良否，视人与法。 —— 孙中山 政治里面有两个潮流，一个是自由底潮流，一个是秩序底潮流。 —— 孙中山 政治是运用国家的；国家是实行政治的。 —— 孙中山 政治社会的建立并不是为了别的目的，而仅仅是为了保障每个人今生财产的所有权。 —— 洛克 政治是经济的女儿，所以他照顾自己的女儿是很自然的。 —— 高尔基 在政治上，如同在宗教上一样，要想用火与剑迫使人们改变信仰，是同样荒谬的。 —— 汉密尔顿 「政治自由的含義指的是從事自治引起的各種事務的自由。這些自由基本上包括公民使用某種手段以表示自己意見並在管理中產生效果的自由。首先，公民必須能自由地投票。社會中每個成員必須按一個人來計算，而且這種權利必須得到保護。」 —— 卡爾·柯恩《民主概論》 📖参看 主要参看📖 Albert Einstein - Wikiquote Politics - Wikipedia 阿尔伯特·爱因斯坦 - 维基语录，自由的名人名言录 政治 - 维基百科，自由的百科全书 政治哲学 - 维基百科，自由的百科全书 政治 - 维基语录，自由的名人名言录 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 破折号 - 维基百科，自由的百科全书 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 — - Em 长划: U+2014 mdash - Unicode 字符百科 连接号 - 维基百科，自由的百科全书 分类：其他（二度及以上关联☌） 格言 - 维基百科，自由的百科全书 自由民主制 - 维基百科，自由的百科全书 分类：其他（二度及以上关联☌）（站内资源） 国家(Country) ※参考和引用 ^&ensp;政治 - 维基百科，自由的百科全书 ^&ensp;[&thinsp;Albert Einstein Quotes And Facts - EasyBib&thinsp;]#[&thinsp;Einstein and World War II&thinsp;]#[&thinsp;Fleeing Germany&thinsp;] Albert Einstein Quotes And Facts - EasyBib politics icon - Google 搜索 阿尔伯特·爱因斯坦 - 维基语录，自由的名人名言录 政治 - 维基语录，自由的名人名言录 🔗外部链接 Wikipedia’s external link ltr-icon โต้วาที, ข้อกำหนดการโต้วาที, พูดสาธารณะ png - png โต้วาที, ข้อกำหนดการโต้วาที, พูดสาธารณะ icon vector "},{"title":"美国枪支暴力问题","date":"2021-04-30T01:31:48.000Z","url":"/2021/04/30/%E7%BE%8E%E5%9B%BD%E6%9E%AA%E6%94%AF%E6%9A%B4%E5%8A%9B%E9%97%AE%E9%A2%98/","tags":[["社会","/tags/Society/"],["美国","/tags/United-States-of-America/"],["文化","/tags/Culture/"],["法律","/tags/Law/"]],"categories":[["社会","/categories/Society/"]],"content":" 枪械暴力是美国社会重大的公共议题之一，特别是在城市地区，并且与青年活动和帮派暴力息息相关。自1865年林肯总统，以及后来的加菲尔德总统、麦金莱总统和肯尼迪总统被暗杀以来，枪支暴力对美国人来说已相当常见。而枪支暴力引发的重大事件，如参议员罗伯特·肯尼迪、民权领袖马丁·路德·金的暗杀，以及科伦拜中学大屠杀、华盛顿特区狙击手攻击事件、维吉尼亚理工大学校园枪击案、桑迪·胡克小学枪击案，也时常引发对枪支政策的辩论。在美国，枪支暴力与大多数凶杀案与超过一半以上的自杀案有关。 在美国发生的枪击案件中，很大比例都是非致命性的。美国疾病控制与预防中心估计，美国在2000年总共发生了52447起蓄意、23237起意外非致命枪伤。美国大多数因枪伤致死的人都是自杀，2004年共有16907起自杀是使用枪支的。 美国联邦、州和地方各级的法律政策试图通过各种方法解决枪支暴力，包括限制由青年和其他“高风险”的人购买枪支、为购买枪支设置等待时间、设立枪支“回购”计划、针对性执法和制定警务策略、对违反枪支法者从重量刑、为家长和子女开设教育课程，以及在社区推广。研究显示这些政策结果好坏参半。一些政策如枪支“回购”方案成效不大，而像波士顿“停火行动”（减少帮派暴力的策略）已有效地减低青少年暴力。枪支管理政策在美国受到美国宪法第二修正案的强烈影响，该法案禁止侵犯“人民持有和携带武器的权利”。拥枪权倡导者一般鼓励大众捍卫宪法第二修正案所保障的权利。 👆←🗎[1] 📖参看 主要参看📖 美国枪支暴力问题 - 维基百科，自由的百科全书 主要参看📖（站内资源） 美利坚合众国 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;美国枪支暴力问题 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"美国枪支政策","date":"2021-04-30T01:31:24.000Z","url":"/2021/04/30/%E7%BE%8E%E5%9B%BD%E6%9E%AA%E6%94%AF%E6%94%BF%E7%AD%96/","tags":[["社会","/tags/Society/"],["美国","/tags/United-States-of-America/"],["文化","/tags/Culture/"],["法律","/tags/Law/"]],"categories":[["社会","/categories/Society/"]],"content":" 枪支管制的相关政策一直是美国政治中的争议议题。持枪权的支持者和枪支管制的支持者（不等同反对持枪权）在该问题上分歧很大，经常在枪支管制、枪支造成和预防犯罪、公共安全等问题上争论不休。 👆←🗎[1] 📖参看 主要参看📖 美国枪支政策 - 维基百科，自由的百科全书 主要参看📖（站内资源） 美利坚合众国 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;美国枪支政策 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"《The Star-Spangled Banner》","date":"2021-04-30T00:26:19.000Z","url":"/2021/04/30/%E3%80%8AThe-Star-Spangled-Banner%E3%80%8B/","tags":[["社会","/tags/Society/"],["美国","/tags/United-States-of-America/"],["文化","/tags/Culture/"]],"categories":[["其他","/categories/Other/"]],"content":" “The Star-Spangled Banner” is the national anthem of the United States. The lyrics come from the “Defence of Fort M’Henry”, a poem written on September 14, 1814, by 35-year-old lawyer and amateur poet Francis Scott Key after witnessing the bombardment of Fort McHenry by British ships of the Royal Navy in Baltimore Harbor during the Battle of Baltimore in the War of 1812. Key was inspired by the large U.S. flag, with 15 stars and 15 stripes, known as the Star-Spangled Banner, flying triumphantly above the fort during the U.S. victory. The poem was set to the tune of a popular British song written by John Stafford Smith for the Anacreontic Society, a men’s social club in London. “To Anacreon in Heaven” (or “The Anacreontic Song”), with various lyrics, was already popular in the United States. This setting, renamed “The Star-Spangled Banner”, soon became a well-known U.S. patriotic song. With a range of 19 semitones, it is known for being very difficult to sing. Although the poem has four stanzas, only the first is commonly sung today. “The Star-Spangled Banner” was recognized for official use by the United States Navy in 1889, and by U.S. president Woodrow Wilson in 1916, and was made the national anthem by a congressional resolution on March 3, 1931 (46 Stat. 1508, codified at 36 U.S.C. § 301), which was signed by President Herbert Hoover. Before 1931, other songs served as the hymns of U.S. officialdom. “Hail, Columbia” served this purpose at official functions for most of the 19th century. “My Country, ‘Tis of Thee”, whose melody is identical to “God Save the Queen”, the United Kingdom’s national anthem, also served as a de facto national anthem. Following the War of 1812 and subsequent U.S. wars, other songs emerged to compete for popularity at public events, among them “America the Beautiful”, which itself was being considered before 1931 as a candidate to become the national anthem of the United States. 👆←🗎[1] “The Star-Spangled Banner” in 1814 📖参看 主要参看📖 The Star-Spangled Banner - Wikipedia 美国国歌 - 维基百科，自由的百科全书 主要参看📖（站内资源） 美利坚合众国 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;The Star-Spangled Banner - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"In God We Trust","date":"2021-04-30T00:01:20.000Z","url":"/2021/04/30/In-God-We-Trust/","tags":[["社会","/tags/Society/"],["美国","/tags/United-States-of-America/"],["文化","/tags/Culture/"]],"categories":[["社会","/categories/Society/"]],"content":" “In God We Trust” (sometimes rendered “In God we trust”) is the official motto of the United States of America and of the U.S. state of Florida. It was adopted by the U.S. Congress in 1956, supplanting E pluribus unum, which had been the de facto motto since the initial 1776 design of the Great Seal of the United States. The capitalized form “IN GOD WE TRUST” first appeared on the two-cent piece in 1864 and has appeared on paper currency since 1957. A law passed in a Joint Resolution by the 84th Congress (Pub.L. 84–140) and approved by President Dwight Eisenhower on July 30, 1956, requires that “In God We Trust” appear on all American currency. The following year, the phrase was used on paper money for the first time—on the updated one-dollar silver certificate that entered circulation on October 1, 1957. The 84th Congress later passed legislation (Pub.L. 84–851), also signed by President Eisenhower on July 30, 1956, declaring the phrase to be the national motto. Some groups and people have objected to its use, contending that its religious reference violates the Establishment Clause of the First Amendment. These groups believe the phrase should be removed from currency and public property. In lawsuits, this argument has not overcome the interpretational doctrine of accommodationism, which allows government to endorse religious establishments as long as they are all treated equally.[10] According to a 2003 joint poll by USA Today, CNN, and Gallup, 90% of Americans support the inscription “In God We Trust” on U.S. coins. In 2006, “In God We Trust” was designated as the motto of the U.S. state of Florida.The Spanish equivalent of “In God We Trust”, En Dios Confiamos, is the motto of the Republic of Nicaragua. The heraldic motto of Brighton, England was (until 1997) the Latin equivalent, In Deo Fidemus. 👆←🗎[1] 📖参看 主要参看📖 In God We Trust - Wikipedia In God We Trust - 维基百科，自由的百科全书 主要参看📖（站内资源） 美利坚合众国 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;In God We Trust - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"国家(Country)","date":"2021-04-29T15:14:26.000Z","url":"/2021/04/29/%E5%9B%BD%E5%AE%B6-Country/","tags":[["国家","/tags/Country/"]],"categories":[["社会","/categories/Society/"]],"content":" 国家&thinsp;或&thinsp;国（法语：pays；英语：country或nation；西班牙语：país；德语：Land），有时又作&thinsp;邦，现代多指&thinsp;主权国家（sovereign state）。 从广义的角度，国家&thinsp;是指&thinsp;拥有共同的语言、文化、种族、宗教、领土、政权或者历史的&thinsp;社会群体；从狭义的角度，国家&thinsp;是一定范围内的人群所形成的&thinsp;共同体形式。一般来说，国家行政管理当局&thinsp;是&thinsp;国家的象征，它是一种拥有治理一个社会的权力的国家机构，在一定的领土内&thinsp;拥有外部和内部的主权。 👆←🗎[1] 在本站中，[&thinsp;涉及&thinsp;国家&thinsp;]&thinsp;的知识&thinsp;会被划分到【国家】的[标签]之中。 📖参看 主要参看📖 Country - Wikipedia 国家 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;国家 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"美利坚合众国","date":"2021-04-29T14:58:36.000Z","url":"/2021/04/29/%E7%BE%8E%E5%88%A9%E5%9D%9A%E5%90%88%E4%BC%97%E5%9B%BD-United-States-of-America/","tags":[["国家","/tags/Country/"],["美国","/tags/United-States-of-America/"]],"categories":[["社会","/categories/Society/"]],"content":" 美利坚合众国（英语：United States of America，缩写为USA，一般称为United States（U.S.或US），或America），中文通称&thinsp;美国。是由其下辖的50个州、华盛顿哥伦比亚特区、五个自治领土及外岛共同组成的联邦共和国。 美国本土48个州和联邦特区&thinsp;位于北美洲中部，东临大西洋，北面是加拿大，南部和&thinsp;墨西哥及墨西哥湾&thinsp;接壤，本土位于温带、副热带地区。阿拉斯加州&thinsp;位于北美大陆西北方，东部为加拿大，西隔白令海峡和俄罗斯相望；夏威夷州&thinsp;则位于大洋洲太平洋中部的群岛。美国&thinsp;在加勒比海和太平洋&thinsp;还拥有多处境外领土和岛屿地区。此外，美国&thinsp;还在全球很多个国家和地区&thinsp;拥有着众多海外军事基地。 美国的面积&thinsp;超过983万平方公里，正式为9,834,000万平方公里，位居世界第三或第四；同时拥有接近超过3.3亿人口，为世界第三人口大国。美国是世界上人口最多的发达国家，有着来自世界各地的大量移民，也是&thinsp;世界上&thinsp;民族和文化最多元的国家之一。美国地形与气候&thinsp;复杂多样，是多种野生动物的家园。 👆←🗎[1] 顺带一提，在&thinsp;Wikipedia&thinsp;上，上述部分的部分语句比较生硬，我把它们修饰了一下。 国旗 国徽 📖参看 主要参看📖 United States - Wikipedia 美国 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） In God We Trust - 维基百科，自由的百科全书 美国国歌 - 维基百科，自由的百科全书 美国国徽 - 维基百科，自由的百科全书 美国国旗 - 维基百科，自由的百科全书 星条旗永不落 - 维基百科，自由的百科全书 ※参考和引用 ^&ensp;美国 - 维基百科，自由的百科全书 Flag of the United States - Wikipedia National symbols of the United States - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon Wikipedia_en_file__Flag_of_the_United_States Wikipedia_en_file__Greater_coat_of_arms_of_the_United_States "},{"title":"地区","date":"2021-04-29T14:32:17.000Z","url":"/2021/04/29/%E5%9C%B0%E5%8C%BA/","tags":[["地区","/tags/Region/"]],"categories":[["社会","/categories/Society/"]],"content":" 在地理学中，区域是按物理特征（自然地理），人类影响特征（人类地理）以及人类与环境的相互作用（环境地理）大致划分的区域。地理区域和次区域的定义大多不明确，有时是短暂的边界，但人文地理除外，因为法律规定了国界等管辖区域。 除了全球 大陆地区以外，还存在覆盖海洋的水圈和大气区域，以及地球陆地和水体之上的离散气候。陆地和水域全球区域在地理上划分为子区域，这些子区域受到影响广泛生态（例如平原和地貌）的大型地质特征的界定。 作为描述空间区域的一种方式，区域的概念非常重要，并且在许多地理分支中得到了广泛使用，每个分支都可以用区域术语来描述区域。例如，“生态区域”是环境地理，文化地理中的文化区域，生物地理中的生物区域等使用的术语。研究区域本身的地理学领域称为区域地理学。 在自然地理，生态学，生物地理学，动物地理学和环境地理学领域，区域往往基于自然特征，例如生态系统或生物群落，生物群落，流域，自然区域，山脉，土壤类型。在涉及人文地理的地区，人种学学科描述了区域和子区域。 一个地区有其自身的性质，无法移动。第一自然是自然环境（地形，气候等）。第二种性质是其过去由人们建造的物理元素复合体。第三种性质是其社会文化背景，新移民无法替代。 👆←🗎[1] 在本站中，会将&thinsp;[&thinsp;涉及&thinsp;地区&thinsp;]&thinsp;的知识&thinsp;划分到【地区】的[标签]之中。 📖参看 主要参看📖 Region - Wikipedia 地域大国 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Region - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"文化","date":"2021-04-26T22:43:39.000Z","url":"/2021/04/26/%E6%96%87%E5%8C%96/","tags":[["社会","/tags/Society/"],["文化","/tags/Culture/"]],"categories":[["社会","/categories/Society/"]],"content":" 文化（日语：文化／ぶんか Bunka）是由古罗马哲学家西塞罗首次使用拉丁文“cultura animi”定义，原意是“灵魂的培养”，由此衍生为生物在其发展过程中积累起跟自身生活相关的知识或经验，使其适应自然或周围的环境，是一群共同生活在相同自然环境及经济生产方式的人所形成的一种约定俗成潜意识的外在表现。 对“文化”有各种各样的定义，其中之一的意义是“相互通过学习人类思想与行为的精华来达到完美”；广义的文化包括文字、语言、建筑、饮食、工具、技能、技术、知识、习俗、艺术等。大致上可以用一个民族的生活形式来指称它的文化。 在考古学上“文化”则指同一历史时期的遗迹、遗物的综合体。同样的工具、用具、制造技术等是同一种文化的特征。文化和文明有时在用法上混淆不清。 现今中文里文化一词的意思，借自于日文和制汉语中“文化”之义，其所表达的概念、集合与意涵和华夏古籍的原义相差甚远，应避免望文生义。 互联网成熟的发展使原先相对疏离的个人或组织可以很容易经由社群网站，建立许多新的基于价值观、理想、观念、商业、友谊、血缘等等非常错综复杂的联系，由此发展出特定社群意识的网络文化，这种网络文化联系瞬间的爆发力，对特定议题及选举所造成的影响已经是新兴不可忽视的力量。 👆←🗎[1] 在本站中，通常会将&thinsp;[&thinsp;主要涉及&thinsp;文化&thinsp;]&thinsp;的知识&thinsp;划分到【文化】的[标签]之中。 📖参看 主要参看📖 Culture - Wikipedia 文化 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;文化 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"（社会）（文化）梁宏达_【老梁：中国神话体系】","date":"2021-04-26T21:39:10.000Z","url":"/2021/04/26/%EF%BC%88%E7%A4%BE%E4%BC%9A%EF%BC%89%EF%BC%88%E6%96%87%E5%8C%96%EF%BC%89%E6%A2%81%E5%AE%8F%E8%BE%BE-%E3%80%90%E8%80%81%E6%A2%81%EF%BC%9A%E4%B8%AD%E5%9B%BD%E7%A5%9E%E8%AF%9D%E4%BD%93%E7%B3%BB%E3%80%91/","tags":[["社会","/tags/Society/"],["文化","/tags/Culture/"]],"categories":[["社会","/categories/Society/"]],"content":" 老梁：中国神话体系 - YouTube 264,938次观看•2020年3月12日 👆←🗎[1] View on YouTube 📖参看 主要参看📖 老梁 - YouTube 梁宏达 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;老梁：中国神话体系 - YouTube 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"心理学","date":"2021-04-22T16:46:57.000Z","url":"/2021/04/22/%E5%BF%83%E7%90%86%E5%AD%A6/","tags":[["社会","/tags/Society/"],["心理学","/tags/Psychology/"]],"categories":[["社会","/categories/Society/"]],"content":" 心理学（英语：psychology）是一门研究人类和动物的心理现象、意识和行为的科学。它既是一门理论学科，也是一门应用学科，包括理论心理学与应用心理学两大领域。 心理学研究涉及意识、感觉、知觉、认知、情绪、人格、行为和人际关系等众多领域，影响其他学科的发展，例如：教育学、管理学、传播学、社会学、经济学、精神病学、统计学、以及文学等等。心理学一方面尝试用大脑运作来解释个体基本的行为与心理机能，同时，心理学也尝试解释个体心理机能在社会行为与社会动力中的角色。心理学家从事基础研究的目的是描述、解释、预测和控制行为。应用心理学家还有第五个目的——提高人类生活的品质。这些目标构成了心理学事业的基础。 早期的心理学家为了研究人类的行为，会对动物进行残忍实验，以推测环境、生理（如：大脑损伤、运动是否能增加多巴胺等）以及一些特定因素对人产生的影响。但这种实验方法一直以来受到讨论与争议。然而，随着科技的进步，人们使用核磁共振、断层扫描、及发展较成熟的问卷调查等方式来研究人类的心理。有时会有脑部部分损伤的病人，心理学家也借由观察这些人的脑部活动，去了解脑袋各部位的功能为何。 👆←🗎[1] 在本站中，会将&thinsp;[&thinsp;主要涉及&thinsp;心理学&thinsp;]&thinsp;的知识&thinsp;划分到【心理学】的[标签]之中。 📖参看 主要参看📖 Psychology - Wikipedia 心理学 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;心理学 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"（社会）（心理学）梁宏达解读洗脑术","date":"2021-04-22T16:14:02.000Z","url":"/2021/04/22/%EF%BC%88%E7%A4%BE%E4%BC%9A%EF%BC%89%EF%BC%88%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%89%E6%A2%81%E5%AE%8F%E8%BE%BE%E8%A7%A3%E8%AF%BB%E6%B4%97%E8%84%91%E6%9C%AF/","tags":[["社会","/tags/Society/"],["文化","/tags/Culture/"],["心理学","/tags/Psychology/"]],"categories":[["社会","/categories/Society/"]],"content":" 老梁解读洗脑术 过瘾！！ - YouTube 598,212次观看•2020年3月20日 👆←🗎[1] View on YouTube 📖参看 主要参看📖 老梁 - YouTube 梁宏达 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;老梁解读洗脑术-过瘾！！ - YouTube 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"《Thinking in Java》","date":"2021-04-16T20:14:45.000Z","url":"/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["《Thinking in Java》","/tags/%E3%80%8AThinking-in-Java%E3%80%8B/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" Thinking in Java (ISBN 978-0131872486) is a book about the Java programming language, written by Bruce Eckel and first published in 1998. Prentice Hall published the 4th edition of the work in 2006. The book represents a print version of Eckel’s “Hands-on Java” seminar. Bruce Eckel wrote “On Java8” as a sequel for Thinking in Java and it is available in Google Play as an ebook. 👆←🗎[1] Java 经典著作。本站专门做了对该著作的整理笔记。 手册 《Thinking in Java》（第4版） ← 整理手册 📖参看 主要参看📖 【电子书】Thinking in Java, 4th Edition (Bruce Eckel) 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Thinking in Java - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"《Thinking in Java》（第4版） ← 整理手册","date":"2021-04-16T18:53:02.000Z","url":"/2021/04/16/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["《Thinking in Java》","/tags/%E3%80%8AThinking-in-Java%E3%80%8B/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" 《Thinking in Java》(4th)&thinsp;的译本《Java编程思想》(第四版)&thinsp;的整理笔记。 该手册中还包括&thinsp;本人添加的&thinsp;一些知识更新和拓展。 顺便吐槽一下，译本的翻译比较生硬，很多地方使用容易出现歧义的长句 目录 第1章 面向对象导论 1.1 抽象过程 1.2 每个对象都有一个接口 1.3 每个对象都提供服务 1.4 被隐藏的具体实现 1.5 复用具体实现 1.6 继承 1.6.1 “是一个”与“像是一个”的关系 1.7 伴随多态的可互换对象 1.8 单根继承结构 1.9 容器 1.9.1 参数化类型 1.10 对象的创建和生命周期 1.11 异常处理：错误处理 1.12 并发编程 1.13 Java与Internet 1.13.1 Web是什么 1.13.2 客户端编程 1.13.3 服务器端编程 1.14 总结 第2章 一切都是对象 2.1 用引用操纵对象 2.2 必须由你创建所有对象【底层存储】 2.2.1 存储到什么地方【对象的存储】 2.2.2 特例：基本类型 2.2.3 Java中的数组 2.3 永远不需要销毁对象 2.4 创建新的数据类型 2.5 方法、参数和返回值 2.6 构建一个Java程序 2.7 你的第一个Java程序 2.8 注释和嵌入式文档 2.9 编码风格 2.10 总结 2.11 练习 第3章 操作符 3.1 更简单的打印语句 3.2 使用Java操作符 3.3 优先级 3.4 赋值 3.4.1 方法调用中的别名问题 3.5 算数操作符 3.5.1 一元加减操作符 3.6 自动递增和递减 3.7 关系操作符 3.7.1 测试对象的等价性 3.8 逻辑操作符 3.8.1 短路 3.9 直接常量 3.9.1 指数记数法 3.10 按位操作符 3.11 移位操作符 3.12 三元操作符if-else 3.13 字符串操作符+和= 3.14 使用操作符时常犯的错误 3.15 类型转换操作符 3.15.1 截尾和舍入 3.15.2 提升 3.16 Java没有sizeof 3.17 操作符小结 3.18 总结 第4章 控制执行流程 第5章 初始化与清理 5.1 用构造器确保初始化 5.2 方法重载 5.3 默认构造器 5.4 this关键字 5.4.1 在构造器中调用构造器 5.4.2 static的含义 5.5 清理：终结处理和垃圾回收 5.5.1 finalize()的用途何在 5.5.2 你必须实施清理 5.5.3 终结条件 5.5.4 垃圾回收器如何工作 5.6 成员初始化 5.6.1 指定初始化 5.7 构造器初始化 5.7.1 初始化顺序 5.7.2 静态数据的初始化 5.7.3 显式的静态初始化 5.7.4 非静态实例初始化 5.8 数组初始化 5.8.1 可变参数列表 5.9 枚举类型 5.9.1 枚举类（enum）——基本概念 5.9.2 枚举类的使用 5.10 总结 第6章 访问权限控制 6.1 包：库单元 6.1.1 代码组织 6.1.2 创建独一无二的包名 6.1.3 定制工具库 6.1.4 用import改变行为 6.1.5 对使用包的忠告 6.2 Java访问权限修饰词 6.3 接口和实现 6.4 类的访问权限 6.5 总结 第7章 复用类 7.1 组合语法 7.2 继承语法 7.2.1 初始化基类 【拓展】7.2.2 重写 7.3 代理 7.4 结合使用组合和继承 7.4.1 确保正确清理 7.4.2 名称屏蔽 7.5 在组合与继承之间选择 7.6 protected关键字 7.7 向上转型 7.7.1 为什么称为向上转型 7.7.2 再论组合与继承 7.8 final关键字 7.8.1 final数据 7.8.2 final方法 7.8.3 final类 7.8.4 有关final的忠告 7.9 初始化类及类的加载 7.9.1 继承与初始化 7.10 总结 第8章 多态 8.1 再论向上转型 8.1.1 忘记对象类型 8.2 转机 8.2.1 方法调用绑定 8.2.2 产生正确的行为 8.2.3 可拓展性 8.2.4 缺陷：“覆盖”私有方法 8.2.5 缺陷：域与静态方法 8.3 构造器和多态 8.3.1 构造器的调用顺序 8.3.2 继承与清理 8.3.3 构造器内部的多态方法的行为 8.4 协变返回类型 8.5 用继承进行设计 8.5.1 纯继承与拓展 8.5.2 向下转型与运行时类型识别 8.6 总结 第9章 接口 9.1 抽象类和抽象方法 9.2 接口 9.3 完全解耦 9.4 Java中的多重继承 9.5 通过继承来拓展接口 9.6 适配接口 9.7 接口中的域 9.8 嵌套接口 9.9 接口与工厂 9.10 总结 第10章 内部类 10.1 创建内部类 10.2 链接到外部类 10.3 使用.this与.new 10.4 内部类与向上转型 10.5 在方法和作用域内的内部类 10.6 匿名内部类 10.7 嵌套类 10.8 为什么需要内部类 10.9 内部类的继承 10.10 内部类可以被覆盖吗 10.11 局部内部类 10.12 内部类标识符 10.13 总结 第11章 持有对象 11.1 泛型和类型安全的容器 11.2 基本概念 11.3 添加一组元素 11.4 容器的打印 11.5 List（原理 &amp; 简介） 11.6 迭代器 11.7 LinkedList 11.8 Stack 11.9 Set 11.10 Map 11.11 Queue 11.12 Collection和Iterator 11.13 Foreach与迭代器 11.13.1 适配器方法惯用法→示例源码说明 11.14 总结 第12章 通过异常处理错误 12.1 概念 12.2 基本异常 12.2.1 捕获异常参数 12.3 捕获异常 12.3.1 try块 12.3.2 异常处理程序 12.4 创建自定义异常 12.4.1 异常与记录日志 12.5 异常说明 12.6 捕获所有异常 12.6.1 栈轨迹 12.6.2 重新抛出异常 12.6.3 异常链 12.7 Java标准异常 12.7.1 特例：RuntimeException 12.8 使用finally进行清理 12.8.1 finally用来做什么 12.8.2 在return中使用finally 12.8.3 缺憾：异常缺失 12.9 异常的限制 12.10 构造器 12.11 异常匹配 12.12 其他可选方式 12.12.1 历史 12.12.2 观点 12.12.3 把异常传递给控制台 12.12.4 把“被检查的异常”转换为“不检查的异常” 12.13 异常使用指南 12.14 总结 第13章 字符串 13.1 不可变String 13.2 重载“+”与StringBuilder 13.3 无意识的递归 13.4 String上的操作 13.5 格式化输出 13.5.4 格式化说明符 13.6 正则表达式 13.7 扫描输入 13.8 StringTokenizer（已废弃） 13.9 总结 第14章 类型信息（RTTI） 14.1 为什么需要RTTI 14.2 Class对象 14.2.1 类字面量 14.2.2 泛化的Class引用 14.2.3 类的转换（原：新的转型语法） 14.3 类型转换前先做检查 14.4 注册工厂 14.5 instanceof与Class的等价性 14.6 反射：运行时的类信息 14.6.1 类方法提取器 14.7 动态代理 14.8 空对象 14.8.1 模拟对象与桩 14.9 接口与类型信息 14.10 总结 第15章 泛型 15.1 与C++比较 15.2 简单泛型 15.2.1 一个元祖类库 15.2.2 一个堆栈类 15.2.3 RandomList 15.3 泛型接口 15.4 泛型方法 15.4.1 杠杆利用类型参数判断 15.4.2 可变参数与泛型方法 15.4.3 用于Generator的泛型方法 15.4.4 一个通用的Generator 15.4.5 简化元祖的使用 15.4.6 一个Set实用工具 15.5 匿名内部类 15.6 构建复杂模型 15.7 擦除的神秘之处 15.7.1 C++的方式 15.7.2 迁移兼容性 15.7.3 擦除的问题 15.7.4 边界处的动作 15.8 擦除的补偿 15.8.1 创建类型实例 15.8.2 泛型数组 15.9 边界 15.10 通配符 15.10.1 编译器有多聪明 15.10.2 逆变 15.10.3 无界通配符 15.10.4 捕获转换（通配符捕获） 15.11 问题 15.11.1 任何基本类型都不能作为类型 15.11.2 实现参数化接口 15.11.3 转型和警告 15.11.4 重载 15.11.5 基类劫持了接口 15.12 自限定的类型 15.12.1 古怪的循环泛型 15.12.2 自限定 15.12.3 参数协变 15.13 动态类型安全 15.14 异常 15.15 混型 15.15.1 C++中的混型 15.15.2 与接口混合 15.15.3 使用装饰器模式 15.15.4 与动态代理混合 15.16 潜在类型机制 15.17 对缺乏潜在类型机制的补偿 15.17.1 反射 15.17.2 将一个方法应用于序列 15.17.3 当你并为碰巧拥有正确的接口时 15.17.4 用适配器仿真潜在类型机制 15.18 将函数对象用作策略 15.19 总结：转型真的如此之糟吗？ 15.19.1 进阶读物 第16章 数组 16.1 数组为什么特殊 16.2 数组是第一级对象 16.3 返回一个数组 16.4 多维数组 16.5 数组与泛型 16.6 创建测试数据 16.6.1 Arrays.fill() 16.6.2 数据生成器 16.6.3 从Generator中创建数组 16.7 Arrays实用功能 16.7.1 复制数组 16.7.2 数组的比较 16.7.3 数组元素的比较 16.7.4 数组排序 16.7.5 在已排序的数组中查找 16.8 总结 第17章 容器深入研究 17.1 完整容器分类法 17.2 填充容器 17.2.1 一种Generator解决方案 17.2.2 Map生成器 17.2.3 使用Abstract类 17.3 Collection的功能方法 17.4 可选操作 17.4.1 未获支持的操作 17.5 List的功能方法 17.6 Set和存储排序 17.6.1 SortedSet 17.7 队列 17.7.1 优先级队列 17.7.2 双向队列 17.8 理解Map 17.8.1 性能 17.8.2 SortedMap 17.8.3 LinkedHashMap 17.9 散列与散列码 17.9.1 理解hashCode() 17.9.2 为速度而散列 17.9.3 覆盖hashCode() 17.10 选择接口的不同实现 17.10.1 性能测试框架 17.10.2 对List的选择 17.10.3 微基准测试的危险 17.10.4 对Set的选择 17.10.5 对Map的选择 17.11 实用方法 17.11.1 List的排序和查询 17.11.2 设定Collection或Map为不可修改 17.11.3 Collection或Map的同步控制 17.12 持有引用 17.12.1 WeakHashMap 17.13 Java 1.0-1.1的容器 17.13.1 Vector和Enumeration 17.13.2 Hashtable 17.13.3 Stack 17.13.4 BitSet 17.14 总结 第18章 Java IO系统 18.1 File类 18.1.1 目录列表器 18.1.2 目录实用工具 18.1.3 目录的检查及创建 18.2 输入（Input）和输出（Output） 18.2.1 InputStream类型 18.2.2 OutputStream类型 18.3 添加属性和有用的接口 18.3.1 通过FilterInputStream从InputStream读取数据 18.3.2 通过FilterOutputStream从OutputStream写入 18.4 Reader和Writer 18.4.1 数据的来源和去处（字节流和字符流类库的关联） 18.4.2 更改流的行为 18.4.3 未发生变化的类 18.5 自我独立的类：RandomAccessFile 18.6 IO流的典型使用方式 18.6.1 缓冲输入文件 18.6.2 从内存输入 18.6.3 格式化的内存输入 18.6.4 基本的文件输出 18.6.5 存储和恢复数据 18.6.6 随机读写访问文件 18.6.7 管道流 18.7 文件读写的实用工具 18.7.1 读取二进制文件 18.8 标准IO 18.8.1 从标准输入中读取 18.8.2 将System.out转换成PrintWriter 18.8.3 标准IO重定向 18.9 进程控制 18.10 新IO 18.10.1 转换数据 18.10.2 获取基本类型 18.10.3 视图缓冲器 18.10.4 用缓冲器操纵数据 18.10.5 缓冲器的细节 18.10.6 内存映射文件 18.10.7 文件加锁 18.11 压缩 18.11.1 用GZIP进行简单压缩 18.11.2 用Zip进行多文件保存 18.11.3 Java档案文件 18.12 对象序列化 18.12.1 寻找类 18.12.2 序列化的控制 18.12.3 使用“持久性” 18.13 XML 18.14 Preferences 18.15 总结 第19章 枚举类型 19.1 基本enum特性 19.1.1 将静态导入用于enum 19.2 向enum中添加新方法 19.2.1 覆盖enum的方法 19.3 switch语句中的enum 19.4 values()的神秘之处 19.5 实现而非继承 19.6 随机选取 19.7 使用接口组织枚举 19.8 使用EnumSet替代标志 19.9 使用EnumMap 19.10 常量相关的方法（枚举类的抽象方法） 19.10.1 使用enum的职责链 19.10.2 使用enum的状态机 19.11 多路分发 19.11.1 使用enum分发 19.11.2 使用常量相关的方法 19.11.3 使用EnumMap分发 19.11.4 使用二维数组 19.12 总结 第20章 注解 20.1 基本语法 20.1.1 定义注解 20.1.2 元注解 20.2 编写注解处理器 20.2.1 注解元素 20.2.2 默认值限制 20.2.3 生成外部文件 20.2.4 注解不支持继承 20.2.5 实现处理器 20.3 使用apt处理注解 20.4 将观察者模式用于apt 20.5 基于注解的单元测试 20.5.1 将@Unit用于泛型 20.5.2 不需要任何“套件” 20.5.3 实现@Unit 20.5.4 移除测试代码 20.6 总结 第21章 并发 21.1 并发的多面性 21.2 基本的线程机制 21.3 共享受限资源 21.4 终结任务 21.5 线程之间的协作 21.6 死锁 21.7 新类库中的构件 21.8 仿真 21.9 性能调优 21.10 活动对象 21.11 总结 第22章 图形化用户界面 第1章 面向对象导论面向对象程序设计（Object-oriend Programming，OOP）。本章将介绍包括开发方法概述在内的&thinsp;OOP&thinsp;的基本概念。 相关资料：🗎[1]🗎[2] 基础概念面向对象程序设计（OOP）是一种具有对象概念的程序编程规范，同时也是一种程序开发的抽象方针。 它可以包含数据、属性、代码&thinsp;与&thinsp;方法。 在面向对象程序设计（OOP）中，计算机程序会被设计成彼此相关的&thinsp;对象。 这种在程序中包含各种独立而又相互调用的对象的思想，与传统编程思想正好相反：传统的程序设计主张把程序看成一系列函数的集合，或者直接对计算机下达的指令。 OOP&thinsp;中的每个对象都应该能接受和处理数据，并且能将数据传达给其他对象。 OOP = 对象 + 类 + 继承 + 多态 + 消息，其中的核心概念是类和对象。 其中，对象&thinsp;指的是&thinsp;类的实例。 对象是程序的基本单元，将程序的数据封装在其中，以提高软件的重用性、灵活性和拓展性。对象里的程序可以访问和修改该对象相关联的数据。 主要特征：封装性、继承性、多态性 封装性：封装是指将计算机程序的数据，以及此数据相关的一切操作语言（即描述对象的属性和行为的代码）组装到一起，一并封装到一个有机实体（也就是“类”）中。 封装的最基本单位是对象。 封装增强了软件结构的模块性，是软件在结构上实现“高内聚，低耦合”的基础。 封装的原则：隐藏对象的属性和实现细节，仅对外提供公共访问方式。 封装的好处： （1）高内聚：将变化隔离，提高安全性； （2）低耦合：便于使用，提高重用性。 继承性：继承是一种多种类之间的联系和区别关系。在面向对象中，继承是指一类对象针对另一类对象的某些特点和能力进行复制或者延续。 父类又称为基类、超类；子类又称为派生类。子类可以直接访问父类中的非私有的属性和行为。关键字为extends。 按照继承源进行划分，继承可以分为单继承和多继承。 按照继承中包含的内容进行划分，继承可以分为4类，分别为取代继承、包含继承、受限继承、特化继承。 继承的好处： 多态性：在面向对象技术中—— 从宏观角度来讲，多态是指当不同的对象同时接收到同一个完全相同的消息时，所表现出来的动作是各不相同的，具有多种形态。 从微观角度来讲，多态是指在一个类中，调用同一个函数名，使用不同的参数（注：参数列表，包括参数数量和参数类型），得到不同的执行效果。 多态实现的前提条件： （1）有继承关系； （2）有方法重写； （3）有父类引用指向子类对象。 多态有三种体现形式： （1）类多态； （2）抽象类多态； （3）接口多态。 多态的优点：提高软件的拓展性和可维护性。 多态的缺点（？）：父类引用不能使用子类特有的功能。 多态在类型转换中的体现： （1）基本类型：隐式转换（小到大），强制转换（大到小）； （2）引用类型：向上转型（小到大），向下转型（大到小）。 设计优点面向对象出现以前，结构化程序设计是程序设计的主流，结构化程序设计又称为面向过程的程序设计。在面向过程程序设计中，问题被看作一系列需要完成的任务，函数（在此泛指例程、函数、过程）用于完成这些任务，解决问题的焦点集中于函数。其中函数是面向过程的，即它关注如何根据规定的条件完成指定的任务。 比较面向对象程序设计和面向过程程序设计，还可以得到面向对象程序设计的其他优点： 数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少甚至避免对外界的干扰； 通过继承大幅减少冗余的代码，并可以方便地扩展现有代码，提高编码效率，也减低了出错概率，降低软件维护的难度； 结合面向对象分析、面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中中间环节的转换过程； 通过对对象的辨别、划分可以将软件系统分割为若干相对为独立的部分，在一定程度上更便于控制软件复杂度； 以对象为中心的设计可以帮助开发人员从静态（属性）和动态（方法）两个方面把握问题，从而更好地实现系统； 通过对象的聚合、联合可以在保证封装与抽象的原则下实现对象在内在结构以及外在功能上的扩充，从而实现对象由低到高的升级。 设计缺陷 运行效率较低。 类的大量加载会牺牲系统性能，降低运行速度。虽然CPU速度在提高，内存容量在增加，但这一问题仍会随着系统规模变大而逐渐显示出来，变得越发严重。 类库庞大。 由于类库都过于庞大，程序员对它们的掌握需要一段时间，从普及、推广的角度来看，类库应在保证其功能完备的基础上进行相应的缩减。 类库可靠性。 越庞大的系统必会存在我们无法预知的问题隐患，程序员无法完全保证类库中的每个类在各种环境中百分之百的正确，当使用的类发生了问题，就会影响后续工作，程序员也有可能推翻原来的全部工作。 名词解释 面向对象程序设计中的概念主要包括：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递。通过这些概念面向对象的思想得到了具体的体现。 （1）对象（Object）： 可以对其做事情的一些东西。对象有3种属性：状态、行为、标识。 （2）类（Class）： 一个共享相同结构和行为的对象的集合。类（Class）定义了一件事物的抽象特点。通常来说，类定义了事物的属性和它可以做到的（它的行为）。举例来说，“狗”这个类会包含狗的一切基础特征，例如它的孕育、毛皮颜色和吠叫的能力。类可以为程序提供模版和结构。一个类的方法和属性被称为“成员”。 （3）封装（Encapsulation）： 第一层意思：将数据和操作捆绑在一起，创造出一个新的类型的过程。第二层意思：将接口与实现分离的过程。 （4）继承： 类之间的关系，在这种关系中，一个类共享了一个或多个其他类定义的结构和行为。继承描述了类之间的“是一种”关系。子类可以对基类的行为进行扩展、覆盖、重定义。 （5）组合： 既是类之间的关系也是对象之间的关系。在这种关系中一个对象或者类包含了其他的对象和类。 （6）多态： 类型理论中的一个概念，一个名称可以表示很多不同类的对象，这些类和一个共同超类有关。因此，这个名称表示的任何对象可以以不同的方式响应一些共同的操作集合。 （7）动态绑定： 也称动态类型，指的是一个对象或者表达式的类型直到运行时才确定。通常由编译器插入特殊代码来实现。与之对立的是静态类型。 （8）静态绑定： 也称静态类型，指的是一个对象或者表达式的类型在编译时确定。 （9）消息传递： 指的是一个对象调用了另一个对象的方法（或者称为成员函数）。 （10）方法： 也称为成员函数，是指对象上的操作，作为类声明的一部分来定义。方法定义了可以对一个对象执行那些操作。 第1章-1 抽象过程所有编程语言都提供抽象机制。可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。所谓的“类型”指的是“所抽象的是什么”。 汇编语言是对底层机器的轻微抽象。接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。…… 另一种对机器建模的方式就是只针对待解决问题建模。…… 面向对象方式通过向程序员提供表示问题空间中的元素的工具而更近了一步。…… Alan Kay&thinsp;曾经总结了第一个[成功的面向对象语言、同时也是&thinsp;Java&thinsp;所基于的语言之一的&thinsp;Smalltalk&thinsp;的]五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式： (1)&ensp;万物皆为对象。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件（示例：狗、建筑物、服务等），将其表示为程序中的对象。 (2)&ensp;程序是对象的集合，它们通过发送消息来告知彼此所要做的。…… (3)&ensp;每个对象都有自己的由其他对象所构成的存储。…… (4)&ensp;每个对象都拥有其类型。…… (5)&ensp;某一特定类型的所有对象都可以接收同样的消息。…… Booch&thinsp;对&thinsp;对象&thinsp;提供了一个更加简洁的描述：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（它们给出了该&thinsp;对象的状态）和方法（它们产生&thinsp;对象的行为），并且每一个对象都可以唯一地与其他对象区分开来（标识），具体说来，就是每一个对象在其内存中都有一个唯一的地址。 第1章-2 每个对象都有一个接口亚里士多德是第一个深入研究类型（type）的哲学家，他曾提出过鱼类和鸟类这样的概念。所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所属的类的一部分。这种思想被直接应用于第一个面向对象语言&thinsp;Simula-67，它在程序中使用基本关键字class来引入新的类型。 Simula，就像其名字一样，是为了开发诸如经典的“银行出纳员问题”（bank teller problem）这样的仿真程序而创建的。…… 所以，尽管我们在面向对象程序设计中实际上进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用class这个关键词来表示数据类型。……因为类（class）描述了相同特性（数据元素）和行为（功能）的对象集合，所以一个类（class）实际上就是一个数据类型，例如所有的浮点型数字都具有相同的特性和行为集合。………… UML（Unified Modelling Language，统一建模语言）形式的图，…… 第1章-3 每个对象都提供服务…… 第1章-4 被隐藏的具体实现将程序开发人员按照角色分为类创建者（创建新数据类型的程序员）和客户端程序员（在应用程序中使用数据类型的类消费者）是大有裨益的。客户端程序员的目标，是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，同时隐藏其他部分。构建类的只向客户端程序员暴露必需部分而隐藏其他部分的设计，能保证类的稳定安全，避免人为攻击，减少程序&thinsp;Bug。 明确边界：在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。…… 因此，访问控制的存在原因： （1）让客户端程序员无法触及他们不应该接触的部分&thinsp;——&thinsp;这部分对数据类型的内部操作是必需的，但是对于解决问题所需的接口的一部分。 （2）允许库设计者可以改变&thinsp;类内部&thinsp;的工作方式，同时不用担心会影响到客户端程序员。 Java&thinsp;用3个关键字在类的内部设定边界：public，private，protected。这些访问指定词（access specifier）决定了紧跟其后被定义的东西可以被谁使用。……Java&thinsp;还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为&thinsp;包访问权限，在这种权限下，类可以访问在同一个包中的其他类的成员。 第1章-5 复用具体实现一旦类被设计创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。……。代码复用是面向对象程序设计语言提供的最了不起的优点之一。 最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为“创建一个成员对象”。新的类可以由任意数量、任意类型的其他对象，以任意可以实现新的类中想要的功能的方式所组成。…… …… 第1章-6 继承对象这种概念，本身就是十分方便的工具，方便你通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于&thinsp;必须使用底层机器语言。这些概念用关键字class来表示，它们形成了编程语言中的基本单位。 当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括&thinsp;现有类型的所有成员（尽管private成员被隐藏了起来，并且不可被访问），而且更重要的是它复制了&thinsp;基类的接口。也就是说，所有可以发送给基类对象的消息同时也能发送给派生类对象。由于通过发送给类的消息类型可以判断类的类型，所以派生类与基类具有相同的类型。 …… 第1章-6-1 “是一个”与“像是一个”的关系对于继承可能会引发某些争论：继承是否应该只覆盖基类的方法，而并不添加在基类中没有的新方法？ 略（原文此处论述太过智障）。 第1章-7 伴随多态的可互换对象在处理类型的层次结构时，经常想把一个对象不当作的它所属的特定类型来看待，而是将其当作其基类的对象来处理。这使得程序员可以编写出不依赖于特定类型的代码。 泛化（generic），涉及到向上转型。泛化处理的负面作用是导致编译器无法明确实际执行的代码，而代码的执行只能在编译完成后运行时才能确定。 因为面向对象程序设计语言使用了&thinsp;后期绑定&thinsp;的概念——当向对象发送消息时，被调用的代码直到运行时才能确定：编译器确保被调用的方法的存在，并对调用参数和返回值执行类型检查（无法提供此类语言保证的语言被称为&thinsp;弱类型语言），但是不能确定将被执行的确切代码。 为了执行&thinsp;后期绑定，Java&thinsp;使用一小段特殊的代码来替代绝对地址调用。这段代码使用在对象中存储的信息来计算方法体的地址（这个过程将在第八章中体现）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道通过这条消息应该做什么。 在某些语言中，必须明确地声明某个方法具备后期绑定属性所带来的灵活性（C++是使用virtual关键字来实现的）。在这些语言中，方法在默认情况下不是动态绑定的。而在&thinsp;Java&thinsp;中，动态绑定是默认行为，不需要添加额外的关键字来实现多态。 示例：多态的表现 - 示例 第1章-8 单根继承结构 在&thinsp;OOP（面向对象编程）中，自&thinsp;C++&thinsp;面世以来就令人关注的一个问题：是否所有的类最终都继承自同一个基类。在&thinsp;Java&thinsp;中（事实上还包括&thinsp;C++&thinsp;以外的所有&thinsp;OOP&thinsp;语言），答案是&thinsp;yes &ensp; ，这个终极基类是&thinsp;Object。 事实证明，单根继承结构&thinsp;带来了很多好处。 在&thinsp;单根继承结构&thinsp;中，所有对象都具有一个共用接口，所以它们归根结底都是相同的基本类型。 单根继承结构&thinsp;保证所有对象都具备某些功能，可以在每个对象上执行基本操作。所有对象都很容易地在[&thinsp;堆（Heap）]上创建，同时&thinsp;参数的传递&thinsp;也被极大地简化。 单根继承结构&thinsp;使得垃圾回收器的实现变得容易很多，而垃圾回收器正是&thinsp;Java&thinsp;相对&thinsp;C++&thinsp;的重要改进之一。由于所有对象都保证具有其自身的类型信息，因此不会因为无法确定对象的类型而陷入僵局；这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。 在另一种（C++所提供的）非单根继承结构中…… 在另一种（C++所提供的）非单根继承结构中，无法确保所有的对象都属于同一个基本类型，从向后兼容的角度来看，这么做能够更好地适应C模型，且受限较少；除此以外不值得…… 第1章-9 容器第1章-9-1 参数化类型第1章-10 对象的创建和生命周期第1章-11 异常处理：错误处理第1章-12 并发编程第1章-13 Java与Internet第1章-13-1 Web是什么第1章-13-2 客户端编程第1章-13-3 服务器端编程第1章-14 总结第2章 一切都是对象第2章-1 用引用操纵对象 每种编程语言都会有自己的操纵内存中元素的方式。很多时候，程序员必须注意将要处理的数据是什么类型。是选择直接操纵元素，还是用某种基于特殊语法的间接表示（）来操纵对象？ 所有这一切在&thinsp;Java&thinsp;里得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操纵的标识符实际上是对象的一个“引用”（reference） 第2章-2 必须由你创建所有对象【底层存储】一旦创建了一个引用，我们通常希望它能够与一个新的对象关联。通常使用new操作符来实现这一目的。new关键字的意思是“分配一个新对象”。 上述代码不仅表示“分配一个新的字符串”，还通过给构造方法提供的初始字符串，确定了如何构建这个String对象的信息。 这是&thinsp;Java&thinsp;程序设计中的一项基本行为。 第2章-2-1 存储到什么地方【对象的存储】 程序运行时…… 程序运行时，对象是怎么进行存放安排的呢？特别是内存是怎样分配的呢？对这些方面的了解对程序员会有很大的帮助。 有五个不同的地方可以存储数据： 寄存器。位于&thinsp;处理器内部。 这是&thinsp;最快的存储区。因为它位于不同于其他存储区的地方&thinsp;——&thinsp;处理器内部。 但是&thinsp;寄存器的数量&thinsp;极其有限，所以寄存器&thinsp;根据需求进行分配，且&thinsp;Java&thinsp;不允许程序员直接或间接地控制寄存器，甚至屏蔽寄存器的存在概念。⤴&ensp;（另一方面，C&thinsp;和&thinsp;C++&thinsp;允许程序员向编译器建议寄存器的分配方式） 堆栈（Heap）。位于通用&thinsp;RAM（随机访问存储器）&thinsp;中。 通过&thinsp;堆栈指针&thinsp;可以从&thinsp;处理器&thinsp;那里获得&thinsp;直接支持。 堆栈指针，若向下移动，则分配新的内存；若向上移动，则释放已分配的内存。 堆栈（Heap）是一个快速存储区域，存取效率仅次于&thinsp;寄存器。 堆栈（Heap）中存放的数据&thinsp;必须明确其&thinsp;数据大小&thinsp;和&thinsp;生命周期&thinsp;，导致&thinsp;堆栈（Heap）区&thinsp;的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作不灵活。 在&thinsp;Java&thinsp;中，堆栈（Heap）用来存放&thinsp;基本类型数据&thinsp;和&thinsp;对象的引用（对象句柄）。 堆（Stack）。位于&thinsp;RAM&thinsp;中；是一种&thinsp;通用内存池。 堆（Stack）中的数据不需要明确&thinsp;数据大小&thinsp;和&thinsp;生命周期，相比于&thinsp;堆栈（Heap）&thinsp;具有很好的灵活性。 但相应的代价是：堆（Stack）的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作，相比于&thinsp;堆栈（Heap），速度慢很多。 在&thinsp;Java&thinsp;中，堆（Stack）用于存放&thinsp;所有的&thinsp;Java&thinsp;对象。 常量存储（常量池）。通常位于&thinsp;程序代码内部，随着&thinsp;JDK&thinsp;的迭代而存在不同的设计。（另外在嵌入式系统中，常量会和其他部分隔离，此时可以选择&thinsp;ROM&thinsp;作为常量存储区） 常量存储（常量池）位于&thinsp;堆（Heap）&thinsp;中。 JDK&thinsp;7&thinsp;之前的版本 运行时常量池&thinsp;是&thinsp;方法区&thinsp;的一部分。Class文件中除了有&thinsp;类的版本、字段、方法、接口&thinsp;等描述信息外，还有&thinsp;常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然&thinsp;运行时常量池&thinsp;是&thinsp;方法区&thinsp;的一部分，自然受到&thinsp;方法区内存&thinsp;的限制，当&thinsp;常量池&thinsp;无法再申请到内存时会抛出OutOfMemoryError异常。 JDK&thinsp;7&thinsp;及之后的版本 JDK&thinsp;7&thinsp;及之后的版本中，JVM&thinsp;已经将&thinsp;运行时常量池&thinsp;从&thinsp;方法区&thinsp;中移了出来，并在&thinsp;堆（Heap）&thinsp;中开辟了一块区域存放&thinsp;运行时常量池。 常量存储（常量池）&thinsp;用于存储&thinsp;常量。⤷&ensp;因为常量是永远不会被改变的，所以&thinsp;Java&thinsp;中将&thinsp;常量池&thinsp;设置在&thinsp;程序内部&thinsp;的设计是安全的。 非RAM存储。在&thinsp;非&thinsp;RAM&thinsp;存储&thinsp;中，存储的数据的生命周期不受程序本身的生命周期影响。⤷&ensp;其中两个基本的例子是&thinsp;流对象&thinsp;和&thinsp;持久化对象。 在&thinsp;流对象&thinsp;中，对象被转化为字节流（Bit Stream）；通常被发送给另一台机器。 在&thinsp;持久化对象&thinsp;中，对象被存放于磁盘上，对象的存储形式与其存储媒介有关。⤷&ensp;在需要时，可以将&thinsp;持久化对象&thinsp;从&thinsp;具体的存储形式&thinsp;恢复成&thinsp;常规的、基于&thinsp;RAM&thinsp;的对象。 Java 提供了对&thinsp;轻量级持久化&thinsp;的支持…… Java&thinsp;提供了&thinsp;对&thinsp;轻量级持久化&thinsp;的支持。诸如&thinsp;JDBC&thinsp;和&thinsp;Hibernate&thinsp;这样的机制，提供了&thinsp;更加复杂的、对数据库中的对象信息的&thinsp;存取支持。 第2章-2-2 特例：基本类型基本类型对象&thinsp;直接存储“值”，而不是引用；基本类型对象直接存储于&thinsp;堆栈（Heap）&thinsp;中，所以其所占空间大小是确定的。 Java&thinsp;要确定每种&thinsp;基本类型&thinsp;所占空间大小。它们的大小不会随着机器硬件架构的变化而变化，这种&thinsp;所占存储空间大小的不变性&thinsp;是&thinsp;Java&thinsp;可移植性&thinsp;好的原因之一。 基本类型 中文名称 数据大小(单位：位) 最小值 最大值 对应包装器类型 boolean 布尔型 —— —— —— Boolean char 字符型 16 bit Unicode 0 Unicode 2^16-1 Character byte 字节型 8 bit -2^7（-128） +2^7-1（127） Byte short 短整型 16 bit -2^15 +2^15-1 Character int 整型 32 bit -2^31 +2^31-1 Integer long 长整型 64 bit -2^63 +2^63-1 Long float 浮点型 32 bit IEEE754 IEEE754 Character double 双精度浮点型 64 bit IEEE754 IEEE754 Double void 字符型 —— —— —— Void boolean&thinsp;类型所占空间大小没有明确地指定，仅定义为能够取字面值true或false。 所有的&thinsp;数值类型&thinsp;都有&thinsp;符号，所以不要去寻找无符号的&thinsp;数值类型。 第2章-2-3 Java中的数组第2章-3 永远不需要销毁对象第2章-4 创建新的数据类型第2章-5 方法、参数和返回值第2章-6 构建一个Java程序第2章-7 你的第一个Java程序第2章-8 注释和嵌入式文档第2章-9 编码风格第2章-10 总结第2章-11 练习第3章 操作符在最底层，Java&thinsp;中的数据是通过使用&thinsp;操作符&thinsp;来操作的。 第3章-1 更简单的打印语句第3章-2 使用Java操作符 操作符&thinsp;接受一个或多个&thinsp;参数，并生成一个新值。 参数的形式&thinsp;与普通的&thinsp;方法调用&thinsp;不同，但效果是相同的。 加号和一元的正号+、减号和一元的负号-、乘号*、除号/以及赋值号=的用法与其他编程语言类似。 操作符&thinsp;用于操作&thinsp;数，生成一个新值。 另外，有些操作符可能会改变&thinsp;操作数自身的值，这被称为“副作用”。 那些能改变其操作数的操作符，最普遍的用途就是用来产生副作用；但要记住，使用此类操作符生成的值，与使用无副作用的操作符生成的值，没有什么区别。 几乎所有的&thinsp;操作符&thinsp;都只能操作“基本类型”。 例外的操作符是=、==和!=：这些操作符能操作所有的对象（这也是&thinsp;对象&thinsp;易令人糊涂的地方）。 除此之外，String类支持+和+=：操作String类的+和+=意味着字符串拼接，并且如果必要（被操作的对象不属于String类），编译器会先尝试将非String类型的对象转换为String类型对象，再进行字符串拼接的操作。 注意：操作String类型对象的+和+=操作符，必须要小心使用（…），显式执行（？），杜绝在&thinsp;循环体&thinsp;中使用+=操作String造成内存的不可控使用（最坏结果：内存溢出）。 第3章-3 优先级 当一个&thinsp;表达式&thinsp;中存在多个&thinsp;操作符&thinsp;时，操作符的优先级&thinsp;就决定了各部分的计算顺序。Java&thinsp;对&thinsp;计算顺序&thinsp;做了特别的规定。 第3章-4 赋值第3章-4.1 方法调用中的别名问题第3章-5 算数操作符第3章-5-1 一元加减操作符第3章-6 自动递增和递减第3章-7 关系操作符 关系操作符生成的是一个boolean（布尔）类型结果，计算的是&thinsp;操作数的值之间的关系。如果关系是真实的，则关系表达式会生成true（真），否则生成false（假）。 关系操作符包括：小于&lt;、大于&gt;、小于或等于&lt;=、大于或等于&gt;=、等于==、不等于!=。 其中等于==、不等于!=适用于所有的&thinsp;基本数据类型，而其他比较符适用于&thinsp;除boolean类型以外的&thinsp;基本数据类型。 因为boolean值只能为true或false，对于&thinsp;大于&thinsp;和&thinsp;小于&thinsp;的逻辑来说没有实际意义。 第3章-7-1 测试对象的等价性关系操作符==和!=适用于所有对象。 注意：关系运算符&thinsp;比较的是&thinsp;对象的值。 若要比较&thinsp;对象的引用，可以使用&thinsp;对象的equals方法（来自Object）实现。 第3章-8 逻辑操作符 逻辑操作符：与&amp;&amp;、或||、非!。 逻辑操作符&thinsp;能根据&thinsp;参数的逻辑关系，生成一个&thinsp;布尔值boolean（true或false）。 在&thinsp;Java&thinsp;中，逻辑操作符（与&amp;&amp;、或||、非!）只可应用于&thinsp;布尔值boolean。 而在&thinsp;C&thinsp;和&thinsp;C++&thinsp;中，不可将一个&thinsp;布尔值&thinsp;当做&thinsp;非布尔值&thinsp;在&thinsp;逻辑表达式&thinsp;中使用。 注意：如果在使用String值的地方使用布尔值，该布尔值会自动转换为String形式。 第3章-8-1 短路当使用逻辑运算符时，我们会遇到一种“短路”现象：一旦能够明确无误地确定&thinsp;整个表达式的值，就不再计算表达式的余下部分。 示例： 【应用】我们可以借助“短路”这种设计，节省不必要的代码，使业务逻辑的实现（在编码层面）更精简方便。 第3章-9 直接常量第3章-9-1 指数记数法第3章-10 按位操作符第3章-11 移位操作符第3章-12 三元操作符if-else第3章-13 字符串操作符+和=第3章-14 使用操作符时常犯的错误第3章-15 类型转换操作符第3章-15-1 截尾和舍入第3章-15-2 提升第3章-16 Java没有sizeof第3章-17 操作符小结第3章-18 总结第4章 控制执行流程第5章 初始化与清理随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。初始化&thinsp;和&thinsp;清理（cleanup）&thinsp;正是涉及安全的两个问题。 许多&thinsp;C&thinsp;程序的错误都源于程序员忘记&thinsp;初始化变量。特别是在使用程序库，且用户不知道如何正确地初始化库的构件（或者是必须初始化的其他东西）时，更是如此。 清理&thinsp;也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记，导致这个元素占用的资源一直得不到释放，最终结果是资源（尤其是内存）用尽。 C++&thinsp;引入了&thinsp;构造器（constructor）&thinsp;的概念，这是一个&thinsp;在创建对象时&thinsp;被自动调用的特殊方法。Java&thinsp;中也采用了&thinsp;构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。 本章就讨论&thinsp;初始化&thinsp;和&thinsp;清理&thinsp;的相关问题，以及&thinsp;Java&thinsp;对它们的支持。 第5章-1 用构造器确保初始化 可以假想为编写的每个类都定义一个initialize()方法，该方法的名称提醒你在使用其对象之前，应首先调用initialize()。然而，这同时意味着用户必须记得自己去调用此方法。 在&thinsp;Java&thinsp;中，通过提供构造器，类的设计者可以确保每个对象都会得到初始化。创建对象时，如果其类具有构造器，Java&thinsp;就会在用户能够操作对象之前自动调用相应的构造器，从而保证了初始化的顺利进行。 接下来的问题就是如何命名这个方法，2个考虑点：①&ensp;构造器按照方法命名规范所取的任何名字，都可能与类的某个成员名称冲突；②&ensp;调用构造器是编译器的责任，所以必须让编译器知道构造器对应哪一个方法。 C++&thinsp;中采用了的解决方案看起来是最简单且更符合逻辑的，所以&thinsp;Java&thinsp;中也采用了这种方案：构造器采用与类相同的名称（符合类的命名规范，但不符合方法的命名规范）。 注意，由于构造器名称必须与类名完全一致，所以“每个方法首字母小写”的编码风格并不适用于构造器。 以下是一个带有构造器的简单类…… 以下是一个带有构造器的简单类：……现在，在创建对象时： 将会为对象分配存储空间，并调用相应的构造器。这就保证了在你能操作对象之前，它已经被恰当地初始化了。 默认构造器（无参构造器）：不接收形式参数的构造器。 有参构造器。如果Tree(int)是Tree类中唯一的构造器，那么编译器将不会允许你以其他任何方式创建Tree对象。 构造器&thinsp;有助于减少错误，并使代码更易阅读。从概念上讲，“初始化”与“创建”是彼此独立的，然而在上面的代码中，你却找不到对initialize()方法的明确调用。在&thinsp;Java&thinsp;中，“初始化”和“创建”是捆绑在一起，不可分离的。 构造器&thinsp;是一种特殊类型的方法，因为它没有返回值。这与&thinsp;返回值为空（void）&thinsp;明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西；构造器&thinsp;则不会返回任何东西，你别无选择（new&thinsp;表达式确实返回了对新建对象的引用，但构造器本身并没有返回任何值）。假如构造器具有返回值，并且允许程序员自行选择返回类型，那么势必得让编译器知道该如何处理此返回值。 第5章-2 方法重载 任何程序设计语言都具备一项重要特性，就是对名字的运用。 当创建一个对象时，也就是给这个对象分配到的存储空间取了一个名字。 所谓方法就是给某个动作取的名字。 通过使用名字，你可以引用所有的对象和方法。 名字起的好可以更易于理解和修改。 第5章-3 默认构造器默认构造器（又称&thinsp;无参构造器）是没有形式参数的，它的作用是创建一个默认对象。 如果一个类中没有构造器，则编译器会自动创建一个该类的默认构造器；而如果类中已经定义了构造器（无论是否有参数），则编译器不会再为该类创建默认构造器。 第5章-4 this关键字方法调用时，往往需要指定&thinsp;对象（static方法&thinsp;还可以直接指定&thinsp;类class）。 示例： …… 同一个类型的对象，a&thinsp;和&thinsp;b，想要让它们都能调用同一个方法peel()，该如何实现？ 在&thinsp;Java&thinsp;中，使用了简便且面向对象的语法来编写代码 —— 即“发送消息给对象”，编译器做了一些幕后处理 —— 它将“所操作对象的引用”作为第一个&thinsp;参数&thinsp;传递给&thinsp;方法。 所以，示例中的方法调用代码可以如下解释： ↓ 以下是内部的表现形式（注意：不符合编码规范，编译会报错） this&thinsp;关键字为此而生，它表示对“调用方法的那个对象”的引用，且只能在&thinsp;方法内部&thinsp;使用（指代发起方法调用时，该方法对应的对象）。 this&thinsp;的用法与其他对象引用并无不同。注意，如果在方法内部调用同一个类的另一个方法，不必使用&thinsp;this，直接调用即可。 只有当需要明确指出对当前对象的引用时，才需要使用&thinsp;this&thinsp;关键字。例如，当需要返回对当前对象的引用时，就可以这样写：…… this&thinsp;引用对于将当前对象传递给其他方法也很有用。…… 第5章-4-1 在构造器中调用构造器调用形式：this(参数类型列表) 例子： …… 在&thinsp;构造器&thinsp;中，最多只能调用一次&thinsp;构造器。（否则编译报错） 在&thinsp;构造器&thinsp;中，[&thinsp;调用构造器&thinsp;的代码&thinsp;]&thinsp;必须在&thinsp;最开始的地方。（否则编译报错） 这个例子中也展示了&thinsp;this&thinsp;的另一种用法&ensp;——&ensp;避免歧义。 由于参数s的名称和数据成员s的名称相同，同时使用会产生歧义；使用this.s来代表数据成员就能解决这个问题。 第5章-4-2 static的含义了解this关键字以后，就能更好地理解static（静态）方法的含义。 static方法&thinsp;中不能使用&thinsp;this。 使用static方法时，由于不存在this，所以它不是通过“向对象发送消息”来完成的。 static方法&thinsp;中不能（直接）调用&thinsp;非静态方法&thinsp;和&thinsp;非静态对象（涉及到底层加载顺序）；而&thinsp;非静态方法&thinsp;中可以调用&thinsp;静态方法&thinsp;和&thinsp;静态对象。 static方法&thinsp;的&thinsp;加载&thinsp;是依附于&thinsp;类class&thinsp;而不是&thinsp;类的对象Object：可以在没有创建任何对象的前提下，通过&thinsp;类本身&thinsp;来调用static方法，这正是static方法&thinsp;的主要用途。 static方法很像&thinsp;全局方法；Java&thinsp;中禁止使用全局方法，但你在static方法中就能访问其他static方法&thinsp;和&thinsp;static域。 第5章-5 清理：终结处理和垃圾回收在&thinsp;Java&thinsp;中，有&thinsp;垃圾回收器&thinsp;负责回收无用对象占据的内存资源。但也有特殊情况，由于&thinsp;垃圾回收器&thinsp;只能释放那些经由new分配的内存，所以那些不使用new获得的特殊内存将不会被垃圾回收器正常处理释放。 为了应对这种情况，Java&thinsp;允许在类中定义一个名为finalize()的方法。…… Java&thinsp;中的&thinsp;垃圾回收： 对象&thinsp;可能不被&thinsp;垃圾回收。 垃圾回收&thinsp;不等于“析构”。 垃圾回收&thinsp;只与&thinsp;内存&thinsp;有关。 …… 第5章-5-1 finalize()的用途何在此时，已经明确了不该将finalize()作为通用的清理方法，那么finalize()真正的用途是什么呢？ 垃圾回收只与内存有关…… 第5章-5-2 你必须实施清理…… 第5章-5-3 终结条件…… 第5章-5-4 垃圾回收器如何工作…… 第5章-6 成员初始化Java&thinsp;尽力保证：所有变量在使用前都能得到恰当的&thinsp;初始化。Java&thinsp;不允许使用&thinsp;方法的局部变量。…… 方法中定义的变量&thinsp;没有初值，但是&thinsp;类的数据成员（即字段）会有&thinsp;默认值。…… 在&thinsp;类&thinsp;中定义一个&thinsp;对象引用&thinsp;时，如果不将其&thinsp;初始化，此引用会获得一个特殊值null。类中定义的&thinsp;基本数据类型，会有&thinsp;对应类型的默认值。 第5章-6-1 指定初始化第5章-7 构造器初始化可以用构造器来进行初始化。 在运行时刻，可以调用方法或者执行某些动作来确定初值，这为编程带来了极大的便利性。 但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。 因此假如使用如下代码： 那么类Test的数据成员（字段）i会首先被置为0（默认值），然后被&thinsp;构造器&thinsp;置为7。运行结果： 对于所有&thinsp;基本类型&thinsp;和&thinsp;对象引用，包括&thinsp;在定义时&thinsp;直接指定初值的变量，这种情况都是成立的。 第5章-7-1 初始化顺序在[&thinsp;类的内部&thinsp;]，变量定义的顺序&thinsp;决定了&thinsp;初始化的顺序；并且，变量的初始化（默认值）&thinsp;会在&thinsp;任何方法（包括构造器）被调用之前。 示例： …… 第5章-7-2 静态数据的初始化无论创建多少个对象，静态数据&thinsp;都只占用一份存储区域。 static关键字不能应用于&thinsp;局部变量，因此它只能作用于&thinsp;域。 如果一个&thinsp;域&thinsp;是&thinsp;静态的基本类型域，且没有被&thinsp;初始化，那么它就会被自动赋予&thinsp;默认值（基本类型 → 对应类型的默认值，引用类型 → null）。 如果想在&thinsp;定义处&thinsp;进行初始化，采取的方法和&thinsp;非静态数据&thinsp;没什么不同。 要想了解静态存储区域是何时初始化的，需要用到下面这个例子： …… ……由输出可见，静态初始化&thinsp;只有在必要时刻才会进行。…… 初始化的顺序&thinsp;是先&thinsp;静态对象（如果它们尚未因排序在前的对象创建而被初始化），而后是&thinsp;非静态对象。…… 总结一下对象创建的过程（书中的总结不够好，详见习题） 假设有个名为&thinsp;Dog&thinsp;的类： 首次创建&thinsp;类型为Dog的&thinsp;对象&thinsp;时，或者Dog类的&thinsp;，静态方法&thinsp;/&thinsp;静态域&thinsp;首次被访问时，Java&thinsp;解释器&thinsp;将会查找类的路径，定位Dog.class文件。 载入Dog.class（后面章节会提及，这将&thinsp;创建一个对象），有关&thinsp;静态初始化&thinsp;的所有动作都会执行。 因此，静态初始化&thinsp;只在Class对象&thinsp;首次加载时&thinsp;进行一次。 当用new Dog()创建对象的时候： 首先，将&thinsp;在堆上&thinsp;为Dog对象&thinsp;分配&thinsp;足够的存储空间。🡇 这块存储空间会被清零，这就自动地将Dog对象中的&thinsp;所有基本类型数据&thinsp;都设置成了&thinsp;默认值。🡇 然后，执行所有出现于&thinsp;字段定义处&thinsp;的&thinsp;初始化动作。🡇 最后，执行&thinsp;构造器。正如第7章所看到的，这可能会涉及到很多动作，尤其是涉及到&thinsp;继承&thinsp;的时候。 第5章-7-3 显式的静态初始化Java&thinsp;允许将多个&thinsp;静态初始化动作&thinsp;组织成一个特殊的“静态子句”（有时也叫做“静态块”）。 语法形式： 尽管上面的代码看起来像个方法，但它实际上只是一段跟在static关键字后面的代码；与其他初始化动作一样，这段代码仅会执行一次。 示例： …… 第5章-7-4 非静态实例初始化Java&thinsp;中也有被称为&thinsp;实例初始化&thinsp;的类似语法，用来初始化每一个对象的&thinsp;非静态变量。 示例： 输出： ⤷你可以看到&thinsp;实例初始化子句： ⤷它看起来与静态初始化子句一样，只不过少了static关键字。这种语法对于支持“匿名内部类”（参见第10章）是必须的，但是它也使得无论你调用哪个显式构造器，某些操作都会发生。 从输出中可以看到，实例初始化子句&thinsp;是在两个&thinsp;构造器&thinsp;之前执行的。 第5章-8 数组初始化数组→概念数组&thinsp;是&thinsp;用一个&thinsp;标识符名称&thinsp;封装到一起的、相同类型的&thinsp;[&thinsp;一个&thinsp;对象序列&thinsp;或&thinsp;基本类型数据序列&thinsp;]。 数组→定义和使用数组&thinsp;是&thinsp;通过方括号下标操作符[]来&thinsp;定义和使用的。 要定义一个数组…… 要定义一个数组，只需在&thinsp;类型名&thinsp;后面加上一对方括号[]即可（或许更合理）：⤵ 也可以将方括号[]置于标识符后面（符合C和C++程序员的习惯）：⤵ 数组→特点 编译器不允许指定&thinsp;数组的大小。这是因为数组是一组&thinsp;对象的引用（Java&thinsp;中&thinsp;对象引用本身&thinsp;是不变的，但是&thinsp;所引用的对象&thinsp;是可变的），所以&thinsp;声明时&thinsp;无法指定数组的成员数量，但是&thinsp;创建时&thinsp;不受限制。 所有数组都有一个&thinsp;固有成员length…… 数组初始化的3种方式 （只能在&thinsp;创建数组的地方&thinsp;使用）花括号&#123;&#125;&ensp;+&ensp;数组成员。此时存储空间的分配（等价于使用new）将由编译器负责： new&ensp;+&ensp;类型说明&ensp;+&ensp;成员数量说明： 演示： 👆 输出⤵ 示例： 👆 …… 初始化进程说明&ensp;→&ensp;此时，即便使用new创建数组之后：⤵ ⤷&ensp;它还只是一个&thinsp;引用数组，直到通过创建新的Integer对象（本例中通过&thinsp;自动包装机制&thinsp;创建），并把&thinsp;对象&thinsp;赋值给&thinsp;引用，初始化进程&thinsp;才算结束。⤵ ⤷&ensp;如果忘记了创建对象，并且试图使用数组中的空引用，就会出现运行时异常。 new&ensp;+&ensp;类型说明&ensp;+&ensp;花括号&#123;&#125;&ensp;+&ensp;数组成员：⤵ 演示： 输出：⤵ 第5章-8-1 可变参数列表 “new&ensp;+&ensp;类型说明&ensp;+&ensp;花括号&#123;&#125;&ensp;+&ensp;数组成员”形式的&thinsp;数组初始化方法，可以用于Object数组实现与&thinsp;C&thinsp;的&thinsp;可变参数列表&thinsp;一样的效果。⤵ ⤷&ensp;示例： ⤷&ensp;输出：⤵ 在&thinsp;Java&thinsp;SE&thinsp;5&thinsp;之前，通常使用上例来实现；而从&thinsp;Java&thinsp;SE&thinsp;5&thinsp;开始，提供了对&thinsp;可变参数&thinsp;的语法支持。有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上将会自动填充数组。⤵ ⤷&ensp;示例： 输出：⤵ 在&thinsp;可变参数列表&thinsp;中，可以使用&thinsp;任何类型的参数，包括&thinsp;基本类型（涉及到&thinsp;自动包装机制）。 如果&thinsp;可变参数列表&thinsp;中&thinsp;没有任何参数（包括为空），则&thinsp;参数传递时&thinsp;转变为&thinsp;数据尺寸为0的&thinsp;指定类型数组。同样，可变参数列表&thinsp;也能直接接受&thinsp;对应类型的数组（此时编译期间将不会再做不必要的数据转换）。 ⤷&ensp;示例： 输出：⤵ 可变参数列表&thinsp;不依赖于&thinsp;自动包装机制&ensp;🡄&ensp;实际上使用的是&thinsp;基本类型⤷&ensp;见示例最后一行→创建并打印出来的int数组（其中的I表示&thinsp;基本数据类型）。 然而，可变参数列表&thinsp;与&thinsp;自动包装机制&thinsp;可以和谐共处。 ⤷&ensp;示例： 输出：⤵ 注意：你可以在&thinsp;单一类型的参数列表&thinsp;中&thinsp;将类型混合在一起，而&thinsp;自动包装机制&thinsp;将有选择地将int参数提升为Integer。 可变参数列表&thinsp;使得&thinsp;重载过程&thinsp;变得复杂了，尽管乍一看似乎足够安全。 ⤷&ensp;示例： 输出：⤵ ⤷&ensp;在每一种情况中，编译器都会使用&thinsp;自动包装机制&thinsp;来匹配&thinsp;重载方法。⤷&ensp;但是在上例中，不传递参数，调用f()时，编译器就无法确定该调用哪个方法（编译不通过）。 可以考虑添加&thinsp;非可变参数&thinsp;来解决&thinsp;重载方法之间&thinsp;可变参数列表混淆&thinsp;的问题。 【设计原则】 如果是&thinsp;有必要在&thinsp;重载方法&thinsp;中使用&thinsp;可变参数列表，请保证&thinsp;至多在重载方法的一个版本中&thinsp;使用&thinsp;可变参数列表，或者不使用它。 某些情况下，可以考虑使用&thinsp;恰当类型的数组&thinsp;来替代&thinsp;可变参数列表。 第5章-9 枚举类型在&thinsp;Java&thinsp;SE&thinsp;5&thinsp;中添加了一个看似很小的新特性&ensp;——&ensp;enum关键字，它使得我们需要群组并使用&thinsp;枚举类型集&thinsp;时，可以很方便地处理。 C&thinsp;/&thinsp;C++&thinsp;都有&thinsp;枚举类型，现在&thinsp;Java&thinsp;也拥有&thinsp;枚举类型&thinsp;且比它们的要完备得多。 额外参考资料 枚举类 - 廖雪峰的官方网站 Java 中的枚举 (enum) - 简书 Java 枚举(enum) 详解7种常见的用法_请叫我大师兄-CSDN博客_枚举 第5章-9-1 枚举类（enum）——基本概念 枚举类：一种&thinsp;特殊的类，其&thinsp;实例对象&thinsp;是&thinsp;有限且固定的。 枚举类（enum）的特点 枚举类&thinsp;和普通的类（class）一样，有自己的&thinsp;成员变量、成员方法、构造器（因为&thinsp;设计时&thinsp;限定使用private访问修饰符，故无法&thinsp;从外部&thinsp;调用&thinsp;枚举类的构造器，只能&thinsp;在构造枚举值时&thinsp;调用&thinsp;对应枚举类的构造器）。 与普通类（class）一样，一个&thinsp;Java&thinsp;源文件中最多只能有一个public类型的&thinsp;枚举类，且&thinsp;该&thinsp;Java&thinsp;源文件的名称&thinsp;必须与&thinsp;该枚举类的名称&thinsp;相同。 枚举类（enum）默认继承了java.lang.Enum类，并实现了 java.lang.Seriablizable和java.lang.Comparable两个接口。 ⤷&ensp;枚举类&thinsp;是非抽象的，且不能再派生出子类。 尽管&thinsp;枚举类&thinsp;不能被继承，但是可以有&thinsp;抽象方法&ensp;🡆&ensp;枚举类的抽象方法&thinsp;必须必需被其每一个&thinsp;枚举值&thinsp;实现。 所有的&thinsp;枚举值&thinsp;都是&thinsp;限定public static final修饰的。 在&thinsp;Java&thinsp;中，使用enum关键字来定义&thinsp;枚举类；其地位与class和interface相同。 枚举类的&thinsp;所有实例，必须在&thinsp;枚举类的第一行&thinsp;显式地列出；否则这个&thinsp;枚举类&thinsp;将&thinsp;不能生成实例。⤷&ensp;同时，编译器会自动地为&thinsp;枚举值&thinsp;添加public static final修饰，无需程序员显式添加。 第5章-9-2 枚举类的使用…… 参看项目&thinsp;[&thinsp;SuiteLHY/DingDing - githun.com&thinsp;]&thinsp;代码 第5章-10 总结 类（class）的&thinsp;初始化顺序： 父类的&thinsp;静态成员变量&thinsp;和&thinsp;静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 子类的&thinsp;静态成员变量&thinsp;和&thinsp;静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 父类的&thinsp;非静态成员变量&thinsp;和&thinsp;非静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 父类的&thinsp;构造方法；🡇 子类的&thinsp;非静态成员变量&thinsp;和&thinsp;非静态代码块（按&thinsp;声明先后顺序&thinsp;执行）；🡇 子类的&thinsp;构造方法。 第6章 访问权限控制访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。…… 为了解决这一问题，Java&thinsp;提供了&thinsp;访问权限修饰词，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的。 访问权限的控制等级，从最大权限到最小权限依次为：public&ensp;🡆&ensp;protected&ensp;🡆&ensp;[&thinsp;包访问权限&thinsp;]（没有关键词）&ensp;🡆&ensp;private。 ……对于这一点，Java&thinsp;用关键字package加以控制；而&thinsp;访问权限修饰词&thinsp;会因为&thinsp;类class是否在同一个包下&thinsp;而受到影响。 …… 第6章-1 包：库单元包package内包含有一组&thinsp;[&thinsp;类class&thinsp;/&thinsp;接口interface&thinsp;/&thinsp;枚举enum&thinsp;]，它们&thinsp;在单一的名字空间下&thinsp;被组织在了一起。…… 第6章-1-1 代码组织 当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件；该输出文件的名称与.java文件中的每个类的名称相同，且后缀名为.class。因此，在编译少量的.java文件之后，会得到大量的.class文件。 如果用编译型语言编写过程序，就会清楚：在传统的编译型语言中，编译器产生一个中间文件（通常是一个obj文件），然后再与通过链接器（用于创建一个可执行文件）或类库产生器（librarian，用以创建一个类库）产生的其他同类文件捆绑在一起。 然而&thinsp;Java&thinsp;的可运行程序，是一组可以打包并压缩为一个&thinsp;Java&thinsp;文档文件（JAR，使用&thinsp;Java&thinsp;的&thinsp;jar&thinsp;文档生成器）的.class文件。⤷&ensp;Java&thinsp;解释器&thinsp;负责这些文件的&thinsp;查找、装载&thinsp;和&thinsp;解释。 类库&thinsp;实际上是一组类文件.class。其中每个文件都有一个public类，以及&thinsp;任意数量的&thinsp;非public类；因此每个文件都有一个构件。如果希望这些构件（每一个都有它们自己独立的.java和.class文件）从属于同一个群组，可以使用关键字package。 如果使用package语句，它必须是&thinsp;文件中&thinsp;除注释以外的&thinsp;第一行程序代码。在&thinsp;文件起始处&thinsp;写：⤵ ⤷&ensp;（请注意，Java&thinsp;包的命名规则是&thinsp;全部使用小写字母，包括中间的字母也是如此） 注意：关键字import与通配符*搭配，不能定位到命名空间下的包（不能保证没有冲突）。 第6章-1-2 创建独一无二的包名 既然一个包&thinsp;从未真正地将&thinsp;被打包的东西&thinsp;包装成&thinsp;单一的文件，并且一个包可以由许多.class文件构成；那么仅仅是这样，就可能出现名称完全相同的.class文件混淆在一起。 ⤷&ensp;为了避免这种情况，Java&thinsp;将每个包的所有.class文件都置于独一无二的目录下。…… 冲突…… 注意：import关键字&thinsp;和&thinsp;通配符*，不能定位指定命名空间下的包（package），因为没有分配资源去进行&thinsp;唯一性的校验，无法避免&thinsp;包名冲突。 第6章-1-3 定制工具库…… 第6章-1-4 用import改变行为…… 第6章-1-5 对使用包的忠告务必记住，无论何时创建&thinsp;包（package），都已经在给定&thinsp;包的名称&thinsp;的时候隐式地指定了目录结构。 第6章-2 Java访问权限修饰词…… 第6章-3 接口和实现 访问权限的控制&thinsp;常被称为是&thinsp;具体实现的隐藏。 封装：把&thinsp;数据&thinsp;和&thinsp;方法&thinsp;包装进&thinsp;类（class）&thinsp;中，隐藏&thinsp;类（class）的具体实现。其结果是&thinsp;生成一个&thinsp;带有特征和行为的&thinsp;数据类型。 使用封装的原因（好处）在结构中建立内部机制，将公开的接口和具体实现分离。⤴&ensp;隐藏实现细节，提供公共的访问方式。⤵ 提高代码的可维护性。 提高代码的可重用性。 提高数据的安全性。 第6章-4 类的访问权限在&thinsp;Java&thinsp;中，访问权限修饰词&thinsp;也可以用于&thinsp;确定库中的哪些类对于该库的使用者是可用的。 如果希望某个类可以为客户端程序员所用，就可以通过把关键字public作用于整个类的定义来实现。这样做甚至可以控制客户端程序员是否能创建一个该类的对象。 实现形式： …… 访问权限修饰词&thinsp;还有一些额外的限制： 每个编译单元（文件）都只能有一个public类。⤷&ensp;这表示，每个编译单元&thinsp;都有一个&thinsp;唯一的公共接口，通过public实现。 public类的名称必须完全与含有该编译单元的文件名一致（包括大小写）。 虽然不是很常用，但编译单元内完全不带public类也是可以的。⤷&ensp;此时文件的命名不受限制。 第6章-5 总结…… 第7章 复用类 复用代码&thinsp;是&thinsp;Java&thinsp;众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它必须能够做更多的事情。 在&thinsp;Java&thinsp;中，所有问题的解决都是围绕着&thinsp;类（class）&thinsp;展开的。可以通过创建新类来复用代码。此方法的窍门在于使用&thinsp;类&thinsp;而不破坏现有程序代码。 第1种实现方法非常直观：只需在新的类中创建现有类的对象。该方法只是复用了现有程序代码的功能，而非它的形式。由于新的类是由现有类的对象所组成，所以这种方法称为&thinsp;组合。 第2种方法则更细致一些，它按照现有类的类型来创建新类，无需改变现有类的形式，采用现有类的形式，并在其基础上添加新的代码，这种方法被称为&thinsp;继承。编译器完成其中绝大部分的工作。继承&thinsp;是面向对象的基础之一。 第7章-1 组合语法使用组合技术，只需要将对象引用置于新的类中即可。对于&thinsp;基本类型数据，可以直接定义；而对于&thinsp;非基本类型的对象，必须将其&thinsp;引用&thinsp;置于新的类中。 编译器并不会为每一个引用都创建默认对象，为的是避免不必要的负担（现在Java之父后悔了！声称：当初是因为实现简单才这样设计的；后来的使用中造成了至少10亿美元的损失）。 如果想要初始化引用，可以在下列位置中进行： 定义对象的地方。这意味着它们总是能够在被构造器调用之前被初始化。 类的构造器中。 在使用这些对象的代码之前，这种方式被称为惰性初始化。&ensp;在声明的引用不必每次都生成对象的情况下，可以避免不必要的负担。 使用实例初始化。 示例： …… 第7章-2 继承语法继承是所有&thinsp;OOP&thinsp;语言不可缺少的组成部分。 当创建一个类时，总是在&thinsp;继承；除非明确地指出要从其他类中继承，否则就是在隐式地从&thinsp;Java&thinsp;的标准根类Object进行继承。 继承的语法：……关键字extends 第7章-2-1 初始化基类继承&thinsp;涉及到&thinsp;基类（被继承的类，又称&thinsp;父类、超类）和&thinsp;派生类（继承的类，又称&thinsp;子类、导出类）2个类。 从外部看，派生类的对象&thinsp;就像是一个&thinsp;与基类具有相同接口的新类，或许还会有一些额外的&thinsp;方法&thinsp;和&thinsp;域。但&thinsp;继承&thinsp;并不只是单纯地复制基类的接口。 Java会自动在派生类的构造器中插入对基类构造器的调用。 当通过继承创建了一个派生类的对象时，该对象包含了一个基类（超类）的子对象。⤷&ensp;其中，对基类的子对象的正确初始化也是至关重要的，而且有且仅有一种方法来保证这一点：在&thinsp;派生类构造器&thinsp;中调用&thinsp;基类构造器&thinsp;来执行初始化，且&thinsp;必须&thinsp;在派生类构造器中&thinsp;最开始执行。 在设计上，基类的构造器&thinsp;具有&thinsp;执行基类初始化所需要的&thinsp;所有知识和能力，包括&thinsp;超类对象的&thinsp;构造器调用所必需的能力。 示例： …… 带参数的构造器 上例中各个类均含有默认的构造器，即不带参数的构造器。 如果没有&thinsp;默认的&thinsp;基类构造器，或者想要&thinsp;调用一个&thinsp;带参数的&thinsp;基类构造器，就必须&thinsp;使用关键字super&thinsp;显式地编写&thinsp;调用基类构造器的语句，同时配以适当的&thinsp;参数列表。 需要格外注意的是：在&thinsp;子类构造器&thinsp;中，对&thinsp;超类构造器&thinsp;的（显式）调用动作&thinsp;必须在最开始定义。 示例： …… 【拓展】第7章-2-2 重写 参考资料：【runoob.com】Java 重写(Override)与重载(Overload) 重写（Override）&thinsp;是&thinsp;子类对&thinsp;[&thinsp;父类中&thinsp;允许子类访问的方法&thinsp;]&thinsp;的实现过程&thinsp;进行重新编写（方法名、返回值、形参列表&thinsp;都保持一致，访问权限&thinsp;和&thinsp;抛出异常&thinsp;符合重写规则）。 在面向对象原则里，重写（Override）意味着可以重写任何现有的方法。 重写（Override）的好处 子类可以根据自己的需要，定义特定于自己的行为（即子类能够根据需要实现父类的方法）。 重写（Override）规则 参数列表&thinsp;必须&thinsp;与&thinsp;被重写的方法&thinsp;完全相同（参数个数、参数类型&thinsp;及其&thinsp;排列方式）。 访问权限&thinsp;对比&thinsp;父类中被重写的方法&thinsp;更高&thinsp;或&thinsp;相等。⤷&ensp;例如：如果一个&thinsp;父类的方法&thinsp;被声明为public，那么&thinsp;子类中对应的重写方法&thinsp;就不能声明为protected。 父类中的方法&thinsp;只能&thinsp;被它的子类&thinsp;重写。 声明为final的方法&thinsp;不能被重写。 声明为static的方法&thinsp;不能被重写，但是能够&thinsp;被再次声明。 static方法&thinsp;仅与&thinsp;类（class）&thinsp;绑定，而不与&thinsp;类的具体对象&thinsp;绑定； 继承&thinsp;是描述&thinsp;对象之间的关系&thinsp;的概念。 ⤷&ensp;所以&thinsp;static方法&thinsp;与&thinsp;重写（Override）的概念&thinsp;搭不上边。 构造方法&thinsp;不能被重写。 如果不能&thinsp;继承&thinsp;一个方法，则不能&thinsp;重写&thinsp;这个方法。 如果&thinsp;子类和父类&thinsp;在同一个包中，那么&thinsp;子类&thinsp;可以重写&thinsp;[&thinsp;父类中&thinsp;除了声明为private或final的&thinsp;其他所有方法&thinsp;]。 如果&thinsp;子类和父类&thinsp;在不同的包中，那么&thinsp;子类&thinsp;只能够重写&thinsp;[&thinsp;父类中&thinsp;声明为public或protected的、非final修饰的&thinsp;所有方法&thinsp;]。 重写的方法&thinsp;能够抛出&thinsp;任何非强制异常，无论&thinsp;被重写的方法&thinsp;是否抛出异常；⤷&ensp;不能抛出&thinsp;新的强制性异常，或者&thinsp;[&thinsp;比&thinsp;被重写的方法&thinsp;声明得更广泛的&thinsp;强制性异常&thinsp;]。 Super关键字的使用 当需要&thinsp;在子类中&thinsp;调用&thinsp;父类的被重写方法&thinsp;时，要使用super关键字（类似this关键字；代替&thinsp;父类指针）。 重写（Override）与重载（Overload）之间的区别 区别点 重载（Overload） 重写（Override） 参数列表 必须修改 必须一致 返回类型 可以修改 必须一致 访问权限 可以修改 可以&thinsp;保持一致&thinsp;或&thinsp;降低限制，不能做更严格的限制（访问权限&thinsp;不能提高） 抛出异常 可以修改 可以&thinsp;减少&thinsp;或&thinsp;删除，不能抛出&thinsp;新的&thinsp;或者&thinsp;范围更广泛的&thinsp;强制性异常 重写（Override）与重载（Overload）之间的联系 方法的&thinsp;重写（Override）和&thinsp;重载（Overload）&thinsp;是&thinsp;Java&thinsp;多态性&thinsp;的不同表现 重写（Override）&thinsp;是&thinsp;父类与子类之间&thinsp;多态性的一种表现； 重载（Overload）&thinsp;可以理解成多态的具体表现形式。 第7章-3 代理第7章-4 结合使用组合和继承同时使用组合和继承是很常见的事。…… 第7章-4-1 确保正确清理Java&thinsp;中没有&thinsp;C++&thinsp;中&thinsp;析构函数&thinsp;的概念。 析构函数&thinsp;是一种&thinsp;在对象被销毁时&thinsp;可以被自动调用的函数。 ⤷&ensp;其原因可能是在&thinsp;Java&thinsp;的设计中，销毁对象的操作&thinsp;由&thinsp;垃圾回收器&thinsp;进行控制执行。 ⤷&ensp;通常这样做是好事，但有时&thinsp;类（class）&thinsp;可能要&thinsp;在生命周期内&thinsp;执行一些必需的&thinsp;清理活动。…… 第7章-4-2 名称屏蔽如果&thinsp;Java&thinsp;的基类&thinsp;拥有某个&thinsp;已被多次重载（Overload）的方法名称，那么&thinsp;在派生类中&thinsp;重新定义该方法名称时，并不会&thinsp;屏蔽&thinsp;其&thinsp;在基类中的&thinsp;任何版本。⤷&ensp;因此，无论在该层还是在它的基类中进行定义，重载（Overload）机制都可以正常工作。 ……（C++&thinsp;中设计&thinsp;重写（Override）时&thinsp;屏蔽&thinsp;基类的重载机制&thinsp;的原因之一&ensp;——&ensp;防止程序员犯错误） Java&thinsp;SE&thinsp;5&thinsp;新增加了@Override注解，它并不是关键字，但是可以被当做关键字使用。 @Override注解的作用：在编译时进行&thinsp;重写（Override）检验的&thinsp;编译检查⤷&ensp;防止意外地&thinsp;重载（Override）。 第7章-5 在组合与继承之间选择组合（Composition）&thinsp;和&thinsp;继承（extends）&thinsp;都允许&thinsp;在新的类中&thinsp;放置&thinsp;子对象。组合（Composition）&thinsp;是&thinsp;显式地&thinsp;执行；继承（extends）&thinsp;是&thinsp;隐式地&thinsp;执行。 要想使用好&thinsp;组合&thinsp;和&thinsp;继承，我们需要明确：二者之间的区别何在？怎样在二者之间做出选择？ 组合和继承的区别 在底层实现层面上，继承（extends）&thinsp;实际上是&thinsp;在&thinsp;组合（Composition）的基础上&thinsp;封装实现的抽象逻辑。 在抽象逻辑层面上： 组合（Composition）&thinsp;是“has-a”（有一个）关系的表达； 继承（extends）&thinsp;是“is-a”（是一个）关系的表达。 在&thinsp;Java&thinsp;中，继承（extends）&thinsp;支持&thinsp;从派生类向基类进行&thinsp;向上转型。 在组合和继承之间的选择 组合（Composition）&thinsp;通常用于&thinsp;在新的类中&thinsp;使用&thinsp;现有类的功能&ensp;🡄&ensp;而非现有类的接口。 继承（extends）&thinsp;往往用于&thinsp;在新的类中&thinsp;实现&thinsp;现有类的接口。 第7章-6 protected关键字 理解了&thinsp;继承，关键字protected才具有意义。 protected关键字的作用：限制&thinsp;对&thinsp;类（class）的成员&thinsp;的访问，仅允许&thinsp;[&thinsp;该类的派生类&thinsp;和&thinsp;同一个包下的&thinsp;]&thinsp;任何类&thinsp;访问。 第7章-7 向上转型 “为新的类提供方法”并不是&thinsp;继承&thinsp;技术中最重要的方面，其最重要的方面是&thinsp;表现新的类和基类之间的所属关系，这种关系可以概括为“新的类是现有类的一种类型”。 第7章-7-1 为什么称为向上转型 该术语的使用有其历史原因，并且是以传统的&thinsp;类继承图&thinsp;的绘制方法为基础：将根置于页面的顶端，然后逐渐向下。 由&thinsp;派生类&thinsp;生成&thinsp;基类，在&thinsp;继承图&thinsp;上是向上移动的，因此称为&thinsp;向上转型。 第7章-7-2 再论组合与继承 在&thinsp;OOP&thinsp;中，生成和使用程序代码最有可能采用的方法是&thinsp;组合 &ensp;🡆&ensp;直接将数据和方法包装进一个类中，并使用该类的对象。 判断是否应该使用&thinsp;继承，最清晰的标准是&thinsp;是否需要&thinsp;从派生类向基类进行&thinsp;向上转型。 第7章-8 final关键字根据&thinsp;上下文环境，Java&thinsp;的关键字final的含义存在细微的差别，通常它指的是“这是无法改变的”。 ⤷&ensp;不想改变可能出于2种理由：设计&thinsp;或&thinsp;效率（Java&thinsp;SE&thinsp;5&thinsp;之后不需要考虑，交由&thinsp;JVM&thinsp;来优化）。 ⤷&ensp;由于这2个原因相差很远，因此关键字final有可能被误用。 下面讨论可能使用到final的3种情况：数据、方法、类。 第7章-8-1 final数据许多编程语言都有某种方法，来向编译器告知一块数据是&thinsp;恒定不变的。 对于&thinsp;数据的恒定不变，有2种情况： 一个&thinsp;永不改变的&thinsp;编译时常量：以final关键字修饰，且&thinsp;值&thinsp;为&thinsp;基本数据类型的数据（总之就是&thinsp;编译期&thinsp;能够确定值的对象）。 对于&thinsp;编译常量&thinsp;这种情况，编译器可以将该&thinsp;常量值&thinsp;代入任何可能用到它的计算式中。即&thinsp;在编译时&thinsp;执行计算式，减轻运行时负担。 在&thinsp;Java&thinsp;中，这类&thinsp;常量&thinsp;必须是&thinsp;基本数据类型，并且以final关键字修饰。 一个&thinsp;运行时常量&ensp;——&ensp;在运行时&thinsp;被初始化的值，且不希望它被改变。 在&thinsp;Java&thinsp;中，当final关键字修饰&thinsp;对象引用&thinsp;时，该&thinsp;对象引用&thinsp;会恒定不变（一旦该引用被初始化指向一个对象，就不会再被更改为其他对象）；然而，该引用所指向的对象，其自身是可以被修改的。 Java&thinsp;并未提供&thinsp;使任何对象恒定不变&thinsp;的途径（可以自己编写&thinsp;类&thinsp;以实现&thinsp;使对象恒定不变的效果）。 一个既是static又是final的域，只占据一段不能改变的存储空间（……）。 示例： 下面的示例示范了final域的情况。注意，根据惯例，既是static又是final的域（……）将用&thinsp;大写字母&thinsp;表示，并使用下划线_分隔各个单词。 …… 空白finalJava&thinsp;允许生成“空白final”，所谓空白final是指：被声明为final，但又未给定初值的域。无论什么情况，编译器都确保空白final在使用前被初始化。 空白final在final关键字的使用中提供了更大的灵活性&ensp;——&ensp;一个类中的final域可以根据对象而有所不同，却还能保持其恒定不变的特性。 示例： …… final参数Java&thinsp;允许&thinsp;在参数列表中&thinsp;以声明的方式将&thinsp;参数&thinsp;指明为final。这意味着你无法在方法中更改参数引用&ensp;——&ensp;在方法中&thinsp;可以读参数，但不能修改参数。 这一特性主要用来向&thinsp;匿名内部类&thinsp;传递数据。 第7章-8-2 final方法使用final修饰方法的原因有两个： 把方法锁定，以防任何继承类修改它的含义。 ⤷&ensp;这是出于设计的考虑：想要确保该方法在继承中保持其行为不变，并且不会被覆盖。 不能重写的前提是派生类能够访问到基类中的方法。⤷&ensp;注意：如果一个方法同时被final和private修饰&ensp;——&ensp;派生类没有指定方法的访问权限，final对方法的禁止重写的限制将会失效；派生类中可以定义与基类几乎一致（符合重写规则）的方法，作为派生类定义的新方法。 在过去，建议使用final方法的第2个原因是&thinsp;效率； 在&thinsp;Java&thinsp;的早期实现中，如果将一个方法指明为final，则编译器将针对该方法的所有调用都转为&thinsp;内嵌调用。……在被final修饰的方法不大的情况下，这样做能减少方法调用的开销；否则，程序的代码就会膨胀（……），内嵌直接带来的性能提高会因为在方法内花费过多的时间量而被缩减，实际上达不到性能提高的效果。 ⤷&ensp;在最近的版本中（Java&thinsp;SE&thinsp;5&thinsp;以后），虚拟机（特别是&thinsp;hotspot&thinsp;技术）可以探测到这些情况，并优化去掉这些效率反而降低的&thinsp;内嵌调用，因此不再需要使用final方法来优化了。 同时，为了效率而使用final方法的做法逐渐地受到劝阻&ensp;——&ensp;（Java&thinsp;SE&thinsp;5&thinsp;以后的环境下）应该让编译器和&thinsp;JVM&thinsp;去处理效率的问题， ⤷&ensp;只有在想要明确地禁止覆盖时，才将方法设置为final。 final和private关键字概述：final&ensp;+&ensp;private&ensp;=&ensp;无法覆盖&ensp;+&ensp;无法调用&ensp;=&ensp;无法调用 对于&thinsp;基类中的&thinsp;无法覆盖的方法，子类中&thinsp;可以定义&thinsp;[&thinsp;与这些基类方法&thinsp;在形式上符合重写规则（方法名、参数列表、返回值、访问权限、抛出异常）的&thinsp;]&thinsp;方法，但是这些子类方法只是在子类中新定义的方法，与父类无关。 第7章-8-3 final类当&thinsp;类（class）&thinsp;被修饰为final时，该类无法被&thinsp;继承。 设计目的： 该类不需要做任何改动； 出于安全性的考虑，不希望该类有子类。 final类禁止继承，因此final类中的&thinsp;方法&thinsp;都&thinsp;隐式地&thinsp;指定为final。 第7章-8-4 有关final的忠告在设计类时，将方法指定为final会禁止方法被继承，这需要对&thinsp;该类如何被复用&thinsp;有明确的预见和定义。 …… 第7章-9 初始化类及类的加载 在许多传统语言中，程序是作为启动过程的一部分立刻被加载的，然后是初始化，紧接着程序开始运行。 这些语言的&thinsp;初始化过程&thinsp;必须小心地控制，以确保定义为static的东西，其&thinsp;初始化顺序&thinsp;不会出现问题。⤷&ensp;例如&thinsp;C++&thinsp;中，如果某个static期望另一个static&thinsp;在被初始化之前&thinsp;就能有效地使用它，那么就会出现问题。 Java&thinsp;采用了一种不同的加载方式避免了该问题。…… 类（class）的代码在初次使用时才加载 一般来说，“类的代码在初次使用时才加载”，这通常指的是&thinsp;加载&thinsp;发生在&thinsp;类（class）的第一个对象创建之时，但是当访问static域或static方法时，也会发生加载。 static&thinsp;的初次使用之处&ensp;也是其&thinsp;初始化发生之处 所有的static对象和static代码段，都会&thinsp;在加载时，依据&thinsp;程序中的顺序（即&thinsp;书写顺序）依次初始化。 当然，定义为static的东西只会被初始化一次。 …… 第7章-9-1 继承与初始化了解包括继承在内的初始化全过程，对所发生的一切有个全局把控，是很有益的。 示例： …… 第7章-10 总结继承&thinsp;和&thinsp;组合&thinsp;都能&thinsp;从现有类型&thinsp;生产新的类型。⤷&ensp;组合&thinsp;一般是&thinsp;将现有类型作为新类型底层实现的一部分&thinsp;来加以复用；而&thinsp;继承&thinsp;复用的是接口。 在使用&thinsp;继承&thinsp;时，由于&thinsp;派生类具有基类的接口，因此它可以&thinsp;向上转型&thinsp;至&thinsp;基类。这对&thinsp;多态&thinsp;来讲至关重要。 …… 第8章 多态面向对象的程序设计语言（OOP）的基本特性：封装（数据抽象）、继承、多态。 封装：通过合并特征和行为&thinsp;创建新的数据类型。 “实现隐藏” 继承：…… 继承&thinsp;允许&thinsp;将对象（Object）视为&thinsp;[&thinsp;它本身的类型&thinsp;或者&thinsp;其基类型&thinsp;]&thinsp;来处理。 多态（也称作&thinsp;动态绑定、后期绑定&thinsp;或&thinsp;运行时绑定）：…… 多态的作用是&thinsp;消除类型之间的耦合关系。 第8章-1 再论向上转型对象&thinsp;既可以&thinsp;作为它本身的类型使用，也可以&thinsp;作为基类型使用。而这种&thinsp;[&thinsp;把&thinsp;对象的引用&thinsp;视为&thinsp;对其基类型的引用&thinsp;]&thinsp;的做法，被称作&thinsp;向上转型。 但是，这样做也有一个问题，具体看下面这个例子： 示例： …… 第8章-1-1 忘记对象类型⤷&ensp;上例中的Music.java看起来似乎有些奇怪。为什么所有人都故意忘记对象的类型呢？在进行向上转型时，就会产生这种情况；并且如果让tune()方法接受一个Wind引用作为自己的参数，似乎会更为直观。⤷&ensp;但这样引发的一个重要问题是：如果那样做，就需要为系统内Instrument的每种类型都编写一个新的tune()方法。 …… 这样做行得通，但有一个主要的缺点：必须为每个新的Instrument类编写特定类型的方法。这意味着在开始时就需要更多的编程，…… 此外，如果我们忘记重载某个方法，编译器不会返回任何错误信息，这样对于整个类型的处理过程就会变得难以操纵。 也许我们可以写一个简单地方法，它仅接收基类作为参数，而不接收派生类。⤷&ensp;这是多态所允许的，但这往往不符合大多数的业务设计场景。 第8章-2 转机⤷&ensp;运行上例所设计的程序后，…… 那么在这种情况下，编译器如何知道这个Instrument指向的是Wind对象呢？实际上，编译器仅凭这些无法确定，需要使用&thinsp;绑定&thinsp;来解决。 第8章-2-1 方法调用绑定 绑定：将&thinsp;一个方法的调用&thinsp;同&thinsp;一个方法主体&thinsp;关联起来。 前期绑定：在程序执行前&thinsp;进行绑定。 前期绑定&thinsp;是面向过程语言的默认绑定方式。⤷&ensp;例如，C&thinsp;语言只有&thinsp;前期绑定&thinsp;这一种方法调用。 后期绑定（也叫&thinsp;动态绑定、运行时绑定）：在程序运行时，根据&thinsp;对象的类型&thinsp;进行绑定。 ……后期绑定&thinsp;随语言不同而有所不同，但是试想一下就知道，不管怎样都必须在对象中放置某种“类型信息”。 在&thinsp;Java&thinsp;中，除了static和final限定的方法&thinsp;之外，其他所有的方法&thinsp;都是&thinsp;后期绑定。 第8章-2-2 产生正确的行为在确认Java中所有方法都是通过动态绑定实现多态这个事实后，我们就可以编写只与基类打交道的程序代码了，这些代码对所有的派生类都可以正常运行；或者换一种说法，发送消息给某个对象，让该对象去判断应该执行什么动作。 在面向对象程序设计中，有一个经典的例子就是“几何形状”（shape）。 …… 向上转型可以像下面这条语句这么简单： 这条语句创建了一个Circle对象，并把得到的引用立即赋值给Shape。因为通过&thinsp;继承，Circle就是一种Shape，所以编译器认可这条语句，不会产生错误信息。 假如要调用s.draw()方法（在Circle中已被覆盖），由于&thinsp;后期绑定（多态），最终正确调用了Circle.draw()方法。 第8章-2-3 可拓展性由于多态机制，我们可以从通用的基类继承出新的数据类型，这样就可以添加新功能；同时那些操作基类接口的方法不需要改动就能够应用于新类。 第8章-2-4 缺陷：“覆盖”私有方法 示例： …… 由于private方法被自动认为是final方法，而且对派生类是屏蔽的，所以&thinsp;派生类中定义&thinsp;与&thinsp;基类中符合重写规则形式的方法，算不上&thinsp;重写，只能算是派生类中新定义的方法；同时派生类中的方法&thinsp;也不能&thinsp;对基类中的private方法进行&thinsp;重载。 此时编译器不会报错，但是程序也不会按照所期望的（覆盖基类的方法）来执行。确切地说，在派生类中，对于基类的private方法，最好采用不同的方法名。 第8章-2-5 缺陷：域与静态方法在&thinsp;Java&thinsp;中，只有&thinsp;普通的方法调用（非static&ensp;|&ensp;final的方法调用）可以是&thinsp;多态的。 如果你直接访问某个域，这个访问就将在编译期进行解析。 …… …… 静态方法的行为不具有多态性。 因为&thinsp;静态方法&thinsp;是与&thinsp;类，而非与&thinsp;单个的对象&thinsp;相关联的。 …… 第8章-3 构造器和多态通常，构造器&thinsp;不同于&thinsp;其他种类的方法，涉及到&thinsp;多态&thinsp;时也是如此。 构造器&thinsp;不具有&thinsp;多态性（它们是&thinsp;隐式声明的static方法），但还是很有必要理解&thinsp;构造器怎么通过&thinsp;多态&thinsp;在复杂的层次结构中&thinsp;运作，这将有利于&thinsp;避免一些不必要的困扰。 第8章-3-1 构造器的调用顺序 构造器的调用顺序已经在第5章简要说明和第7章再次提及，但那些都是在多态引入之前讨论的。 基类的构造器&thinsp;总是&thinsp;在导出类的构造过程中&thinsp;被调用，并且&thinsp;按照继承层次&thinsp;逐渐向上链接，使得&thinsp;每个基类的构造器&thinsp;都能得到调用。 示例：（展示&thinsp;组合、继承、多态&thinsp;在构建顺序上&thinsp;的作用） 输出： ⤷&ensp;由上例可见，构造器调用顺序： 调用&thinsp;基类的构造器。🡇 按照声明顺序&thinsp;调用&thinsp;成员的初始化方法。🡇 调用&thinsp;导出类的构造器。 第8章-3-2 继承与清理通过&thinsp;组合&thinsp;和&thinsp;继承&thinsp;的方法&thinsp;来创建新类时，一般不用担心对象的情况问题（子对象留给&thinsp;垃圾回收器（GC）&thinsp;进行处理）。 如果确实需要做&thinsp;自定义的清理动作，需要注意&thinsp;对象销毁的顺序&thinsp;和&thinsp;其&thinsp;初始化的顺序&thinsp;相反。…… 第8章-3-3 构造器内部的多态方法的行为 构造器调用的层次结构&thinsp;带来了一个有趣的两难问题：🡆&ensp;如果在&thinsp;构造器的内部，调用&thinsp;当前构造对象的&thinsp;动态绑定方法，该如何处理？ 在&thinsp;一般方法的内部，动态绑定的方法&thinsp;是&thinsp;在运行时&thinsp;才决定的；⤷&ensp;所以，此时使用的是&thinsp;[&thinsp;对象存储空间&thinsp;在初始化时的&thinsp;默认值&thinsp;]。 示例： …… ⤷&ensp;因此，编写构造器时&thinsp;有一条&thinsp;有效的准则：“用尽可能简单地方法&thinsp;使对象进入正常状态；尽量避免&thinsp;调用其他方法”。 ⤷&ensp;在构造器中&thinsp;唯一能够安全调用的方法&thinsp;是&thinsp;基类中的final方法。 第8章-4 协变返回类型 Java&thinsp;SE&thinsp;5&thinsp;中添加了&thinsp;协变返回类型。 协变返回类型：在导出类中的、被覆盖的&thinsp;方法，可以返回&thinsp;基类方法返回类型的&thinsp;某种导出类型。⤷&ensp;简单来说，协变返回类型&thinsp;允许&thinsp;返回&thinsp;更具体的返回类型。 示例： 输出： Java&thinsp;SE&thinsp;5&thinsp;以前的版本&thinsp;强制&thinsp;process()的覆盖版本&thinsp;必须返回Grain类型，而不能&thinsp;返回&thinsp;Grain类型的派生类型Wheat；⤷&ensp;从&thinsp;Java&thinsp;SE&thinsp;5&thinsp;开始，协变返回类型&thinsp;允许返回&thinsp;更具体的Wheat类型。 第8章-5 用继承进行设计…… 第8章-5-1 纯继承与拓展采用“纯粹”的方式&thinsp;来创建继承层次结构&thinsp;似乎是&thinsp;最好的方式。…… 第8章-5-2 向下转型与运行时类型识别由于向上转型会丢失&thinsp;具体类型信息，…… ⤷&ensp;要解决这个问题，必须&thinsp;有某个方法&thinsp;来确保&thinsp;向下转型的正确性，…… 在某些程序语言（例如&thinsp;C++）中，我们必须&thinsp;执行特殊的操作&thinsp;来获得&thinsp;安全的向下转型；⤷&ensp;但是在&thinsp;Java&thinsp;中，所有转型&thinsp;都会得到检查。 …… 运行时类型识别（RTTI）运行时类型识别（RTTI）：在运行期间&thinsp;对&thinsp;类型&thinsp;进行检查，如果&thinsp;类型转换的返回结果&thinsp;不是&thinsp;程序定义时所期望的类型，就会抛出一个ClassCastException（类转换异常）。 示例： 输出： 第8章-6 总结多态意味着“不同的形式”。…… …… 第9章 接口接口（Interface）&thinsp;和&thinsp;内部类（Inner class）&thinsp;为我们提供了一种&thinsp;将接口与实现分离的&thinsp;更加结构化的方法。 ⤷&ensp;这种机制在编程语言中并不通用。例如，C++&thinsp;对这些概念只有间接的支持。⤷&ensp;而在&thinsp;Java&thinsp;中，有&thinsp;关键字&thinsp;对其进行支持。 首先，我们将学习&thinsp;抽象类。 抽象类是&thinsp;普通的类&thinsp;与&thinsp;接口&thinsp;之间的一种中庸之道。 这某些场景下，抽象类&thinsp;可能比&thinsp;接口&thinsp;更合适。 关于接口 接口知识点 接口（Interface）默认是abstract的。 接口中定义的&thinsp;变量，默认是public abstract final类型的。⤷&ensp;所以，接口中定义的变量必须在定义时初始化，在实现类中也不能被重新定义或者修改其值。 接口中定义的&thinsp;方法，默认是public abstract类型的。 第9章-1 抽象类和抽象方法 在第8章的“乐器”例子中，基类Instrument中的&thinsp;方法&thinsp;往往是“哑”（dummy）方法；Instrument类的设计目的是&thinsp;为它的所有导出&thinsp;创建一个通用接口，使得&thinsp;不同的子类可以用不同的方式&thinsp;实现这些通用接口。若要调用这些“哑”（dummy）方法，就会出现错误。 此例中的Instrument类被称为&thinsp;抽象基类，又称&thinsp;抽象类。 因为&thinsp;抽象类本身&thinsp;只是定义了&thinsp;接口（interface），没有对&thinsp;接口（interface）&thinsp;进行&thinsp;具体地实现，所以&thinsp;创建抽象类的对象&thinsp;是不必要且必须被禁止的。 为了&thinsp;抽象类&thinsp;概念的实现，Java&thinsp;提供了&thinsp;抽象方法：一种&thinsp;由abstract关键字修饰，且&thinsp;只有声明、没有方法体的&thinsp;特殊方法。 注意：构造器&thinsp;不能被abstract修饰，即&thinsp;构造器不能被抽象。 抽象类具体定义 一种被abstract关键字修饰的&thinsp;类，其中&thinsp;可以定义&thinsp;抽象方法（也可以没有）；且&thinsp;定义了抽象方法的类&thinsp;必须被abstract修饰，即&thinsp;只有&thinsp;抽象类&thinsp;才可以定义&thinsp;抽象方法。 抽象类&thinsp;不能被实例化，但是&thinsp;可以定义构造器（不能被abstract修饰，即不能被抽象）。 由于&thinsp;抽象类里会存在一些&thinsp;属性，那么&thinsp;抽象类&thinsp;一定会有&thinsp;构造方法，其存在目的是&thinsp;为了属性能够正确地初始化。 抽象类，全称&thinsp;抽象基类，是&thinsp;在继承关系的基础上&thinsp;实现的；要想使用抽象类，只能通过&thinsp;其&thinsp;非抽象的派生类&thinsp;实现其全部抽象方法。 具体来说，抽象类的子类&thinsp;可以是抽象类，此时&thinsp;这些抽象的子类&thinsp;不需要实现&thinsp;父类的全部抽象方法；而如果&thinsp;非抽象类&thinsp;继承了&thinsp;抽象类，则&thinsp;其&thinsp;必须实现&thinsp;该抽象类中的全部抽象方法。因为&thinsp;抽象类&thinsp;只能通过&thinsp;继承关系&thinsp;来使用，所以&thinsp;抽象类&thinsp;不能被final关键字修饰（final类无法被继承）。 外部抽象类&thinsp;不允许使用static修饰，而&thinsp;内部抽象类&thinsp;可以使用static修饰；因为&thinsp;外部类&thinsp;是不能被static修饰为&thinsp;静态的，只有&thinsp;内部类&thinsp;可以被static修饰（此时作为&thinsp;成员，可以被static修饰）。使用static修饰的&thinsp;内部类，可以不需要&thinsp;实例化其所在的外部类&thinsp;就可以&thinsp;作为静态成员使用，使用形式“外部类.内部类”。 内部抽象类使用示例： 输出： 抽象类的使用有时候，在抽象类中&thinsp;只需要一个特定的系统子类操作，所以可以忽略掉&thinsp;外部子类；这样的设计&thinsp;在系统类库中&thinsp;会比较常见，目的是&thinsp;对用户&thinsp;隐藏&thinsp;不需要知道的子类。 场景示例： 输出： 抽象方法具体定义 抽象方法&thinsp;必须被abstract关键字修饰，且&thinsp;没有方法体（Java&thinsp;8&thinsp;开始&thinsp;可以有方法体）。 构造器&thinsp;和&thinsp;static方法&thinsp;不能被abstract修饰，即&thinsp;它们&thinsp;不能被抽象。 抽象方法&thinsp;在其所在抽象类的非抽象子类中，必须被实现。 第9章-2 接口第9章-3 完全解耦第9章-4 Java中的多重继承第9章-5 通过继承来拓展接口第9章-6 适配接口第9章-7 接口中的域第9章-8 嵌套接口第9章-9 接口与工厂第9章-10 总结第10章 内部类第10章-1 创建内部类第10章-2 链接到外部类第10章-3 使用.this与.new第10章-4 内部类与向上转型第10章-5 在方法和作用域内的内部类第10章-6 匿名内部类第10章-7 嵌套类第10章-8 为什么需要内部类第10章-9 内部类的继承第10章-10 内部类可以被覆盖吗第10章-11 局部内部类第10章-12 内部类标识符第10章-13 总结第11章 持有对象第11章-1 泛型和类型安全的容器第11章-2 基本概念第11章-3 添加一组元素第11章-4 容器的打印第11章-5 List（原理 &amp; 简介）第11章-6 迭代器第11章-7 LinkedList第11章-8 Stack第11章-9 Set第11章-10 Map第11章-11 Queue第11章-12 Collection和Iterator第11章-13 Foreach与迭代器第11章-13-1 适配器方法惯用法→示例源码说明第11章-14 总结第12章 通过异常处理错误第12章-1 概念第12章-2 基本异常第12章-2-1 捕获异常参数第12章-3 捕获异常第12章-3-1 try块第12章-3-2 异常处理程序第12章-4 创建自定义异常第12章-4-1 异常与记录日志第12章-5 异常说明第12章-6 捕获所有异常第12章-6-1 栈轨迹第12章-6-2 重新抛出异常第12章-6-3 异常链第12章-7 Java标准异常第12章-7-1 特例：RuntimeException第12章-8 使用finally进行清理第12章-8-1 finally用来做什么第12章-8-2 在return中使用finally第12章-8-3 缺憾：异常缺失第12章-9 异常的限制第12章-10 构造器第12章-11 异常匹配第12章-12 其他可选方式第12章-12-1 历史第12章-12-2 观点第12章-12-3 把异常传递给控制台第12章-12-4 把“被检查的异常”转换为“不检查的异常”第12章-13 异常使用指南第12章-14 总结第13章 字符串第13章-1 不可变String第13章-2 重载“+”与StringBuilder第13章-3 无意识的递归第13章-4 String上的操作第13章-5 格式化输出第13章-5-4 格式化说明符第13章-6 正则表达式第13章-7 扫描输入第13章-8 StringTokenizer（已废弃）第13章-9 总结第14章 类型信息（RTTI）第14章-1 为什么需要RTTI第14章-2 Class对象第14章-2-1 类字面量第14章-2-2 泛化的Class引用第14章-2-3 类的转换（原：新的转型语法）第14章-3 类型转换前先做检查第14章-4 注册工厂第14章-5 instanceof与Class的等价性第14章-6 反射：运行时的类信息第14章-6-1 类方法提取器第14章-7 动态代理第14章-8 空对象第14章-8-1 模拟对象与桩第14章-9 接口与类型信息第14章-10 总结第15章 泛型第15章-1 与C++比较第15章-2 简单泛型第15章-2-1 一个元祖类库第15章-2-2 一个堆栈类第15章-2-3 RandomList第15章-3 泛型接口第15章-4 泛型方法第15章-4-1 杠杆利用类型参数判断第15章-4-2 可变参数与泛型方法第15章-4-3 用于Generator的泛型方法第15章-4-4 一个通用的Generator第15章-4-5 简化元祖的使用第15章-4-6 一个Set实用工具第15章-5 匿名内部类第15章-6 构建复杂模型第15章-7 擦除的神秘之处第15章-7-1 C++的方式第15章-7-2 迁移兼容性第15章-7-3 擦除的问题第15章-7-4 边界处的动作第15章-8 擦除的补偿第15章-8-1 创建类型实例第15章-8-2 泛型数组第15章-9 边界第15章-10 通配符第15章-10-1 编译器有多聪明第15章-10-2 逆变第15章-10-3 无界通配符第15章-10-4 捕获转换（通配符捕获）第15章-11 问题第15章-11-1 任何基本类型都不能作为类型第15章-11-2 实现参数化接口第15章-11-3 转型和警告第15章-11-4 重载第15章-11-5 基类劫持了接口第15章-12 自限定的类型第15章-12-1 古怪的循环泛型第15章-12-2 自限定第15章-12-3 参数协变第15章-13 动态类型安全第15章-14 异常第15章-15 混型第15章-15-1 C++中的混型第15章-15-2 与接口混合第15章-15-3 使用装饰器模式第15章-15-4 与动态代理混合第15章-16 潜在类型机制第15章-17 对缺乏潜在类型机制的补偿第15章-17-1 反射第15章-17-2 将一个方法应用于序列第15章-17-3 当你并为碰巧拥有正确的接口时第15章-17-4 用适配器仿真潜在类型机制第15章-18 将函数对象用作策略第15章-19 总结：转型真的如此之糟吗？第15章-19-1 进阶读物第16章 数组第16章-1 数组为什么特殊第16章-2 数组是第一级对象第16章-3 返回一个数组第16章-4 多维数组第16章-5 数组与泛型第16章-6 创建测试数据第16章-6-1 Arrays.fill()第16章-6-2 数据生成器第16章-6-3 从Generator中创建数组第16章-7 Arrays实用功能第16章-7-1 复制数组第16章-7-2 数组的比较第16章-7-3 数组元素的比较第16章-7-4 数组排序第16章-7-5 在已排序的数组中查找第16章-8 总结第17章 容器深入研究第17章-1 完整容器分类法第17章-2 填充容器第17章-2-1 一种Generator解决方案第17章-2-2 Map生成器第17章-2-3 使用Abstract类第17章-3 Collection的功能方法第17章-4 可选操作第17章-4-1 未获支持的操作第17章-5 List的功能方法第17章-6 Set和存储排序第17章-6-1 SortedSet第17章-7 队列第17章-7-1 优先级队列第17章-7-2 双向队列第17章-8 理解Map第17章-8-1 性能第17章-8-2 SortedMap第17章-8-3 LinkedHashMap第17章-9 散列与散列码第17章-9-1 理解hashCode()第17章-9-2 为速度而散列第17章-9-3 覆盖hashCode()第17章-10 选择接口的不同实现第17章-10-1 性能测试框架第17章-10-2 对List的选择第17章-10-3 微基准测试的危险第17章-10-4 对Set的选择第17章-10-5 对Map的选择第17章-11 实用方法第17章-11.1 List的排序和查询第17章-11.2 设定Collection或Map为不可修改第17章-11.3 Collection或Map的同步控制第17章-12 持有引用第17章-12.1 WeakHashMap第17章-13 Java 1.0-1.1的容器第17章-13.1 Vector和Enumeration第17章-13.2 Hashtable第17章-13.3 Stack第17章-13.4 BitSet第17章-14 总结第18章 Java IO系统第18章-1 File类第18章-1-1 目录列表器第18章-1-2 目录实用工具第18章-1-3 目录的检查及创建第18章-2 输入（Input）和输出（Output）第18章-2-1 InputStream类型第18章-2-2 OutputStream类型第18章-3 添加属性和有用的接口第18章-3-1 通过FilterInputStream从InputStream读取数据第18章-3-2 通过FilterOutputStream从OutputStream写入第18章-4 Reader和Writer第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）第18章-4-2 更改流的行为第18章-4-3 未发生变化的类第18章-5 自我独立的类：RandomAccessFile第18章-6 IO流的典型使用方式第18章-6-1 缓冲输入文件第18章-6-2 从内存输入第18章-6-3 格式化的内存输入第18章-6-4 基本的文件输出第18章-6-5 存储和恢复数据第18章-6-6 随机读写访问文件第18章-6-7 管道流第18章-7 文件读写的实用工具第18章-7-1 读取二进制文件第18章-8 标准IO第18章-8-1 从标准输入中读取第18章-8-2 将System.out转换成PrintWriter第18章-8-3 标准IO重定向第18章-9 进程控制第18章-10 新IO第18章-10-1 转换数据第18章-10-2 获取基本类型第18章-10-3 视图缓冲器第18章-10-4 用缓冲器操纵数据第18章-10-5 缓冲器的细节第18章-10-6 内存映射文件第18章-10-7 文件加锁第18章-11 压缩第18章-11-1 用GZIP进行简单压缩第18章-11-2 用Zip进行多文件保存第18章-11-3 Java档案文件第18章-12 对象序列化第18章-12-1 寻找类第18章-12-2 序列化的控制第18章-12-3 使用“持久性”第18章-13 XML第18章-14 Preferences第18章-15 总结第19章 枚举类型第19章-1 基本enum特性第19章-1-1 将静态导入用于enum第19章-2 向enum中添加新方法第19章-2-1 覆盖enum的方法第19章-3 switch语句中的enum第19章-4 values()的神秘之处第19章-5 实现而非继承第19章-6 随机选取第19章-7 使用接口组织枚举第19章-8 使用EnumSet替代标志第19章-9 使用EnumMap第19章-10 常量相关的方法（枚举类的抽象方法）第19章-10-1 使用enum的职责链第19章-10-2 使用enum的状态机第19章-11 多路分发第19章-11-1 使用enum分发第19章-11-2 使用常量相关的方法第19章-11-3 使用EnumMap分发第19章-11-4 使用二维数组第19章-12 总结第20章 注解第20章-1 基本语法第20章-1-1 定义注解第20章-1-2 元注解第20章-2 编写注解处理器第20章-2-1 注解元素第20章-2-2 默认值限制第20章-2-3 生成外部文件第20章-2-4 注解不支持继承第20章-2-5 实现处理器第20章-3 使用apt处理注解第20章-4 将观察者模式用于apt第20章-5 基于注解的单元测试第20章-5-1 将@Unit用于泛型第20章-5-2 不需要任何“套件”第20章-5-3 实现@Unit第20章-5-4 移除测试代码第20章-6 总结第21章 并发第21章-1 并发的多面性第21章-2 基本的线程机制第21章-3 共享受限资源第21章-4 终结任务第21章-5 线程之间的协作第21章-6 死锁第21章-7 新类库中的构件第21章-8 仿真第21章-9 性能调优第21章-10 活动对象第21章-11 总结第22章 图形化用户界面 📖参看 主要参看📖 Java | 夜与花海 Java教程 - 廖雪峰的官方网站 《Thinking-in-Java》 | 夜与花海 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 🡅 - 向上重箭头: U+1F845 - Unicode 字符百科 🡆 - 向右重箭头: U+1F846 - Unicode 字符百科 🡇 - 向下重箭头: U+1F847 - Unicode 字符百科 🡄 - 向左重箭: U+1F844 - Unicode 字符百科 ⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科 ⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科 ⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科 ⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;面向对象程序设计 - 维基百科，自由的百科全书 ^&ensp;面向对象程序设计（一种计算机编程架构）_百度百科 🔗外部链接 Wikipedia’s external link ltr-icon Java 重写(Override)与重载(Overload) | 菜鸟教程 Java 中的枚举 (enum) - 简书 Java 枚举(enum) 详解7种常见的用法_请叫我大师兄-CSDN博客_枚举 SuiteLHY/DingDing: Instant Messaging System, Microservice Architecture, DDD (Domain-driven design); Spring, Spring MVC, Spring Data JPA, Hibernate, Spring Cloud, Spring Cloud Alibaba 枚举类 - 廖雪峰的官方网站 "},{"title":"实践手册","date":"2021-04-16T02:49:53.000Z","url":"/2021/04/16/%E5%AE%9E%E8%B7%B5%E6%89%8B%E5%86%8C/","tags":[["实践手册","/tags/PracticeManual/"]],"categories":[["手册","/categories/Handbook/"]],"content":"在本站中，通常会将&thinsp;[&thinsp;属于【手册】类型且以解决&thinsp;实践过程中遇到的问题&thinsp;为主干进行编纂编撰&thinsp;]&thinsp;的知识划分到【实践手册】的[标签]之中。 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"使用手册（Tutorial）","date":"2021-04-16T02:48:14.000Z","url":"/2021/04/16/%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","tags":[["使用手册","/tags/Tutorial/"]],"categories":[["手册","/categories/Handbook/"]],"content":" A tutorial, in education, is a method of transferring knowledge and may be used as a part of a learning process. More interactive and specific than a book or a lecture, a tutorial seeks to teach by example and supply the information to complete a certain task. A tutorial can be taken in many forms, ranging from a set of instructions to complete a task to an interactive problem solving session (usually in academia). 👆←🗎[1] 在本站中，通常会将&thinsp;[&thinsp;属于【手册】类型且以功能为主干进行编纂编撰&thinsp;]&thinsp;的知识划分到【使用手册】的[标签]之中。 📖参看 主要参看📖 Tutorial - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Tutorial - Wikipedia 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"理论手册（Theory Handbook）","date":"2021-04-16T00:39:46.000Z","url":"/2021/04/16/%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/","tags":[["理论手册","/tags/TheoryHandbook/"]],"categories":[["手册","/categories/Handbook/"]],"content":"在本站中，通常会将&thinsp;[&thinsp;属于【手册】类型且以理论数据为主干进行编纂编撰&thinsp;]&thinsp;的知识划分到【理论手册】的[标签]之中。 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"Java 理论手册","date":"2021-04-15T23:22:56.000Z","url":"/2021/04/15/Java-%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["理论手册","/tags/TheoryHandbook/"]],"categories":[["计算机科学","/categories/ComputerScience/"],["手册","/categories/ComputerScience/Handbook/"]],"content":" Java 是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级 Web 应用开发和移动应用开发。 👆←🗎[1] Java ← 定位 Java | 夜与花海 基础知识延伸知识拓展知识Java &amp; 设计模式 iluwatar/java-design-patterns: Design patterns implemented in Java Java ← 相关著作《Thinking in Java》 《Thinking in Java》（第4版） ← 整理手册 📖参看 主要参看📖 java · GitHub Topics 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Java - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon iluwatar/java-design-patterns: Design patterns implemented in Java java · GitHub Topics Snailclimb/JavaGuide: 「Java学习+面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！ "},{"title":"Java","date":"2021-04-15T02:30:04.000Z","url":"/2021/04/15/Java/","tags":[["计算机科学","/tags/ComputerScience/"],["Java","/tags/Java/"],["编程语言","/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" Java&thinsp;是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级&thinsp;Web&thinsp;应用开发和移动应用开发。 任职于&thinsp;Sun&thinsp;微系统的詹姆斯·高斯林等人于1990年代初开发&thinsp;Java&thinsp;语言的雏形，最初被命名为&thinsp;Oak，目标设置在家用电器等小型系统的编程语言，应用在电视机、电话、闹钟、烤面包机等家用电器的控制和通信。由于这些智能化家电的市场需求没有预期的高，太阳计算机系统（Sun&thinsp;公司）放弃了该项计划。随着1990年代互联网的发展，Sun&thinsp;公司看见&thinsp;Oak&thinsp;在互联网上应用的前景，于是改造了&thinsp;Oak，于1995年5月以&thinsp;Java&thinsp;的名称正式发布。Java&thinsp;伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。 Java编程语言的风格十分接近&thinsp;C++&thinsp;语言。继承了&thinsp;C++&thinsp;语言面向对象技术的核心，舍弃了容易引起错误的指针，以引用取代；移除了&thinsp;C++&thinsp;中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在&thinsp;Java SE 1.5&thinsp;版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。Sun&thinsp;微系统对&thinsp;Java&thinsp;语言的解释是：“Java&thinsp;编程语言是个简单、面向对象、分布式、解释性、健壮、安全与系统无关、可移植、高性能、多线程和动态的语言”。 Java&thinsp;不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了&thinsp;Java&thinsp;程序的运行效率。但在&thinsp;J2SE1.4.2&thinsp;发布后，Java&thinsp;的运行速度有了大幅提升。 与传统类型不同，Sun&thinsp;公司在推出&thinsp;Java&thinsp;时就将其作为开放的技术。全球的&thinsp;Java&thinsp;开发公司被要求所设计的&thinsp;Java&thinsp;软件必须相互兼容。“Java&thinsp;语言靠群体的力量而非公司的力量”是&thinsp;Sun&thinsp;公司的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司后来推出了与之竞争的&thinsp;.NET&thinsp;平台以及模仿&thinsp;Java&thinsp;的&thinsp;C#&thinsp;语言。后来&thinsp;Sun&thinsp;公司被甲骨文公司并购，Java&thinsp;也随之成为甲骨文公司的产品。 现时，移动操作系统&thinsp;Android&thinsp;大部分的代码采用&thinsp;Java&thinsp;编程语言编程。 👆←🗎[1] 官方资源 Java SE 文档 — API 和文档 | Oracle 中国 百科 &thinsp;维基百科&ensp;👆 历史早期的Java 语言最开始只是Sun计算机（Sun MicroSystems）公司在1990年12月开始研究的一个内部项目。Sun计算机公司的一个叫做帕特里克·诺顿的工程师被公司自己开发的C++和C语言编译器搞得焦头烂额，因为其中的API极其难用。帕特里克决定改用NeXT，同时他也获得了研究公司的一个叫做“Stealth计划”的项目的机会。 “Stealth计划”后来改名为“Green计划”，詹姆斯·高斯林和麦克·舍林丹（Mike Sheridan）也加入了帕特里克的工作小组。他们和其他几个工程师一起在加利福尼亚州门罗帕克市沙丘路的一个小工作室里面研究开发新技术，瞄准下一代智能家电（如微波炉）的程序设计，Sun公司预料未来科技将在家用电器领域大显身手。团队最初考虑使用C++语言，但是很多成员包括Sun的首席科学家比尔·乔伊，发现C++和可用的API在某些方面存在很大问题。 工作小组使用的是嵌入式系统，可以用的资源极其有限。很多成员发现C++太复杂以至很多开发者经常错误使用。他们发现C++缺少垃圾回收系统，还有可移植的安全性、分布程序设计、和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。 根据可用的资金，乔伊决定开发一种集C语言和Mesa语言大成的新语言，在一份报告上，乔伊把它叫做“未来”，他提议Sun公司的工程师应该在C++的基础上，开发一种面向对象的环境。最初，高斯林试图修改和扩展C++的功能，他自己称这种新语言为C++ ++，但是后来他放弃了。他将要创造出一种全新的语言，被他命名为“Oak”（橡树），以他的办公室外的橡树命名。 就像很多开发新技术的秘密工程一样，工作小组没日没夜地工作到了1993年的夏天，他们能够演示新平台的一部分了，包括Green操作系统，Oak的程序设计语言，类库及其硬件。最初的尝试是面向一种类PDA设备，被命名为Star7，这种设备有鲜艳的图形界面和被称为“Duke”的智能代理来帮助用户。1992年12月3日，这台设备进行了展示。 同年11月，Green计划被转化成了“FirstPerson有限公司”，一个Sun公司的全资子公司，团队也被重新安排到了帕洛阿尔托。FirstPerson团队对建造一种高度交互的设备感兴趣，当时代华纳发布了一个关于电视机顶盒的征求提议书时（Request for proposal），FirstPerson改变了他们的目标，作为对征求意见书的响应，提出了一个机顶盒平台的提议。但是有线电视业界觉得FirstPerson的平台给予用户过多的控制权，因此FirstPerson的投标败给了SGI。与3DO公司的另外一笔关于机顶盒的交易也没有成功，由于他们的平台不能在电视工业产生任何效益，公司被并回Sun公司。 Java和“Java” 由于商标搜索显示Oak已被一家显卡制造商注册。于是同年，Oak被改名为Java。当使用十六进制编辑器打开由Java源代码编译出的二进制文件（.class文件）的话，最前面的32位将显示为CA FE BA BE，即词组“CAFE BABE”（咖啡屋宝贝）。 Java和互联网 1994年6月，在同约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·施密特经历了一场历时三天的头脑风暴后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。 1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java 1.0a版本已经可以提供下载，但是Java和HotJava浏览器的第一次公开发布却是在1995年3月23日SunWorld大会上进行的。升阳公司的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，Sun公司成立了Java业务集团，专门开发Java技术。 在流行几年之后，Java在浏览器中的地位被逐步侵蚀。它在简单交互性动画方面的用途已经完全被Adobe公司的Flash排挤，2005年Java倾向只被用于雅虎游戏那样的更为复杂的应用程序。Java同时遭受到来自微软的反对，他们决定在新版本的Internet Explorer和Windows中不再附带Java平台。 与此相反，在万维网的服务器端和手持设备上，Java变得更加流行。很多网站在后端使用JSP和其他的Java技术。 在桌面系统上，独立的Java程序还是相对少见这是因为Java平台的运行开销较大，而许多人的电脑上没有安装Java，由于网络带宽在以前较小，下载Java曾经是个耗时的事情。但是随着计算机计算能力、网络带宽在10年中获取了很大的进步，同时虚拟机和编译器的质量得到了提高，许多应用程序得到了广泛的使用，包括： 开源软件 NetBeans和Eclipse等软件开发工具 Android操作系统 JEdit Azureus BitTorrent客户端。 JNode操作系统 Apache软件基金会的Ant、Derby、Hadoop、Jakarta、POI和Tomcat JBoss和GlassFish应用服务器 商业软件 EIOffice（永中Office） Minecraft 纯Java 3D游戏合金战士Chrome IBM Websphere、ColdFusion和WebLogic IntelliJ IDEA 目前Java提供以下三个版本： Java Platform, Enterprise Edition（Java EE：Java平台企业版） Java Platform, Standard Edition（Java SE：Java平台标准版） Java Platform, Micro Edition（Java ME：Java平台微型版） Java Platform, Card Edition Java开放源代码项目 2006年SUN在JavaOne公布Java 开放源代码项目，并推出OpenJDK计划。Java虚拟机、Java编译器和Java类库以GNU通用公共许可证公开。 版本历史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年12月，SUN公司发布Java EE 6 2010年11月，由于Oracle公司对于Java社区的不友善，因此Apache扬言将退出JCP 2011年7月28日，Oracle公司发布Java SE 7 2014年3月18日，Oracle公司发表Java SE 8 2017年9月21日，Oracle公司发表Java SE 9 2018年3月21日，Oracle公司发表Java SE 10 2018年9月25日，Java SE 11发布 语言特性 Java之所以被开发，是要达到以下五个目的： 应当使用面向对象程序设计方法学 应当允许同一程序在不同的计算机平台执行 应当包括内建的对计算机网络的支持 应当被设计成安全地执行远端代码 应当易于使用，并借鉴以前那些面向对象语言（如C++）的长处。 Java技术主要分成几个部分：Java语言、Java运行环境、类库。一般情况下说Java时并不区分指的是哪个部分。 Java在1.5版本时，做了重大改变，Sun公司并1.5版本重命名为Java 5.0。 面向对象 Java的特点之一就是面向对象，是程序设计方法的一种。“面向对象程序设计语言”的核心之一就是开发者在设计软件的时候可以使用自定义的类型和关联操作。代码和数据的实际集合体叫做“对象”。一个对象可以想象成绑定了很多“行为（代码）”和“状态（数据）”的物体。对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。 跨平台性 跨平台性是Java主要的特性之一，跨平台使得用Java语言编写的程序可以在编译后不用经过任何更改，就能在任何硬件设备条件下运行。这个特性经常被称为“一次编译，到处运行”。 执行Java应用程序必须安装Java 运行时环境（Java Runtime Environment，JRE），JRE包括Java虚拟机（Java Virtual Machine，JVM），以及Java平台核心类和基础Java 平台库。通过JVM才能在电脑系统执行Java应用程序（Java Application），这与.Net Framework的情况一样，所以电脑上没有安装JVM，那么这些java程序将不能够执行。 实现跨平台性的方法是大多数编译器在进行Java语言程序的编码时候会生成一个用字节码写成的“半成品”，这个“半成品”会在Java虚拟机（解释层）的帮助下运行，虚拟机会把它转换成当前所处硬件平台的原始代码。之后，Java虚拟机会打开标准库，进行数据（图片、线程和网络）的访问工作。主要注意的是，尽管已经存在一个进行代码翻译的解释层，有些时候Java的字节码代码还是会被JIT编译器进行二次编译。 有些编译器，比如GCJ，可以自动生成原始代码而不需要解释层。但是这些编译器所生成的代码只能应用于特定平台。并且GCJ目前只支持部分的Java API。 甲骨文公司对于Java的许可是“全兼容的”，这也导致了微软和升阳关于微软的程序不支持RMI和JNI接口、并且增加特性为己所用的法律争端。升阳最终赢得了官司，获得了大约两千万美元的赔偿，法院强制要求微软执行升阳公司关于Java的许可要求。作为回应，微软不再在Windows系统中捆绑Java，最新的Windows版本，Windows Vista和Internet Explorer 7.0版本也不再提供对于Java应用程序和控件的支持。但是升阳公司和其他使用Java运行时系统的公司在Windows操作系统下对用户提供无偿的第三方插件和程序支持。 Java语言使用解释层最初是为了轻巧性。所以这些程序的运行效率比C语言和C++要低很多，用户也对此颇有微词。很多最近的调查显示Java的程序运行速度比几年前要高出许多，有些同样功能的程序的效率甚至超过了C++和C语言编写的程序。 Java语言在最开始应用的时候是没有解释层的，所有需要编译的代码都直接转换成机器的原始代码。这样做虽然使程序获得了最佳的性能，但是导致程序异常臃肿。从JIT技术开始，Java的程序都经过一次转换之后才变成机器码。很多老牌的第三方虚拟机都使用一种叫做“动态编译”的技术，也就是说虚拟机实时监测和分析程序的运行行为，同时选择性地对程序所需要的部分进行编译和优化。所有这些技术都改善了代码的运行速度，但是又不会让程序的体积变得失常。 程序的轻便性事实上是软件编写很难达到的一个目标，Java虽然成功地实现了“一次编译，到处运行”，但是由于平台和平台之间的差异，所编写的程序在转换代码的时候难免会出现微小的、不可察觉的错误和意外。有些程序员对此非常头疼，他们嘲笑Java的程序不是“一次编译，到处运行”，而是“一次编译，到处调试”。以Java AWT为例，早期Java AWT内提供的按钮、文字区等均是以计算机系统所默认的样式而显示。这令Java程序在有些没有提供图案的计算机系统产生错误（在Microsoft Windows设有窗口管理器，在一些Linux distribution则没有）。后来SUN公司针对Java AWT一些问题而推出Java Swing。 平台无关性让Java在服务器端软件领域非常成功。很多服务器端软件都使用Java或相关技术创建。 自动垃圾回收（Garbage Collection） C++语言被用户诟病的原因之一是大多数C++编译器不支持垃圾收集机制。通常使用C++编程的时候，程序员于程序中初始化对象时，会在主机存储器堆栈上分配一块存储器与地址，当不需要此对象时，进行析构或者删除的时候再释放分配的存储器地址。如果对象是在堆栈上分配的，而程序员又忘记进行删除，那么就会造成存储器泄漏（Memory Leak）。长此以往，程序运行的时候可能会生成很多不清除的垃圾，浪费了不必要的存储器空间。而且如果同一存储器地址被删除两次的话，程序会变得不稳定，甚至崩溃。因此有经验的C++程序员都会在删除之后将指针重置为NULL，然后在删除之前先判断指针是否为NULL。 C++中也可以使用“智能指针”（Smart Pointer）或者使用C++托管扩展编译器的方法来实现自动化存储器释放，智能指针可以在标准类库中找到，而C++托管扩展被微软的Visual C++ 7.0及以上版本所支持。智能指针的优点是不需引入缓慢的垃圾收集机制，而且可以不考虑线程安全的问题，但是缺点是如果不善使用智能指针的话，性能有可能不如垃圾收集机制，而且不断地分配和释放存储器可能造成存储器碎片，需要手动对堆进行压缩。除此之外，由于智能指针是一个基于模板的功能，所以没有经验的程序员在需要使用多态特性进行自动清理时也可能束手无策。 Java语言则不同，上述的情况被自动垃圾收集功能自动处理。对象的创建和放置都是在存储器堆栈上面进行的。当一个对象没有任何引用的时候，Java的自动垃圾收集机制就发挥作用，自动删除这个对象所占用的空间，释放存储器以避免存储器泄漏。 注意程序员不需要修改finalize方法，自动垃圾收集也会发生作用。但是存储器泄漏并不是就此避免了，当程序员疏忽大意地忘记解除一个对象不应该有的引用时，存储器泄漏仍然不可避免。 不同厂商、不同版本的JVM中的存储器垃圾回收机制并不完全一样，通常越新版本的存储器回收机制越快，IBM、BEA、SUN等等开发JVM的公司都曾宣称过自己制造出了世界上最快的JVM，JVM性能的世界纪录也在不断的被打破并提高。 IBM有一篇有关Java存储器回收机制比不激活垃圾收集机制的C++存储器处理快数倍的技术文章，而著名的Java技术书籍《Java编程思想》（Thinking in Java）也有一段论述Java存储器及性能达到甚至超过C++的章节。 基本语法 编写Java程序前应注意以下几点： 大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。 类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如MyFirstJavaClass。 方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod。 源文件名：源文件名必须和文件内名字唯一且公开(由public关键词修饰)的类名相同。当保存文件的时候，你应该使用该类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。 主方法入口：所有的Java程序由public static void main(String[] args)方法开始执行。 Java关键字下面列出了Java关键字。这些关键字不能用于常量、变量、和任何标识符的名称。 类别 关键字 说明 访问控制 private 私有的 protected 受保护的 public 公共的 类、方法和变量修饰符 abstract 声明抽象 class 类 extends 扩充,继承 final 最终值,不可改变的 implements 实现（接口） interface 接口 native 本地，原生方法（非Java实现） new 新,创建 static 静态 strictfp 严格,精准 synchronized 线程,同步 transient 短暂 volatile 易失 程序控制语句 break 跳出循环 case 定义一个值以供switch选择 continue 继续 default 默认 do 运行 else 否则 for 循环 if 如果 instanceof 实例 return 返回 switch 根据值选择执行 while 循环 错误处理 assert 断言表达式是否为真 catch 捕捉异常 finally 有没有异常都执行 throw 抛出一个异常对象 throws 声明一个异常可能被抛出 try 捕获异常 包相关 import 引入 package 包 基本类型 boolean 布尔型 byte 字节型 char 字符型 double 双精度浮点 float 单精度浮点 int 整型 long 长整型 short 短整型 null 空 变量引用 super 父类,超类 this 本类 void 无返回值 保留关键字 goto 是关键字，但不能使用 const 是关键字，但不能使用 注释 注释的作用：标识程序是干什么的，以及它是如何构建的。注释帮助程序员进行相互沟通以及理解程序。注释不是程序设计语言，所以编译器编译程序时忽略它们。 接口和类别 Java自带了创建接口的类别，可以这样使用： 这段代码的意思是任何实现（implement）Deleteable接口的类别都必须实现delete()方法。每个类别对这个方法的实现可以自行定制。由此概念可以引出很多种使用方法，下面是一个类别的例子： 在另外一个类别中，可以使用这样的代码： 因为队列中所有的对象都可以使用delete()方法。Deleteable队列中包含Fred对象的引用，而这个类别和其他Deleteable类别在使用deleteAll()方法时候不需要进行任何改变。 之所以这样做就是为了在接口的执行和其代码之间进行区别。举例来说，一个名叫Collection的接口可以包含任何对象所需要的引入、转换和存储数据的方法，其他的类都可以使用这个接口。但是这个接口可以是一个可重定义大小的队列、一个链表或者是其他功能的集合。 这种特性其实是一种折中的办法。Java的设计者们不想让Java有多重继承的特性，因为C++的多重继承显示了这种特性的困难。Java的接口功能可以提供同样的功能，但是又不会很复杂。 应用程序开发接口 在Java语言中，应用程序接口（API）化身成类，并且分组成为包。每个包中包含有相关的接口和类。对于不同的平台，Java提供了不同版本的包。API的设定由sun公司和其他公司通过JCP（Java社区程序）决定。任何公司和个人都可以参与这个工程，对API进行设计。2004年，IBM和BEA公司准备联合对官方的Java开源软件工程进行支持，但是2005年初，sun公司拒绝了这个支持。 Hello World 下面这个程序显示“Hello, world!”然后结束运行，注意java.lang包是自动加载的，所以不需要在程序之前加入import java.lang.*; 关于Java的批评 Java试图通过新的方式解决软件编写的复杂性。很多人认为Java语言做到了它承诺的一切。但是Java并不是一门完美的语言。 整体性问题 并不是所有的工程和环境需要企业等级的复杂性，比如一个简单的个人网站或者独自编程的程序师所写的程序。这些程序师会发现Java的复杂管理对于自己要做的程序来说过于强大了。一些人觉得Java在面向对象上面做的没有Ruby和Smalltalk纯粹。但是最新出现的用Java实现的语言Groovy解决了这些问题。 作为一种已经创建的新技术，Java显然综合了很多语言的特性，比如C++、C语言、Python等等。一些对于Java的评论认为Java的不变性在动摇。 语言问题 有些程序师不喜欢原始类型（primitive type）和类别（class）的分离，尤其是那些曾经使用过Smalltalk和Ruby的程序员。Java的代码相对于其他的代码来说过于冗长，这与它的轻便化声明相违背。此外Java一般也会默认式的自动植入过多的标准库代码,导致整体运行会出现缓慢 Java是一种单继承的语言。这也导致了程序师在试图使用多重继承时候的不便，而很多语言都可以使用这个特性。但是Java可以使用接口类，把多重继承可能导致的风险减少到最小。Java不支持运算符重载，这是为了防止运算符重载使得代码的功能变得不清晰。但是用Java实现的语言Groovy可以进行运算符重载。过去Java对于文本的操作和其他语言，比如Perl和PHP相比差的较多，但Java在1.4版本时候引入了正则表达式。 至Java 1.7为止，Java语言不支持闭包（closure）和混入（mixin）特性。Java 1.8加入lambda表达式（Lambda Expressions）。 类库问题 使用Swing平台编写的带有GUI（图形用户界面）的程序和其他原始程序非常不同。选用AWT工具包编写程序的程序师看到的都是原始接口，而且也无法获得先进的GUI编程支持，如果使用的话，就要提供每个平台上面所需的API，这将是一项庞大的工程。Swing则是完全用Java语言所写的程序，避免了接口元素重复的问题，只使用所有平台都支持的最基本的绘图机制。但是很多用户不知道如何在Java风格和Windows风格之间进行转换，结果造成了Java程序的接口在很多程序中非常特殊。苹果计算机已经提供了优化过的Java运行时程序，包含了Mac OS X的经典Aqua接口风格。 在IBM捐赠给Eclipse基金会的SWT界面框架中，用户会看到熟悉的本地风格界面。但这又引起了不同喜好的开发人员之间的争论。 性能问题 由于Java编译器和虚拟机的不同对Java代码的性能影响比语言本身的影响大的多，所以统一讨论Java的程序的性能经常是有误导性的。据IBM的资料，在同样的硬件上2001年时的IBM JDK版本的性能是1996年的JDK版本的十倍左右。而即使是在同一时期，不同公司的JDK和JRE的性能也不一样，比如SUN、IBM、BEA等公司都有自己开发的JDK和JRE。 Java语言的一些特性不可避免的有额外的性能代价，例如数组范围检查、运行时类型检查等等。Java程序的性能还会因为不同的动态复杂性和垃圾处理机制使用的多少而各有不同。如果JVM的实现比较优化的话，那么这些功能甚至可以增加存储器分配的性能。这和总是使用STL或者托管C++的程序的情况类似。 尽管如此，仍然有许多人认为Java的性能低。这部分归因于Sun公司最初的JVM实现使用未优化的解释机制来运行字节码。一些新版本的JVM使用Just-In-Time（JIT）编译器，在加载字节码的时候将其编译成针对运行环境的本地代码来实现一些本地编译器的优化特性。Just-In-Time机制和本地编译的性能比较仍旧是一个有争议的话题。JIT编译需要很多时间，对于运行时间不长或者代码很多的大型程序并不适宜。但是不算JIT编译阶段的话，程序的运行性能在很多JVM下可以和本地编译的程序一争短长，甚至在一些计算比较密集的数值计算领域也是这样。目前，Java已经使用更先进的HotSpot技术来代替JIT技术，Java的性能有了更进一步的提升。另外，在使用-server选项运行Java程序时，也可以对Java进行更深入的优化，比如在运行时将调用较多的方法内联（inline）到程序中来提高运行速度，这就是所谓的“动态优化”，而本地编译器是无法做到这一点的；这也是一些Java代码比对应用C/C++等语言编写的本地代码运行的更快的原因之一。微软的.NET平台也使用JIT编译器，所以也有类似问题。 Java的设计目的主要是安全性和可携性，所以对于一些特性，比如对硬件架构和存储器地址访问的直接访问都被去除了。如果需要间接调用这些底层功能的话，就需要使用JNI（Java本地接口）来调用本地代码，而间接访问意味着频繁调用这些特性时性能损失会很大，微软的.NET平台也有这样的问题。所以到目前为止，性能敏感的代码，例如驱动程序和3D电子游戏，还是大多使用本地编译，甚至直接以不直接支持面向对象的C语言或机器代码编写。但最近已经有了许多用纯Java编写的3D游戏，其效果与用C语言编写的不相上下，例如“合金战士”（英文名：Chrome）。这主要是因为新版的Java 3D技术已经能像C++一样调用硬件加速，也就是使用显卡来加速，无论是C++还是Java语言写的3D游戏都是使用显卡及GPU来处理，从而使得CPU可以专注于其他方面的工作。 用途 桌面GUI应用程序： Java通过抽象窗口工具包（AWT），Swing和JavaFX等多种方式提供GUI开发。虽然AWT包含许多预先构建的组件，如菜单，按钮，列表以及众多第三方组件，但Swing（一个GUI小部件工具包）还提供某些高级组件，如树，表格，滚动窗格，选项卡式面板和列表。JavaFX是一组图形和媒体包，提供了Swing互操作性，3D图形功能和自包含的部署模型，可以快速编写Java小应用程序和应用程序的脚本。[21] 移动应用程序： Java Platform，Micro Edition（Java ME或J2ME）是一个跨平台框架，用于构建可在所有Java支持的设备（包括功能手机和智能手机）上运行的应用程序。此外，最受欢迎的移动操作系统之一的Android应用程序通常使用Android软件开发工具包（SDK）或其他环境在Java中编写脚本。 嵌入式系统： 从微型芯片到专用计算机的嵌入式系统是执行专门任务的大型机电系统的组件。诸如SIM卡，蓝光光盘播放器，公用事业仪表和电视机等多种设备都使用嵌入式Java技术。据甲骨文公司称，100％的蓝光光盘播放器和1.25亿台电视设备都采用Java技术。 Web应用程序： Java通过Servlets，Struts或JSP提供对Web应用程序的支持。编程语言提供的简单编程和更高的安全性使得大量政府应用程序可用于基于Java的健康，社会安全，教育和保险。Java也可以使用Broadleaf等开源电子商务平台开发电子商务Web应用程序。 Web服务器和应用程序服务器： 今天的Java生态系统包含多个Java Web服务器和应用程序服务器。虽然Apache Tomcat，Simple，Jo !, Rimfaxe Web服务器（RWS）和Project Jigsaw占据了Web服务器空间，但WebLogic，WebSphere和Jboss EAP在商业应用服务器领域占据重要地位[22]。 企业应用程序： Java企业版（Java EE）是一种流行的平台，为脚本和运行企业软件（包括网络应用程序和Web服务）提供API和运行时环境。甲骨文宣称Java在97％的企业计算机上运行。Java中更高的性能保证和更快的计算能力导致像Murex这样的高频交易系统被编入脚本中。它也是各种银行应用程序的中枢，它们将Java从前端用户端运行到后端服务器端。 科学应用：Java是许多软件开发人员用于编写涉及科学计算和数学运算的应用程序的选择。这些程序通常被认为是快速和安全的，具有更高的便携性和低维护性。像MATLAB这样的应用程序使用Java来交互用户界面和作为核心系统的一部分。 手册 站内手册 Java 理论手册 | 夜与花海 《Thinking in Java》（第4版） ← 整理手册 相关著作 《Thinking in Java》 📖参看 主要参看📖 Java (programming language) - Wikipedia Java - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Java - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon Java SE 文档 — API 和文档 | Oracle 中国 "},{"title":"Git理论手册","date":"2021-04-15T02:21:43.000Z","url":"/2021/04/15/Git%E7%90%86%E8%AE%BA%E6%89%8B%E5%86%8C/","tags":[["Git","/tags/Git/"],["手册","/tags/Handbook/"],["计算机科学","/tags/ComputerScience/"]],"categories":[["计算机科学","/categories/ComputerScience/"],["手册","/categories/ComputerScience/Handbook/"]],"content":" 👆←🗎[1] 📖参看 主要参看📖 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"Git使用手册","date":"2021-04-15T01:48:17.000Z","url":"/2021/04/15/Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","tags":[["Git","/tags/Git/"],["手册","/tags/Handbook/"],["信息技术","/tags/InformationTechnology/"]],"categories":[["信息技术","/categories/InformationTechnology/"],["手册","/categories/InformationTechnology/Handbook/"]],"content":" 👆←🗎[1] 📖参看 主要参看📖 Git远程操作详解 - 阮一峰的网络日志 常用 Git 命令清单 - 阮一峰的网络日志 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） 使用GitHub - 廖雪峰的官方网站 ※参考和引用 ^&ensp;维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"Git","date":"2021-04-13T22:55:44.000Z","url":"/2021/04/13/Git/","tags":[["Git","/tags/Git/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. Git is easy to learn and has a tiny footprint with lightning fast performance. It outclasses SCM tools like Subversion, CVS, Perforce, and ClearCase with features like cheap local branching, convenient staging areas, and multiple workflows. 👆←🗎[1] git（/ɡɪt/， &thinsp;音频[帮助&thinsp;·&thinsp;信息]，吉特）是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以&thinsp;GPL&thinsp;发布。最初目的是为更好地管理&thinsp;Linux&thinsp;内核开发而设计。应注意的是，这与GNU Interactive Tools（一个类似&thinsp;Norton Commander&thinsp;界面的文件管理器）不同。 git&thinsp;最初的开发动力来自于&thinsp;BitKeeper&thinsp;和&thinsp;Monotone。git&thinsp;最初只是作为一个可以被其他前端（比如&thinsp;Cogito&thinsp;或&thinsp;Stgit）包装的后端而开发的，但后来&thinsp;git&thinsp;内核已经成熟到可以独立地用作版本控制。很多著名的软件都使用&thinsp;git&thinsp;进行版本控制，其中包括&thinsp;Linux&thinsp;内核、X.Org&thinsp;服务器和&thinsp;OLPC&thinsp;内核等项目的开发流程。 👆←🗎[2] Git是一个免费的开源 分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。 官方资源 &ensp; &ensp; 官方文档 百科 &thinsp;维基百科&ensp;👆 历史 自2002年开始，林纳斯·托瓦兹决定使用BitKeeper作为Linux内核主要的版本控制系统用以维护代码。因为BitKeeper为专有软件，这个决定在社区中长期遭受质疑。在Linux社区中，特别是理查德·斯托曼与自由软件基金会的成员，主张应该使用开放源代码的软件来作为Linux内核的版本控制系统。林纳斯·托瓦兹曾考虑过采用现成软件作为版本控制系统（例如Monotone），但这些软件都存在一些问题，特别是性能不佳。现成的方案，如CVS的架构，受到林纳斯·托瓦兹的批评。 2005年，安德鲁·垂鸠写了一个简单程序，可以连接BitKeeper的存储库，BitKeeper著作权拥有者拉里·麦沃伊认为安德鲁·垂鸠对BitKeeper内部使用的协议进行逆向工程，决定收回无偿使用BitKeeper的许可。Linux内核开发团队与BitMover公司进行磋商，但无法解决他们之间的歧见。林纳斯·托瓦兹决定自行开发版本控制系统替代BitKeeper，以十天的时间编写出git第一个版本。 👆←🗎[3] 主要功能 git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。git的速度很快，这对于诸如Linux内核这样的大项目来说自然很重要。git最为出色的是它的合并追踪（merge tracing）能力。 👆←🗎[4] 更多👆 实际上内核开发团队决定开始开发和使用git来作为内核开发的版本控制系统的时候，世界上开源社区的反对声音不少，最大的理由是git太艰涩难懂，从git的内部工作机制来说，的确是这样。但是随着开发的深入，git的正常使用都由一些友善的命令来执行，使git变得非常好用。现在，越来越多的著名项目采用git来管理项目开发，例如：wine、U-boot等。 作为开源自由原教旨主义项目，git没有对版本库的浏览和修改做任何的权限限制，通过其他工具也可以达到有限的权限控制，比如：gitosis、CodeBeamer MR。原本git的使用范围只适用于Linux/Unix平台，但在Windows平台下的使用也日渐成熟，这主要归功于Cygwin、msysgit环境，以及TortoiseGit这样易用的GUI工具。git的源代码中也已经加入了对Cygwin与MinGW编译环境的支持且逐渐完善，为Windows用户带来福音。 实现原理 git和其他版本控制系统（如CVS）有不小的差别，git本身关心文件的整体性是否有改变，但多数的版本控制系统如CVS或Subversion系统则在乎文件内容的差异。git拒绝保持每个文件的版本修订关系。因此查看一个文件的历史需要遍历各个history快照；git隐式处理文件更名，即同名文件默认为其前身，如果没有同名文件则在前一个版本中搜索具有类似内容的文件。 git更像一个文件系统，直接在本机上获取资料，不必连线到主机端获取资料。 每个开发者都可有全部开发历史的本地副本，changes从这种本地repository复制给其他开发者。这些changes作为新增的开发分支被导入，可以与本地开发分支合并。 分支是非常轻量级的，一个分支仅是对一个commit的引用。 git是用C语言开发的，以追求最高的性能。git自动完成垃圾回收，也可以用命令git gc –prune直接调用。 git存储每个新创建的object作为一个单独文件。为了压缩存储空间占用， packs操作把很多文件（启发式类似名字的文件往往具有类似内容）使用差分压缩入一个文件中（packfile），并创建一个对应的索引文件，指明object在packfile中的偏移值。新创建的对象仍然作为单独文件存在。repacks操作非常费时间，git会在空闲时间自动做此操作。也可用命令git gc来直接启动repack。packfile与索引文件都用SHA-1作为校验和并作为文件名。git fsck命令做校验和的完整性验证。 Git服务器典型的TCP监听端口为9418。 👆←🗎[5] 库目录 hooks：存储钩子的文件夹 refs：存储指向各个分支的指针（SHA-1标识）文件 objects：存放git对象 config：存放各种设置文档 HEAD：指向当前所在分支的指针文件路径，一般指向refs下的某文件 数据结构 Git有两种数据结构：可变的索引（index或stage或cache)用于缓冲工作目录信息与下一次提交的版本信息；不变的、仅追加的对象数据库。 对象数据库包含4类对象： blob (二进制大对象)是使用zlib压缩算法对一个文件的内容压缩后的结果。Blobs没有保存文件名、时间戳或其他元数据。Git将其存储在位于隐藏的.git/objects文件夹中。文件的名称为使用SHA-1哈希函数对原文件内容生成的哈希值。这些对象文件称为Blob，每次将新文件添加到存储库时会创建Blob对象。 tree对象对应于文件目录。包含文件名列表以及文件的类型比特（包含许可权）、到blob（对应于文件）或tree对象的引用。tree对象是源树(source tree)的快照。用默克尔树实现。 commit对象链接tree对象在一起而成为history，包含顶层源目录的tree对象名字、一个时间戳、log信息、0个或多个父commit对象的名字。用于保存特定版本的树型文件夹结构以及提交作者，电子邮件地址，日期和描述性提交消息。 tag对象是一个容器，包含了到另一个对象的引用，也可以增加关于另外对象的元数据。通常它保存需要追溯的特定版本数据的一个commit对象的数字签名。 以上4类的对象用其内容的SHA-1 hash值标识：hash值的前两个字符作为存放的目录名字，其余hash字符作为这个对象的文件名。 👆←🗎[6] 更多👆 Git数据库中不变引用的对象将会被垃圾回收清除。Git命令可以创建、移动、删除引用。”git show-ref”列出所有引用。某些引用类型： heads: 引用一个本地对象，是commit的指针。每个head可以指任意一个这样的指针。可以包含任意数量的heads。而”HEAD”（全部大写），仅仅指的是当前有效的head。默认情况下，在每个仓库下都有一个head，叫做master。remotes: 引用远程repository中的一个对象stash: 引用一个还没有committed的一个对象meta: 例如一个bare repository中的一个配置, 用户权限; refs/meta/config名字空间等tags:某些操作（例如，将提交推送到远程存储库，存储太多对象或手动运行Git的垃圾收集命令）可能会导致Git将对象重新打包为打包文件，在打包过程中，采用反向差异并进行压缩以消除多余的内容并减小尺寸。该过程将生成包含对象内容的.pack文件，每个文件都有一个对应的.idx索引文件，其中包含对打包对象及其在打包文件中位置的引用。当将分支推送到远程存储库或从远程存储库拉出分支时，这些打包文件将通过网络传输。提取或获取分支时，将打包文件解压缩以在对象存储库中创建松散对象。 移植性 在Windows平台上有msysgit与TortoiseGit可使用。TortoiseGit还提供有GUI。 git也提供windows版本下载。 Visual Studio 自 2013 版本开始内置 Git 功能。 👆←🗎[7] GIT GUI 客户端 GitHub Desktop：可用于第三方Git仓库网站 Git for Windows TortoiseGit SourceTree GitEye 👆←🗎[8] 📖参看 主要参看📖 分布式版本控制 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;Git&thinsp;官方网站 ^&ensp;git - 维基百科，自由的百科全书 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#歷史 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#主要功能 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#实现原理 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#数据結構 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#移植性 ^&ensp;[&thinsp;git - 维基百科，自由的百科全书&thinsp;]#GIT_GUI客户端 🔗外部链接 Wikipedia’s external link ltr-icon En-us-git.ogg - Wikipedia File:En-us-git.ogg - Wikipedia git/git: Git Source Code Mirror - This is a publish-only repository and all pull requests are ignored. Please follow Documentation/SubmittingPatches procedure for any of your improvements. Help:媒体帮助 - 维基百科，自由的百科全书 帮助:英语国际音标 - 维基百科，自由的百科全书 "},{"title":"法律","date":"2021-04-13T15:38:28.000Z","url":"/2021/04/13/%E6%B3%95%E5%BE%8B/","tags":[["法律","/tags/Law/"]],"categories":[["undefined",""]],"content":"心无良知，行不道德，谈何法律！ 法律（英语：Law） 是一种由规则组成的体系，经由社会组织来施予强制力量，规范个人行为。法律是一系列的规则，通常需要经由一套制度来落实。但在不同的地方，法律体系会以不同的方式来阐述人们的法律权利与义务。其中一种区分的方式便是分为欧陆法系和英美法系两种。有些国家则会以他们的宗教法条为其法律的基础。 学者们从许多不同的角度来研究法律，包括从法制史和哲学，或从如经济学与社会学等社会科学的方面来探讨。法律的研究来自于对何为平等、公正和正义等问题的讯问，这并不都总是简单的。 在一个典型的三权分立国家中，创造和解释法律的核心机构为政府的三大部门：公正不倚的司法、民主的立法和负责的行政。而官僚、军事和警力则是执行法律，并且让法律为人民服务时相当重要的部分。除此之外，若要支持整个法律系统的运作，同时带动法律的进步，则独立自主的法律专业人员和充满生气的公民社会也是不可或缺的一部分。 古希腊哲学家亚里斯多德于公元前350年写道：“法治比任何一个人的统治来得更好。” 👆←🗎[1] 宪法和行政法管理著国家的事务。宪法关注于行政、立法与司法间的关系，以及人权或国家内个人的公民自由。大多数的国家，如美国和法国等国家都只有一部成文宪法，并辅以权利法案。而中华民国宪法则于宪法成文法典条文本文规制人民之基本权。但少部分如英国之类的国家并没有这样的条文；在这些国家里，宪法是由法条、判例和惯例所构成的。在一名为恩蒂克诉卡林顿案一案中，描述了一个普通法里的宪法原则。恩蒂克的房子被卡林顿警长搜索并拿走了一个东西。当恩蒂克在法庭上控诉时，卡林顿警长回驳说他有政府首长的授权。但是，并没有成文的法令条文或法院授权。主审法官查理斯·普拉特说： “ 人们进入社会的重大目的是为了保全他们的财产。这个权利在任何时刻都是神圣且不可侵犯的，亦不会因公法上所谓的公众利益而被夺取或缩减…若不能找到或形成任何的原因，书本的沉默将会是对被告的职权，而原告必然会得到一个决断。 ” 由约翰·洛克提出的一个基本的宪法原则为：个人可以做任何事情，除非法律禁止；且政府不能做任何事情，除非法律许可。行政法是人民监督政权的主要方法。人民可以对地方议会、公共服务或政府部门的作为或决定提出司法审查，以确定它们是否有遵行法律。之后，第一个专门的行政法院——法国行政院议会成立于1799年，正值拿破仑夺权之时。 👆←🗎[2] 在本站中，【法律】[标签]往往和【道德】[标签]一起使用；通常情况下，[&thinsp;主要涉及&thinsp;法律&thinsp;]&thinsp;的知识&thinsp;会被划分到【法律】的[标签]之中。 ※参考和引用 ^&ensp;法律 - 维基百科，自由的百科全书 ^&ensp;[&ensp;法律 - 维基百科，自由的百科全书&ensp;]#憲法與行政法 Law - Wikipedia 更多👆 中华人民共和国宪法 - 维基百科，自由的百科全书 中华人民共和国宪法修正案 (2018年) - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Conscience - Wikipedia Morality - Wikipedia 道德 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 良知 - 维基百科，自由的百科全书 "},{"title":"良心","date":"2021-04-13T14:47:15.000Z","url":"/2021/04/13/%E8%89%AF%E5%BF%83/","tags":[["良心","/tags/Conscience/"]],"categories":[["undefined",""]],"content":" Conscience is a cognitive process that elicits emotion and rational associations based on an individual’s moral philosophy or value system. Conscience stands in contrast to elicited emotion or thought due to associations based on immediate sensory perceptions and reflexive responses, as in sympathetic central nervous system responses. In common terms, conscience is often described as leading to feelings of remorse when a person commits an act that conflicts with their moral values. An individual’s moral values and their dissonance with familial, social, cultural and historical interpretations of moral philosophy are considered in the examination of cultural relativity in both the practice and study of psychology. The extent to which conscience informs moral judgment before an action and whether such moral judgments are or should be based on reason has occasioned debate through much of modern history between theories of modern[clarification needed] in juxtaposition to the theories of romanticism and other reactionary movements after the end of the Middle Ages. 👆←🗎[1] 在本站中，【良心】作为一个重要的[标签]，往往和【道德】[标签]一起使用，且在一定程度上会影响对应文章的[分类]；只要涉及[&thinsp;良心&thinsp;]&thinsp;的知识都会被划分到【良心】的[标签]之中。 ※参考和引用 ^&ensp;Conscience - Wikipedia 良知 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Ethics - Wikipedia Morality - Wikipedia 道德 - 维基百科，自由的百科全书 伦理学 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 "},{"title":"伦理","date":"2021-04-13T02:13:16.000Z","url":"/2021/04/13/%E4%BC%A6%E7%90%86/","tags":[["伦理","/tags/Ethics/"]],"categories":[["undefined",""]],"content":" 伦理学（英语：Ethics 或 Moral Philosophy）也称为道德哲学或道德学，是一门哲学学科，主要探讨道德价值；在此，“道德”被定义为一群人或一种文化所认可的所有行为准则。伦理学试图从理论层面建构一种指导行为的法则体系，并且对其进行严格的评判。 伦理学涉及捍卫并鼓励对的行为，并劝阻错的行为。伦理学领域与美学又一起涉及了价值问题，因此也构成了另一个称为价值论的哲学分支。 伦理学旨在定义诸如：善与恶、对与错、美德与恶习、正义与犯罪等概念来解决道德问题，也探讨什么是聪明或愚蠢。作为一个知识探究领域，道德哲学也与道德心理学（Moral psychology）、描述伦理学和价值观有关。 👆←🗎[1] 在本站中，【伦理】作为一个重要的[标签]，往往和【道德】[标签]一起使用，且在一定程度上会影响对应文章的[分类]；只要涉及[&thinsp;伦理&thinsp;]&thinsp;的知识都会被划分到【伦理】的[标签]之中。 ※参考和引用 ^&ensp;伦理学 - 维基百科，自由的百科全书 Ethics - Wikipedia 伦理学 - MBA智库百科 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Conscience - Wikipedia Morality - Wikipedia 道德 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 良知 - 维基百科，自由的百科全书 "},{"title":"道德","date":"2021-04-13T02:11:58.000Z","url":"/2021/04/13/%E9%81%93%E5%BE%B7/","tags":[["道德","/tags/Moral/"]],"categories":[["undefined",""]],"content":" 道德（英语：moral，源自拉丁语:moralitas, 文学上”举止，品质，适当的行为”）是依据一定社会或阶级（生活形态）的价值观、社会舆论、传统习俗和人的内心信念的力量（生产能力）来调整对他人和自己之间的行为进行善恶、荣辱、正当或不正当等的相互关系（生产关系）的评价和断定的行为规范标准。有着通过确立一定的善恶标准和行为准则，来约束人们的相互关系和个人行为，调节社会关系，并与法律一起对社会生活的正常秩序起保障作用。道德贯串于社会生活的各个方面，如社会公德、婚姻家庭道德、职业道德等。 在英语中，Moral是指那些杰出的人之间的意图、决定和行动的区分，即是正确的还是不正确的及其相关的观念准则。道德可以是源自于特定哲学、宗教或文化的行为准则中衍生出来的一系列标准或原则，也可以源于一个人所相信的普遍价值。道德是一种“非正式公共机制”，非正式即指无法律或权威能判定其正确与否，而公共机制指所有场合都能套用的准则。 一些研究认为，对道德情操的注重，存在于所有的人类社会当中，道德情操是普世文化通则的一部分；而一些研究更认为，像是诚实、助人、宽容、忠诚、责任、社会公正、平等、家庭与国家安全、社会秩序的稳定、报恩等等和道德相关的行为，是普世价值的一部分，也就是说，这些行为可能是所有社会普遍认可的德行，提倡此种原则的伦理学立场称为道德普遍主义。不过道德相对主义的哲学则与道德普遍原则对立，道德相对主义认为不存在普遍的道德原则。 👆←🗎[1] 简而言之，道德属于社会属性，主要是指&thinsp;在社会中的人类个体&thinsp;对[&thinsp;人自身&thinsp;以及&thinsp;人与人之间的关系&thinsp;]的&thinsp;价值评判&thinsp;和&thinsp;看法。道德普遍存在，且作为重要组成部分于[社会中的人与人的交流之中&thinsp;形成并完善的&thinsp;价值标准和行为规范]；具体来说可以是：善恶、荣辱，美丑，文化，法律&thinsp;等等。 （广义上的）道德是社会形成的基础之一，是社会形成的&thinsp;必要不充分条件。 在本站中，【道德】作为一个重要的[标签]，在一定程度上会影响对应文章的[分类]；只要涉及[&thinsp;道德&thinsp;]&thinsp;的知识都会被划分到【道德】的[标签]之中。 ※参考和引用 ^&ensp;道德 - 维基百科，自由的百科全书 Morality - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） Conscience - Wikipedia Morality - Wikipedia 伦理学 - 维基百科，自由的百科全书 【☆】良心犯 - 维基百科，自由的百科全书 良知 - 维基百科，自由的百科全书 "},{"title":"其他🗒","date":"2021-04-12T23:20:43.000Z","url":"/2021/04/12/%E5%85%B6%E4%BB%96-%E6%9A%82%E6%9C%AA%E5%88%86%E7%B1%BB/","categories":[["其他🗒","/categories/Other/"]],"content":"在本站中，[&thinsp;最终难以分类&thinsp;或者&thinsp;所属类型与本站的定位相差很大&thinsp;]&thinsp;的信息，将会被划归到【其他】/【其他🗒】/【其他(暂未分类)】的[分类]之中。分类中的垃圾箱 需要注意的是，类型【其他🗒】与所有其他的类型互斥；对于【其他🗒】类型之下的文章，其标签的定义&thinsp;在一定程度上&thinsp;会受到影响。 ※参考和引用 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗒 - 螺旋笔记本 表情符号: U+1F5D2 - Unicode 字符百科 "},{"title":"手册","date":"2021-04-12T22:55:38.000Z","url":"/2021/04/12/%E6%89%8B%E5%86%8C/","tags":[["手册","/tags/Handbook/"]],"categories":[["手册","/categories/Handbook/"]],"content":" A handbook is a type of reference work, or other collection of instructions, that is intended to provide ready reference. The term originally applied to a small or portable book containing information useful for its owner, but the Oxford English Dictionary defines the current sense as “any book…giving information such as facts on a particular subject, guidance in some art or occupation, instructions for operating a machine, or information for tourists.” A handbook is sometimes referred to as a vade mecum (Latin, “go with me”) or pocket reference. It may also be referred to as an enchiridion. Handbooks may deal with any topic, and are generally compendiums of information in a particular field or about a particular technique. They are designed to be easily consulted and provide quick answers in a certain area. For example, the MLA Handbook for Writers of Research Papers is a reference for how to cite works in MLA style, among other things. Examples of engineering handbooks include Perry’s Chemical Engineers’ Handbook, Marks Standard Handbook for Mechanical Engineers, and the CRC Handbook of Chemistry and Physics. 👆←🗎[1] 手册是&thinsp;一种参考书，或者&thinsp;特定信息的集合。手册可以用于处理任何问题，通常是&thinsp;在特定领域或特定技术中&thinsp;作为&thinsp;信息纲要。手册的设计特点是&thinsp;易于查询，能够&thinsp;在特定领域&thinsp;提供快速准确的有效信息。 在本站中，【手册】作为&thinsp;次级分类；通常会将&thinsp;[&thinsp;对&thinsp;特定领域的重要信息&thinsp;进行&thinsp;整理编排&thinsp;并&thinsp;提供快速索引&thinsp;]&thinsp;的知识划分到【手册】的[分类或标签]之中。 ※参考和引用 ^&ensp;Handbook - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗎 - 文献: U+1F5CE - Unicode 字符百科 "},{"title":"站点记录","date":"2021-04-12T22:25:45.000Z","url":"/2021/04/12/%E7%AB%99%E7%82%B9%E8%AE%B0%E5%BD%95/","tags":[["站点记录","/tags/SiteRecord/"]],"categories":[["站点记录","/categories/SiteRecord/"]],"content":"在本站中，会将&thinsp;[&thinsp;关于本站点的各种&thinsp;记录信息&thinsp;]&thinsp;划分到【站点记录】的[分类和标签]之中。 📖参看 主要参看📖 Java (programming language) - Wikipedia Java - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 ^&ensp;[Java - 维基百科，自由的百科全书][Wikipedia_zh__Java] 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"生命","date":"2021-04-12T16:47:37.000Z","url":"/2021/04/12/%E7%94%9F%E5%91%BD/","tags":[["生命","/tags/Life/"]],"categories":[["生命","/categories/Life/"]],"content":" 生命是一种特征，物质存在的一种活跃形式。目前对于生命的定义在学术界还无共识，较流行的定义是一类维持体内平衡、具有生命周期和稳定的物质和能量代谢现象、能对刺激做反应、能进行自我复制或和繁殖、进化的半开放物质系统。由细胞组成，能够成长，适应环境。其他定义有时包括非细胞生命形式，如病毒和类病毒。 生命是生物学的基本概念，而生物学是研究生命的科学。生命具有生物进程(如信号传递和自我维持过程)的物理实体与那些没有生物进程的实体区分开来。如果生物过程的功能已经停止(死亡)，或者它们从来没有这样的功能则会被归类为无生命。 生命包含所有“生物的特性”，生命个体一定会经历出生、成长、衰老和死亡。生命种群则在一代代个体的更替中经过自然选择发生进化以适应环境。生物学则是以研究生命为中心的科学。 生命的最小单位是生物，生物是由一个或多个细胞组成，能够新陈代谢，维持恒定性，可以成长，回应刺激，可以繁殖甚至演化，以适应外界环境，继续繁殖并产生后代。生命以各种形式存在，如植物、动物、真菌、原生生物、古菌和细菌。在地球的生物圈内可以找到许多不同的生物，在这些生物中都有共同的特征，都是由以碳和水为基础的细胞构成，有其组织以及可以遗传的基因资讯。 👆←🗎[1] 在本站中，通常会将&thinsp;[&thinsp;主要对&thinsp;生命&thinsp;的记录、思考和表达等方面 &thinsp;]&thinsp;的知识划分到【生命】的[分类和标签]之中，其中包括且不限于&thinsp;人与自然、人与人（在生命层面的思考和表达）、动物以及植物。 ※参考和引用 ^&ensp;生命 - 维基百科，自由的百科全书 Life - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗎 - 文献: U+1F5CE - Unicode 字符百科 "},{"title":"日常记录","date":"2021-04-12T15:58:16.000Z","url":"/2021/04/12/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/","tags":[["日常记录","/tags/DailyRecord/"]],"categories":[["日常记录","/categories/DailyRecord/"]],"content":" 日记是以日期为排列顺序的笔记。 一开始的日记是人们用日记来记录天气、事件一直到个人心理感受以及思想深处。 日记可以是记录将要做的事情的，也能记录已经发生的事情和心情。 👆←🗎[1] 本站的[分类或标签]所定义的【日常记录】包括且不仅限于&thinsp;日记。 【日常记录】所对应的分类，作为本站的&thinsp;次级&thinsp;分类甚至可以归类于【其他(暂未分类)】。 在本站中，通常会将&thinsp;[&thinsp;没有明确主题，且以&thinsp;日常事件&thinsp;为&thinsp;内容或讨论对象&thinsp;]&thinsp;的知识划分到【日常记录】的[分类和标签]之中。 ※参考和引用 ^&ensp;日记 - 维基百科，自由的百科全书 Diary - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 "},{"title":"社会","date":"2021-04-12T15:12:28.000Z","url":"/2021/04/12/%E7%A4%BE%E4%BC%9A/","tags":[["社会","/tags/Society/"]],"categories":[["社会","/categories/Society/"]],"content":" 社会一词并没有太正式明确定义，一般是指由自我繁殖的个体构建而成的群体，占据一定的空间，具有其独特的文化和风俗习惯。由于社会通常被认为是人类组成的，所以社会和人类社会一般具有相同的含义，但在科学研究或科幻小说里面，有时亦可出现“蚂蚁社会”、“外星社会”等词语。 狭义的社会，也叫“社群”，可以只指群体人类活动和聚居的范围，例如是：乡、村、镇、城市、聚居点等等；广义的社会则可以指一个国家、一个大范围地区或一个文化圈，例如是中国社会、英国社会、东亚社会、东南亚或西方世界，均可作为社会的广义解释，也可以引申为他们的文化习俗。 以人类社会为研究对象的学科叫做社会学。 👆←🗎[1] 社会&thinsp;是共同生活的人们通过各种各样&thinsp;社会关系&thinsp;联合起来的集合。其中形成社会的最主要的社会关系包括家庭关系、共同文化以及传统习俗。微观上，社会强调同伴的意味，并且延伸到为了&thinsp;共同利益&thinsp;而形成联盟。宏观上，社会是由长期合作的社会成员，通过发展组织关系形成团体，进而形成&thinsp;机构、国家&thinsp;等&thinsp;组织形式。 👆←🗎[2] 在本站中，通常会将&thinsp;[&thinsp;主要涉及对&thinsp;社会&thinsp;的记录、思考和评价等方面&thinsp;]&thinsp;的知识划分到【社会】的[分类和标签]之中。 ※参考和引用 ^&ensp;社会 - 维基百科，自由的百科全书 ^&ensp;社会 - MBA智库百科 Society - Wikipedia 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 🗎 - 文献: U+1F5CE - Unicode 字符百科 "},{"title":"知识","date":"2021-04-11T22:20:36.000Z","url":"/2021/04/11/%E7%9F%A5%E8%AF%86/","tags":[["知识","/tags/%E7%9F%A5%E8%AF%86/"]],"categories":[["知识","/categories/Knowledge/"]],"content":" 知识是对某个主题确信的认识，并且这些认识拥有潜在的能力为特定目的而使用。亦指透过经验或联想，而能够熟悉进而了解某件事情；这种事实或状态就称为知识，其包括认识或了解某种科学、艺术或技巧。此外，亦指透过研究、调查、观察或经验而获得的一整套知识或一系列资讯。 认知事物的能力是哲学中充满争议的中心议题之一，并且拥有它自己的分支—知识论。从更加实用的层次来看，知识通常被某些人的群体所共享，在这种情况下，知识可以通过不同的方式来操作和管理。 简而言之，目前为止学术上对[ 知识 ]这个概念还没有具体、明确且统一的定义（就很迷…）。 个人认为：（狭义[1]上）知识是人类通过[ 自身认识世界的方式 ][在思想上]所[产生并认可]的经验[2]（记忆[3]和想法[4]）。 在本站中，通常会将&thinsp;[&thinsp;主要涉及[对&thinsp;知识&thinsp;←&thinsp;（抽象）概念&thinsp;的思考]或[对&thinsp;被归类的知识&thinsp;的管理]等方面&thinsp;]&thinsp;的知识划分到【知识】的[分类和标签]之中。 ※参考和引用 ^&ensp;定义 - 维基百科，自由的百科全书 ^&ensp;经验 - 维基百科，自由的百科全书 ^&ensp;记忆 - 维基百科，自由的百科全书 ^&ensp;想法 - 维基百科，自由的百科全书 Knowledge - Wikipedia 知识 - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰 | 查阅🔍 HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 分类：其他（二度及以上关联☌） 思想 - 维基百科，自由的百科全书 "},{"title":"博客","date":"2021-04-11T02:44:21.000Z","url":"/2021/04/11/%E5%8D%9A%E5%AE%A2/","tags":[["博客","/tags/Blog/"]],"categories":[["博客","/categories/Blog/"]],"content":" 博客（英语：Blog）是一种在线日记型式的个人网站，借由张帖子章、图片或视频来记录生活、抒发情感或分享信息[1]。博客上的文章通常根据张贴时间，以倒序方式由新到旧排列。 许多博客作者专注评论特定的课题或新闻，其他则作为个人日记。一个典型的博客结合了文字、图像、其他博客或网站的超链接、及其它与主题相关的媒体。能够让读者以互动的方式留下意见，是许多博客的重要要素。大部分的博客内容以文字为主，也有一些博客专注艺术、摄影、视频、音乐、播客等各种主题。 博客是社交媒体网络的一部分。 本站就属于[ 博客 ]的范畴，具体来说是一个以分享信息为主的博客。 在本站中，通常会将&thinsp;[&thinsp;主要涉及博客本身的设计、管理、评价等方面&thinsp;]&thinsp;的知识划分到【博客】的[分类和标签]之中。 📖参看 主要参看📖 Java (programming language) - Wikipedia Java - 维基百科，自由的百科全书 分类：解决问题✅ Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色 (……) inline-block的元素垂直居中的问题 - SegmentFault 思否 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 calc() - CSS（层叠样式表） | MDN fit-content() - CSS（层叠样式表） | MDN 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com HTML Color Picker HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 Markdown 教程 | 菜鸟教程 👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科 📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科 🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科 🗎 - 文献: U+1F5CE - Unicode 字符百科 ※ - 参考标志: U+203B - Unicode 字符百科 ☌ - 关联: U+260C - Unicode 字符百科 分类：其他（二度及以上关联☌） ※参考和引用 Blog - Wikipedia 博客 - 维基百科，自由的百科全书 🔗外部链接 Wikipedia’s external link ltr-icon "},{"title":"欢迎来到【夜与花海】！","date":"2021-04-10T22:35:31.000Z","url":"/2021/04/10/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E3%80%90%E5%A4%9C%E4%B8%8E%E8%8A%B1%E6%B5%B7%E3%80%91%EF%BC%81/","tags":[["HelloWorld🐣","/tags/HelloWorld/"],["博客","/tags/Blog/"],["站点记录","/tags/SiteRecord/"]],"categories":[["HelloWorld🐣","/categories/HelloWorld/"]],"content":"๑乛◡乛๑🌹(●´∀ `●)✨ |･ω･｀) |✦▽≦) |o￩ܫ￩o)♪ |´ ˘ `*)♥|д•´)ฅ!! &ensp; &ensp; 欢迎来到【夜与花海】本站作为个人博客，主要用来分享技术积累、社会看法以及对生命的思考。 如果有所收获👆 欢迎来Github点亮小星星๑乛◡乛๑ 关于本站的主题本站使用的是 Candinya (小姐姐🍭)开源分享的 Kratos-Rebirth 主题，喜欢的话就请给小姐姐🍭点亮小星星🌟，谢谢大家啦！~(●´∀ `●) 关于本站的初衷很久以前，就觉得需要一个能够辅助自己整理和分享知识的平台。那时候还没法方便地科学上网，国内各大博客平台底下一泡污…本着宁缺勿滥的思想，于是这事情就“咕”置了 到了现在，这个博客不得不承载着[输出自产自囤多年的笔记]的重任…（哭晕在厕所今天也是干劲满满呢√） 关于本站的搭建本站基于 Hexo 框架，使用 Github - Travis CI 进行发布。 搭建不是5分钟完事了吗（白嫖狂喜.jpg）在没有足够经验的情况下，一个完整的博客从开始搭建到正式版本的上线，实际耗时远比看上去的要长（亿点点）。 本站搭建的相关填坑开发记录请移步本站的搭建记录 那就酱吧，祝各位食用愉快！~ "},{"title":"Hello, World🐣","date":"2021-04-09T19:58:39.000Z","url":"/2021/04/09/HelloWorld/","tags":[["HelloWorld🐣","/tags/HelloWorld/"]],"categories":[["HelloWorld🐣","/categories/HelloWorld/"]],"content":"“Hello, World”是最流行的一段语句，代表着一种🐣[&thinsp;对这个世界&thinsp;]🌹[&thinsp;积极的态度&thinsp;]。 “Hello, World”精神🐣 生命本就是积极的，无论何种姿态，都是在为更好的生活所前行。 生活也正是简简单单，每天醒来“Hello, World”——新的一天👉奥~里~给！（又或者“长醉不复醒，不枉来一遭”） 今天吃啥(๑´ڡ`๑) / 还有好多番没有看(´◓Д◔`) / 更新啦更新啦ε===(っ≧ω≦)っ / 带带我鸭_(:3」∠)_ / 又摸了一天鱼，好累呀~٩(๑´0`๑)۶ Hello, World是指在电脑屏幕显示“Hello, World!”（你好，世界！）字符串的计算机程序。 相关的程序通常都是每种电脑编程语言最基本、最简单的程序，也会用作示范一个编程语言如何运作。同时它亦可以用来确认一个编程语言的编译器、程序开发环境及运行环境是否已经安装妥当。 因为写法简单可见，这也是很多初学者首次接触编程语言时会撰写的程序。 在本站中，符合“Hello, World”精神🐣的知识将划分到【HelloWorld🐣】的[分类和标签]之中。 同名电影 《Hello World》，2019年9月20日在日本发行的动画电影；由 Graphinica 制作，[伊藤智彦]指导执导。（View on Wikipedia） 简介👆 Hello World is a 2019 Japanese animated sci-fi romantic drama film directed by Tomohiko Itō and produced by Graphinica.It was released in Japan on September 20, 2019.Its cast include Takumi Kitamura, Tōri Matsuzaka, and Minami Hamabe.A three-episode spin-off anime titled Another World premiered on September 13, 2019. ※参考和引用 “Hello, World!” program - Wikipedia Hello World - 维基百科，自由的百科全书 更多👆 HelloWorld的箴言 - 简书 Hello World (电影) "},{"title":"计算机工程","date":"2021-04-09T17:56:47.000Z","url":"/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B7%A5%E7%A8%8B/","tags":[["计算机工程","/tags/ComputerEngineering/"]],"categories":[["计算机工程","/categories/ComputerEngineering/"]],"content":" 计算机工程（英语：Computer engineering）一个以电机工程学和计算机科学的部分交叉领域为内容的工程学，其主要任务是设计及实现计算机系统。 计算机工程师通常受过专业的电子工程（或其他与计算机工程有关的电机工程学分支）、软件设计和软硬件集成综合技能的培训。计算机工程师的工作涉及了许多有关计算机的硬件和软件，其关注范围包括微处理器、个人电脑、超级计算机和电路设计（特别是集成电路的设计）等。计算机工程并不仅仅关注计算机系统本身的工作，还致力于多个计算机组成更大规模的分布式系统。 简而言之，计算机工程是一个&thinsp;[&thinsp;专注于对计算机硬件的理论和应用研究 &thinsp;]&thinsp;的[工程学]概念。 在本站中，通常会将&thinsp;[&thinsp;主要对计算机硬件的理论和应用研究&thinsp;]&thinsp;的知识划分到【计算机工程】的[分类和标签]之中。 ※参考和引用 Computer engineering - Wikipedia 计算机工程 - 维基百科，自由的百科全书 更多👆 计算机科学(Computer Science)和信息技术(IT)的区别是什么？ - 知乎 "},{"title":"计算机科学","date":"2021-04-09T17:28:48.000Z","url":"/2021/04/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/","tags":[["计算机科学","/tags/ComputerScience/"]],"categories":[["计算机科学","/categories/ComputerScience/"]],"content":" 计算机科学（英语：computer science，有时缩写为CS）是系统性研究信息与计算的理论基础以及它们在计算机系统中如何实现与应用的实用技术的学科。 它通常被形容为对那些创造、描述以及转换信息的算法处理的系统研究。 计算机科学包含很多分支领域；有些强调特定结果的计算，比如计算机图形学；而有些是探讨计算问题的性质，比如计算复杂性理论；还有一些领域专注于怎样实现计算，比如编程语言理论是研究描述计算的方法，而程序设计是应用特定的编程语言解决特定的计算问题，人机交互则是专注于怎样使计算机和计算变得有用、好用，以及随时随地为人所用。 简而言之，计算机科学是一个&thinsp;[&thinsp;侧重于对计算机知识的理论研究&thinsp;]&thinsp;的[学科]概念。 在本站中，一定程度上会将&thinsp;[&thinsp;侧重于对计算机知识的理论研究&thinsp;]&thinsp;的知识划分到【计算机科学】的[分类和标签]之中。 ※参考和引用 Computer science - Wikipedia 计算机科学 - 维基百科，自由的百科全书 更多👆 计算机科学(Computer Science)和信息技术(IT)的区别是什么？ - 知乎 "},{"title":"信息技术","date":"2021-04-09T16:28:04.000Z","url":"/2021/04/09/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/","tags":[["信息技术","/tags/InformationTechnology/"]],"categories":[["信息技术","/categories/InformationTechnology/"]],"content":" 信息技术（英语：Information Technology，缩写：IT）也称信息和通信技术（Information and Communications Technology，ICT），是主要用于管理和处理信息所采用的各种技术总称，主要是应用计算机科学和通信技术来设计、开发、安装和部署信息系统及应用软件。 简而言之，信息技术（IT）是一个&thinsp;[&thinsp;侧重于对计算机知识的应用&thinsp;]&thinsp;的[技术]概念。 在本站中，一定程度上会将&thinsp;[&thinsp;侧重于对计算机知识的应用&thinsp;]&thinsp;的知识划分到【信息技术】的[分类和标签]之中。 ※参考和引用 Information technology - Wikipedia 信息技术 - 维基百科，自由的百科全书 更多👆 计算机科学(Computer Science)和信息技术(IT)的区别是什么？ - 知乎 "},{"title":"本站的搭建记录","date":"2021-04-09T00:32:39.000Z","url":"/2021/04/09/%E6%9C%AC%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","tags":[["Git","/tags/Git/"],["信息技术","/tags/InformationTechnology/"],["站点记录","/tags/SiteRecord/"],["开发日志","/tags/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"],["Github","/tags/Github/"],["Hexo","/tags/Hexo/"]],"categories":[["信息技术","/categories/InformationTechnology/"],["站点记录","/categories/InformationTechnology/SiteRecord/"]],"content":"本站从零开始的填坑搭建记录 Hexo &ensp; &ensp; Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo插件站点功能拓展文章书写功能拓展 hexo-markmap Innsert a mindmap by markdown in your hexo blog by markmap. 在你的博客中使用markdown插入思维导图，使用markmap。 hexo-tag-hint hexo-tag-hint is a simplistic plugin for Hexo which enables presenting a floating bubble containing the hint text when the content text gets hovered or clicked (yes, mobile-ready!). 文本浮动气泡插件 Travis CI私有Git子模块的API-Token 出于后期站点运营管理的考虑，【博客站点主框架】应该和【博客站点主题】以及【博客文章仓库】分开管理，所以将【博客站点】设计为Git主模块，【博客站点主题】（Github上拉取的分支，在Github上为公开项目）和【博客文章仓库】（在Github上为私有项目）都作为Git子模块。 问题就出在这其中： 在Travis CI平台上，Git子模块的相关操作。 解决方案 Git子模块【博客文章仓库】在Github上为私有项目；在Travis CI平台上，需要根据所选的安全策略对其进行特殊处理。 解决方案 [&thinsp;Private Dependencies GitHub - Travis CI&thinsp;]#API Token&ensp;👆 .travis.yml相关部分：⤵ 相关&ensp;→&ensp;安全策略选择 Authentication Protocol Dependency URL format Gives access to Notes Deploy Key SSH git@github.com/… single repository used by default for main repository User Key SSH git@github.com/… all repos user has access to recommended for dependencies Password HTTPS https://… all repos user has access to password can be encrypted API token HTTPS https://… all repos user has access to token can be encrypted Travis CI平台日志 日志记录 Git子模块相关  记录 1. 从零开始到发布本地服务📔 ※搭建过程中的参考资料 主要参看📖 Hexo 官方文档 Hexo 插件库 Markdown 教程 | 菜鸟教程 Markdown → [ 基本撰写和格式语法 - GitHub Docs ] 本站主题作者 Candinya🍭 编写的使用指南 —— [Kratos-Rebirth食用说明 | 糖菓·部落] 常用 Git 命令清单 - 阮一峰的网络日志 分类：解决问题✅ Hexo引用站内文章 | Recording 【★】[ Private Dependencies GitHub - Travis CI ]#API Token 【★】(……) [译] Hexo git deployer 删除了提交历史记录该怎么整？ - SegmentFault 思否 【★】🐣 - 孵化小鸡 表情符号: U+1F423 - Unicode 字符百科 如何在GitHub风格的Markdown中添加脚注？ - ITranslater 分类：工具🧰&ensp;|&ensp;查阅🔍 【★】【GFM】GitHub Flavored Markdown Spec - github.github.com 【☆】Google 翻译 【☆】[ HTML style tag ] - w3schools.com HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带 markdown-cheatsheet-online | guides.github.com markdown 需要转义的字符 - 简书 Sentence spacing in digital media - Wikipedia 【★】Unicode 字符百科 【★】软件版本号规范与命名原则 - 简书 分类：其他（二度及以上关联☌） Best Practices in Securing Your Data - Travis CI [ Getting started with the REST API - GitHub Docs ]#Authentication Github 中 Markdown 锚点链接如何写 - 码蚁de天空 - OSCHINA - 中文开源技术交流社区 Hexo 搭建个人博客 #04 主题的安装与自定义样式 | 杨斌的博客 Hexo使用攻略：（四）Hexo的分类和标签设置 | { GoonX } html - How to display and using markdown? - Stack Overflow 【★】持续集成服务 Travis CI 教程 - 阮一峰的网络日志 个人博客如何设计分类和标签 - 知乎 六度分隔理论 - 维基百科，自由的百科全书 将通用代码添加为git子模块的问题：“索引中已存在” | 码农家园 如何规划blog的标签（tag）和分类 - 心内求法 - 博客园 如何解决 Git 仓库嵌套问题 - Jartto’s blog (……) Hexo 搭建个人博客 #05 利用 Travis CI 帮你自动部署 - SegmentFault 思否 (……) 关于 git-submodule 的一些基本操作 - SegmentFault 思否 "}]