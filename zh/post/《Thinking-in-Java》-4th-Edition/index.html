<!DOCTYPE html>
<html lang="zh">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="https://avatars.githubusercontent.com/SuiteLHY">
  <title>《Thinking in Java》（第4版） ← 整理手册 | 夜与花海</title>
  <meta name="author" content="Suite" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="Java, 《Thinking in Java》, 计算机科学" />
  
  <meta name="description" content="《Thinking in Java》(4th)&amp;thinsp;的译本《Java编程思想》(第四版)&amp;thinsp;的整理笔记。 该手册中还包括&amp;thinsp;本人添加的&amp;thinsp;一些知识更新和拓展。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Thinking in Java》（第4版） ← 整理手册">
<meta property="og:url" content="https://suitelhy.github.io/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/index.html">
<meta property="og:site_name" content="夜与花海">
<meta property="og:description" content="《Thinking in Java》(4th)&amp;thinsp;的译本《Java编程思想》(第四版)&amp;thinsp;的整理笔记。 该手册中还包括&amp;thinsp;本人添加的&amp;thinsp;一些知识更新和拓展。">
<meta property="og:locale">
<meta property="og:image" content="https://suitelhy.github.io/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/%E3%80%8AThinking%20in%20Java%E3%80%8B-4th.jpg">
<meta property="article:published_time" content="2021-04-16T18:53:02.000Z">
<meta property="article:modified_time" content="2021-05-16T14:43:22.181Z">
<meta property="article:author" content="Suite">
<meta property="article:tag" content="计算机科学">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="《Thinking in Java》">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://suitelhy.github.io/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/%E3%80%8AThinking%20in%20Java%E3%80%8B-4th.jpg">
<meta name="twitter:site" content="@null">
  
  <!-- 站点验证相关 -->
  
    
      <meta name="google-site-verification" content="bZE7nUm9TG8--G23eE_vpUfb898ld93qzKhP7On5QRw" />
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" type="text/css" media="all">
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" type="text/css" media="all">
  
  
  <link rel="stylesheet" id="fontawe-css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" type="text/css" media="all">
  <link rel="stylesheet" id="nprogress-css" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" type="text/css" media="all">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  
  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-dark.min.css" type="text/css" media="all">
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/qrcode_js@1.0.0/qrcode.min.js"></script>
  
<meta name="generator" content="Hexo 5.4.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                        <li><a href="/"><i class="fa fa-home"></i>首页</a></li>
                                    
                                
                                    
                                        <li><a href="/archives/"><i class="fa fa-file"></i>档案馆</a></li>
                                    
                                
                                    
                                        <li><a href="/friends/"><i class="fa fa-paw"></i>好伙伴</a></li>
                                    
                                
                                    
                                        <li>
                                            <a><i class="fa fa-link"></i>链接</a>
                                            <ul class="sub-menu">
                                                
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/SuiteLHY">本站作者</a></li>
                                                    
                                                
                                                    
                                                        <li><a target="_blank" rel="noopener" href="https://github.com/SuiteLHY/SuiteLHY.github.io">项目链接</a></li>
                                                    
                                                
                                            </ul>
                                        </li>
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">夜与花海</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>夜与花海</h2> <br />
                        <span>我写下的——是世界</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        <section class="col-md-8">
    <article>
        <div class="kratos-hentry kratos-post-inner clearfix">
            <header class="kratos-entry-header">
                <h1 class="kratos-entry-title text-center">《Thinking in Java》（第4版） ← 整理手册</h1>
                
                <ul class="kratos-post-meta text-center">
                    <li><i class="fa fa-calendar"></i> 2021-04-16</li>
                    <li><i class="fa fa-user"></i> 作者 Suite</li>
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~67.95K
                        
                        字
                    </li>
                    
                </ul>
            </header>
            <div class="kratos-post-content">
                <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                    本文最后编辑于 <time datetime="1621176202181"></time> 前，其中的内容可能需要更新。
                </div>
                
                    <div class="kratos-post-inner-toc">
                        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">第1章 面向对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Object-oriend-Programming%EF%BC%8COOP%EF%BC%89%E3%80%82"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象程序设计（Object-oriend Programming，OOP）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.1.2.</span> <span class="toc-text">主要特征：封装性、继承性、多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.3.</span> <span class="toc-text">设计优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="toc-number">2.1.4.</span> <span class="toc-text">设计缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">2.1.5.</span> <span class="toc-text">名词解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">第1章-1 抽象过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-2-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.</span> <span class="toc-text">第1章-2 每个对象都有一个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-3-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.4.</span> <span class="toc-text">第1章-3 每个对象都提供服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-4-%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.</span> <span class="toc-text">第1章-4 被隐藏的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-5-%E5%A4%8D%E7%94%A8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">第1章-5 复用具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.</span> <span class="toc-text">第1章-6 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-1-%E2%80%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E4%B8%8E%E2%80%9C%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.7.1.</span> <span class="toc-text">第1章-6-1 “是一个”与“像是一个”的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-7-%E4%BC%B4%E9%9A%8F%E5%A4%9A%E6%80%81%E7%9A%84%E5%8F%AF%E4%BA%92%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.8.</span> <span class="toc-text">第1章-7 伴随多态的可互换对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-8-%E5%8D%95%E6%A0%B9%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-number">2.9.</span> <span class="toc-text">第1章-8 单根继承结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-%E5%AE%B9%E5%99%A8"><span class="toc-number">2.10.</span> <span class="toc-text">第1章-9 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-1-%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.10.1.</span> <span class="toc-text">第1章-9-1 参数化类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.11.</span> <span class="toc-text">第1章-10 对象的创建和生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.12.</span> <span class="toc-text">第1章-11 异常处理：错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">2.13.</span> <span class="toc-text">第1章-12 并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-Java%E4%B8%8EInternet"><span class="toc-number">2.14.</span> <span class="toc-text">第1章-13 Java与Internet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-1-Web%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.14.1.</span> <span class="toc-text">第1章-13-1 Web是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">2.14.2.</span> <span class="toc-text">第1章-13-2 客户端编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-number">2.14.3.</span> <span class="toc-text">第1章-13-3 服务器端编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">2.15.</span> <span class="toc-text">第1章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">第2章 一切都是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-1-%E7%94%A8%E5%BC%95%E7%94%A8%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">第2章-1 用引用操纵对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-%E5%BF%85%E9%A1%BB%E7%94%B1%E4%BD%A0%E5%88%9B%E5%BB%BA%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E3%80%90%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-number">3.2.</span> <span class="toc-text">第2章-2 必须由你创建所有对象【底层存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-1-%E5%AD%98%E5%82%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E3%80%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">第2章-2-1 存储到什么地方【对象的存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">寄存器。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%EF%BC%88Heap%EF%BC%89%E3%80%82"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">堆栈（Heap）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Stack%EF%BC%89%E3%80%82"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">堆（Stack）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%89%E3%80%82"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">常量存储（常量池）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9ERAM%E5%AD%98%E5%82%A8%E3%80%82"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">非RAM存储。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-2-%E7%89%B9%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">第2章-2-2 特例：基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-3-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.3.</span> <span class="toc-text">第2章-2-3 Java中的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-3-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.4.</span> <span class="toc-text">第2章-3 永远不需要销毁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.5.</span> <span class="toc-text">第2章-4 创建新的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-5-%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.2.6.</span> <span class="toc-text">第2章-5 方法、参数和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.7.</span> <span class="toc-text">第2章-6 构建一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-7-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.8.</span> <span class="toc-text">第2章-7 你的第一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-8-%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E6%A1%A3"><span class="toc-number">3.2.9.</span> <span class="toc-text">第2章-8 注释和嵌入式文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-9-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.2.10.</span> <span class="toc-text">第2章-9 编码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.11.</span> <span class="toc-text">第2章-10 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-11-%E7%BB%83%E4%B9%A0"><span class="toc-number">3.2.12.</span> <span class="toc-text">第2章-11 练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">第3章 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-1-%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.1.</span> <span class="toc-text">第3章-1 更简单的打印语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-2-%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">第3章-2 使用Java操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-3-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.3.</span> <span class="toc-text">第3章-3 优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-%E8%B5%8B%E5%80%BC"><span class="toc-number">4.4.</span> <span class="toc-text">第3章-4 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84%E5%88%AB%E5%90%8D%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.1.</span> <span class="toc-text">第3章-4.1 方法调用中的别名问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.5.</span> <span class="toc-text">第3章-5 算数操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-1-%E4%B8%80%E5%85%83%E5%8A%A0%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.5.1.</span> <span class="toc-text">第3章-5-1 一元加减操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-6-%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F"><span class="toc-number">4.6.</span> <span class="toc-text">第3章-6 自动递增和递减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.7.</span> <span class="toc-text">第3章-7 关系操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-1-%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">4.7.1.</span> <span class="toc-text">第3章-7-1 测试对象的等价性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.8.</span> <span class="toc-text">第3章-8 逻辑操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-1-%E7%9F%AD%E8%B7%AF"><span class="toc-number">4.8.1.</span> <span class="toc-text">第3章-8-1 短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-%E7%9B%B4%E6%8E%A5%E5%B8%B8%E9%87%8F"><span class="toc-number">4.9.</span> <span class="toc-text">第3章-9 直接常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-1-%E6%8C%87%E6%95%B0%E8%AE%B0%E6%95%B0%E6%B3%95"><span class="toc-number">4.9.1.</span> <span class="toc-text">第3章-9-1 指数记数法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-10-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.10.</span> <span class="toc-text">第3章-10 按位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-11-%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.11.</span> <span class="toc-text">第3章-11 移位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-12-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6if-else"><span class="toc-number">4.12.</span> <span class="toc-text">第3章-12 三元操作符if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%92%8C"><span class="toc-number">4.13.</span> <span class="toc-text">第3章-13 字符串操作符+和&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-14-%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">4.14.</span> <span class="toc-text">第3章-14 使用操作符时常犯的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.15.</span> <span class="toc-text">第3章-15 类型转换操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-1-%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5"><span class="toc-number">4.15.1.</span> <span class="toc-text">第3章-15-1 截尾和舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-2-%E6%8F%90%E5%8D%87"><span class="toc-number">4.15.2.</span> <span class="toc-text">第3章-15-2 提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-16-Java%E6%B2%A1%E6%9C%89sizeof"><span class="toc-number">4.16.</span> <span class="toc-text">第3章-16 Java没有sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B0%8F%E7%BB%93"><span class="toc-number">4.17.</span> <span class="toc-text">第3章-17 操作符小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-18-%E6%80%BB%E7%BB%93"><span class="toc-number">4.18.</span> <span class="toc-text">第3章-18 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">第4章 控制执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">第5章 初始化与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-1-%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%A1%AE%E4%BF%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">第5章-1 用构造器确保初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-2-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">6.2.</span> <span class="toc-text">第5章-2 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">第5章-3 默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.4.</span> <span class="toc-text">第5章-4 this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-1-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">6.4.1.</span> <span class="toc-text">第5章-4-1 在构造器中调用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-2-static%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">第5章-4-2 static的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.5.</span> <span class="toc-text">第5章-5 清理：终结处理和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-1-finalize-%E7%9A%84%E7%94%A8%E9%80%94%E4%BD%95%E5%9C%A8"><span class="toc-number">6.5.1.</span> <span class="toc-text">第5章-5-1 finalize()的用途何在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-2-%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%AE%9E%E6%96%BD%E6%B8%85%E7%90%86"><span class="toc-number">6.5.2.</span> <span class="toc-text">第5章-5-2 你必须实施清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-3-%E7%BB%88%E7%BB%93%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.5.3.</span> <span class="toc-text">第5章-5-3 终结条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">6.5.4.</span> <span class="toc-text">第5章-5-4 垃圾回收器如何工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.6.</span> <span class="toc-text">第5章-6 成员初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-1-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.6.1.</span> <span class="toc-text">第5章-6-1 指定初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.</span> <span class="toc-text">第5章-7 构造器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.7.1.</span> <span class="toc-text">第5章-7-1 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-2-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.2.</span> <span class="toc-text">第5章-7-2 静态数据的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B9%A6%E4%B8%AD%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8D%E5%A4%9F%E5%A5%BD%EF%BC%8C%E8%AF%A6%E8%A7%81%E4%B9%A0%E9%A2%98%EF%BC%89"><span class="toc-number">6.7.3.</span> <span class="toc-text">总结一下对象创建的过程（书中的总结不够好，详见习题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-3-%E6%98%BE%E5%BC%8F%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.4.</span> <span class="toc-text">第5章-7-3 显式的静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-4-%E9%9D%9E%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.7.5.</span> <span class="toc-text">第5章-7-4 非静态实例初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">6.8.</span> <span class="toc-text">第5章-8 数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%86%92%E6%A6%82%E5%BF%B5"><span class="toc-number">6.8.1.</span> <span class="toc-text">数组→概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%86%92%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">6.8.2.</span> <span class="toc-text">数组→定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%86%92%E7%89%B9%E7%82%B9"><span class="toc-number">6.8.3.</span> <span class="toc-text">数组→特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">6.8.4.</span> <span class="toc-text">数组初始化的3种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">6.8.5.</span> <span class="toc-text">第5章-8-1 可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.</span> <span class="toc-text">第5章-9 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">6.9.1.</span> <span class="toc-text">额外参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enum%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.9.2.</span> <span class="toc-text">第5章-9-1 枚举类（enum）——基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">6.9.3.</span> <span class="toc-text">第5章-9-2 枚举类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">6.10.</span> <span class="toc-text">第5章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">第6章 访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-%E5%8C%85%EF%BC%9A%E5%BA%93%E5%8D%95%E5%85%83"><span class="toc-number">7.1.</span> <span class="toc-text">第6章-1 包：库单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-1-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-number">7.1.1.</span> <span class="toc-text">第6章-1-1 代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-2-%E5%88%9B%E5%BB%BA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%8C%85%E5%90%8D"><span class="toc-number">7.1.2.</span> <span class="toc-text">第6章-1-2 创建独一无二的包名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B2%E7%AA%81"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-3-%E5%AE%9A%E5%88%B6%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-number">7.1.3.</span> <span class="toc-text">第6章-1-3 定制工具库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-4-%E7%94%A8import%E6%94%B9%E5%8F%98%E8%A1%8C%E4%B8%BA"><span class="toc-number">7.1.4.</span> <span class="toc-text">第6章-1-4 用import改变行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-5-%E5%AF%B9%E4%BD%BF%E7%94%A8%E5%8C%85%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-number">7.1.5.</span> <span class="toc-text">第6章-1-5 对使用包的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-2-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-number">7.2.</span> <span class="toc-text">第6章-2 Java访问权限修饰词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">第6章-3 接口和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">使用封装的原因（好处）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-4-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">7.4.</span> <span class="toc-text">第6章-4 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-5-%E6%80%BB%E7%BB%93"><span class="toc-number">7.5.</span> <span class="toc-text">第6章-5 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">第7章 复用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-1-%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">第7章-1 组合语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">第7章-2 继承语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB"><span class="toc-number">8.2.1.</span> <span class="toc-text">第7章-2-1 初始化基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%AF%B9%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E3%80%82"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">Java会自动在派生类的构造器中插入对基类构造器的调用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">带参数的构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E7%AC%AC7%E7%AB%A0-2-2-%E9%87%8D%E5%86%99"><span class="toc-number">8.2.2.</span> <span class="toc-text">【拓展】第7章-2-2 重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E8%A7%84%E5%88%99"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">重写（Override）规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">8.2.2.2.</span> <span class="toc-text">Super关键字的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.2.3.</span> <span class="toc-text">重写（Override）与重载（Overload）之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">8.2.2.4.</span> <span class="toc-text">重写（Override）与重载（Overload）之间的联系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-3-%E4%BB%A3%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">第7章-3 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">8.4.</span> <span class="toc-text">第7章-4 结合使用组合和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-1-%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86"><span class="toc-number">8.4.1.</span> <span class="toc-text">第7章-4-1 确保正确清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-2-%E5%90%8D%E7%A7%B0%E5%B1%8F%E8%94%BD"><span class="toc-number">8.4.2.</span> <span class="toc-text">第7章-4-2 名称屏蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-5-%E5%9C%A8%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-number">8.5.</span> <span class="toc-text">第7章-5 在组合与继承之间选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.5.1.</span> <span class="toc-text">组合和继承的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">8.5.2.</span> <span class="toc-text">在组合和继承之间的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-6-protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.6.</span> <span class="toc-text">第7章-6 protected关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.7.</span> <span class="toc-text">第7章-7 向上转型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%B0%E4%B8%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.7.1.</span> <span class="toc-text">第7章-7-1 为什么称为向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-2-%E5%86%8D%E8%AE%BA%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">8.7.2.</span> <span class="toc-text">第7章-7-2 再论组合与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.8.</span> <span class="toc-text">第7章-8 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-1-final%E6%95%B0%E6%8D%AE"><span class="toc-number">8.8.1.</span> <span class="toc-text">第7章-8-1 final数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%99%BDfinal"><span class="toc-number">8.8.1.1.</span> <span class="toc-text">空白final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%8F%82%E6%95%B0"><span class="toc-number">8.8.1.2.</span> <span class="toc-text">final参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-2-final%E6%96%B9%E6%B3%95"><span class="toc-number">8.8.2.</span> <span class="toc-text">第7章-8-2 final方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%92%8Cprivate%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.8.2.1.</span> <span class="toc-text">final和private关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-3-final%E7%B1%BB"><span class="toc-number">8.8.3.</span> <span class="toc-text">第7章-8-3 final类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-4-%E6%9C%89%E5%85%B3final%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-number">8.8.4.</span> <span class="toc-text">第7章-8-4 有关final的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.9.</span> <span class="toc-text">第7章-9 初始化类及类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-9-1-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.9.1.</span> <span class="toc-text">第7章-9-1 继承与初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">8.10.</span> <span class="toc-text">第7章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">第8章 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-1-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">第8章-1 再论向上转型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-1-1-%E5%BF%98%E8%AE%B0%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">第8章-1-1 忘记对象类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-%E8%BD%AC%E6%9C%BA"><span class="toc-number">9.2.</span> <span class="toc-text">第8章-2 转机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%91%E5%AE%9A"><span class="toc-number">9.2.1.</span> <span class="toc-text">第8章-2-1 方法调用绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-2-%E4%BA%A7%E7%94%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.2.2.</span> <span class="toc-text">第8章-2-2 产生正确的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-3-%E5%8F%AF%E6%8B%93%E5%B1%95%E6%80%A7"><span class="toc-number">9.2.3.</span> <span class="toc-text">第8章-2-3 可拓展性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-4-%E7%BC%BA%E9%99%B7%EF%BC%9A%E2%80%9C%E8%A6%86%E7%9B%96%E2%80%9D%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.4.</span> <span class="toc-text">第8章-2-4 缺陷：“覆盖”私有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-5-%E7%BC%BA%E9%99%B7%EF%BC%9A%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.5.</span> <span class="toc-text">第8章-2-5 缺陷：域与静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">9.3.</span> <span class="toc-text">第8章-3 构造器和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-1-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">9.3.1.</span> <span class="toc-text">第8章-3-1 构造器的调用顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-2-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-number">9.3.2.</span> <span class="toc-text">第8章-3-2 继承与清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.3.3.</span> <span class="toc-text">第8章-3-3 构造器内部的多态方法的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-4-%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.4.</span> <span class="toc-text">第8章-4 协变返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.5.</span> <span class="toc-text">第8章-5 用继承进行设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-1-%E7%BA%AF%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8B%93%E5%B1%95"><span class="toc-number">9.5.1.</span> <span class="toc-text">第8章-5-1 纯继承与拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-number">9.5.2.</span> <span class="toc-text">第8章-5-2 向下转型与运行时类型识别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%EF%BC%88RTTI%EF%BC%89"><span class="toc-number">9.5.2.1.</span> <span class="toc-text">运行时类型识别（RTTI）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-number">9.6.</span> <span class="toc-text">第8章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">第9章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.0.1.</span> <span class="toc-text">关于接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">10.1.</span> <span class="toc-text">第9章-1 抽象类和抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%85%B7%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.1.</span> <span class="toc-text">抽象类具体定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.1.2.</span> <span class="toc-text">抽象类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%85%B7%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.3.</span> <span class="toc-text">抽象方法具体定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.</span> <span class="toc-text">第9章-2 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-3-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">10.3.</span> <span class="toc-text">第9章-3 完全解耦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-4-Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">10.4.</span> <span class="toc-text">第9章-4 Java中的多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-5-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.5.</span> <span class="toc-text">第9章-5 通过继承来拓展接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-6-%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.6.</span> <span class="toc-text">第9章-6 适配接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-7-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F"><span class="toc-number">10.7.</span> <span class="toc-text">第9章-7 接口中的域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-8-%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.8.</span> <span class="toc-text">第9章-8 嵌套接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-number">10.9.</span> <span class="toc-text">第9章-9 接口与工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">10.10.</span> <span class="toc-text">第9章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">第10章 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-1-%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">第10章-1 创建内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-2-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">第10章-2 链接到外部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-3-%E4%BD%BF%E7%94%A8-this%E4%B8%8E-new"><span class="toc-number">11.3.</span> <span class="toc-text">第10章-3 使用.this与.new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-4-%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">11.4.</span> <span class="toc-text">第10章-4 内部类与向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-5-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.5.</span> <span class="toc-text">第10章-5 在方法和作用域内的内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.6.</span> <span class="toc-text">第10章-6 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-7-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-number">11.7.</span> <span class="toc-text">第10章-7 嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.8.</span> <span class="toc-text">第10章-8 为什么需要内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-9-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">11.9.</span> <span class="toc-text">第10章-9 内部类的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-10-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A6%86%E7%9B%96%E5%90%97"><span class="toc-number">11.10.</span> <span class="toc-text">第10章-10 内部类可以被覆盖吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-11-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">11.11.</span> <span class="toc-text">第10章-11 局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-12-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">11.12.</span> <span class="toc-text">第10章-12 内部类标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-13-%E6%80%BB%E7%BB%93"><span class="toc-number">11.13.</span> <span class="toc-text">第10章-13 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.</span> <span class="toc-text">第11章 持有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-1-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">12.1.</span> <span class="toc-text">第11章-1 泛型和类型安全的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">12.2.</span> <span class="toc-text">第11章-2 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">12.3.</span> <span class="toc-text">第11章-3 添加一组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-4-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-number">12.4.</span> <span class="toc-text">第11章-4 容器的打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-5-List%EF%BC%88%E5%8E%9F%E7%90%86-amp-%E7%AE%80%E4%BB%8B%EF%BC%89"><span class="toc-number">12.5.</span> <span class="toc-text">第11章-5 List（原理 &amp; 简介）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-6-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.6.</span> <span class="toc-text">第11章-6 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-7-LinkedList"><span class="toc-number">12.7.</span> <span class="toc-text">第11章-7 LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-8-Stack"><span class="toc-number">12.8.</span> <span class="toc-text">第11章-8 Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-9-Set"><span class="toc-number">12.9.</span> <span class="toc-text">第11章-9 Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-10-Map"><span class="toc-number">12.10.</span> <span class="toc-text">第11章-10 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-11-Queue"><span class="toc-number">12.11.</span> <span class="toc-text">第11章-11 Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-12-Collection%E5%92%8CIterator"><span class="toc-number">12.12.</span> <span class="toc-text">第11章-12 Collection和Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-Foreach%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">12.13.</span> <span class="toc-text">第11章-13 Foreach与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%96%B9%E6%B3%95%E6%83%AF%E7%94%A8%E6%B3%95%E2%86%92%E7%A4%BA%E4%BE%8B%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">12.13.1.</span> <span class="toc-text">第11章-13-1 适配器方法惯用法→示例源码说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">12.14.</span> <span class="toc-text">第11章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">13.</span> <span class="toc-text">第12章 通过异常处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">13.1.</span> <span class="toc-text">第12章-1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-number">13.2.</span> <span class="toc-text">第12章-2 基本异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-1-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%8F%82%E6%95%B0"><span class="toc-number">13.2.1.</span> <span class="toc-text">第12章-2-1 捕获异常参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">13.3.</span> <span class="toc-text">第12章-3 捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-1-try%E5%9D%97"><span class="toc-number">13.3.1.</span> <span class="toc-text">第12章-3-1 try块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-number">13.3.2.</span> <span class="toc-text">第12章-3-2 异常处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">13.4.</span> <span class="toc-text">第12章-4 创建自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-1-%E5%BC%82%E5%B8%B8%E4%B8%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-number">13.4.1.</span> <span class="toc-text">第12章-4-1 异常与记录日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-5-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-number">13.5.</span> <span class="toc-text">第12章-5 异常说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-number">13.6.</span> <span class="toc-text">第12章-6 捕获所有异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-1-%E6%A0%88%E8%BD%A8%E8%BF%B9"><span class="toc-number">13.6.1.</span> <span class="toc-text">第12章-6-1 栈轨迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-2-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">13.6.2.</span> <span class="toc-text">第12章-6-2 重新抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-3-%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-number">13.6.3.</span> <span class="toc-text">第12章-6-3 异常链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-Java%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-number">13.7.</span> <span class="toc-text">第12章-7 Java标准异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-1-%E7%89%B9%E4%BE%8B%EF%BC%9ARuntimeException"><span class="toc-number">13.7.1.</span> <span class="toc-text">第12章-7-1 特例：RuntimeException</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-%E4%BD%BF%E7%94%A8finally%E8%BF%9B%E8%A1%8C%E6%B8%85%E7%90%86"><span class="toc-number">13.8.</span> <span class="toc-text">第12章-8 使用finally进行清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-1-finally%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">13.8.1.</span> <span class="toc-text">第12章-8-1 finally用来做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-2-%E5%9C%A8return%E4%B8%AD%E4%BD%BF%E7%94%A8finally"><span class="toc-number">13.8.2.</span> <span class="toc-text">第12章-8-2 在return中使用finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-3-%E7%BC%BA%E6%86%BE%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BC%BA%E5%A4%B1"><span class="toc-number">13.8.3.</span> <span class="toc-text">第12章-8-3 缺憾：异常缺失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-9-%E5%BC%82%E5%B8%B8%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">13.9.</span> <span class="toc-text">第12章-9 异常的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-10-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">13.10.</span> <span class="toc-text">第12章-10 构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%8C%B9%E9%85%8D"><span class="toc-number">13.11.</span> <span class="toc-text">第12章-11 异常匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89%E6%96%B9%E5%BC%8F"><span class="toc-number">13.12.</span> <span class="toc-text">第12章-12 其他可选方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-1-%E5%8E%86%E5%8F%B2"><span class="toc-number">13.12.1.</span> <span class="toc-text">第12章-12-1 历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-2-%E8%A7%82%E7%82%B9"><span class="toc-number">13.12.2.</span> <span class="toc-text">第12章-12-2 观点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-3-%E6%8A%8A%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92%E7%BB%99%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">13.12.3.</span> <span class="toc-text">第12章-12-3 把异常传递给控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-4-%E6%8A%8A%E2%80%9C%E8%A2%AB%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E2%80%9C%E4%B8%8D%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D"><span class="toc-number">13.12.4.</span> <span class="toc-text">第12章-12-4 把“被检查的异常”转换为“不检查的异常”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-13-%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-number">13.13.</span> <span class="toc-text">第12章-13 异常使用指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">13.14.</span> <span class="toc-text">第12章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">14.</span> <span class="toc-text">第13章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-1-%E4%B8%8D%E5%8F%AF%E5%8F%98String"><span class="toc-number">14.1.</span> <span class="toc-text">第13章-1 不可变String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-2-%E9%87%8D%E8%BD%BD%E2%80%9C-%E2%80%9D%E4%B8%8EStringBuilder"><span class="toc-number">14.2.</span> <span class="toc-text">第13章-2 重载“+”与StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-3-%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-number">14.3.</span> <span class="toc-text">第13章-3 无意识的递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-4-String%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">14.4.</span> <span class="toc-text">第13章-4 String上的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">14.5.</span> <span class="toc-text">第13章-5 格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-number">14.5.1.</span> <span class="toc-text">第13章-5-4 格式化说明符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.6.</span> <span class="toc-text">第13章-6 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-7-%E6%89%AB%E6%8F%8F%E8%BE%93%E5%85%A5"><span class="toc-number">14.7.</span> <span class="toc-text">第13章-7 扫描输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-8-StringTokenizer%EF%BC%88%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="toc-number">14.8.</span> <span class="toc-text">第13章-8 StringTokenizer（已废弃）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-9-%E6%80%BB%E7%BB%93"><span class="toc-number">14.9.</span> <span class="toc-text">第13章-9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%88RTTI%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">第14章 类型信息（RTTI）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81RTTI"><span class="toc-number">15.1.</span> <span class="toc-text">第14章-1 为什么需要RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.2.</span> <span class="toc-text">第14章-2 Class对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-1-%E7%B1%BB%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">15.2.1.</span> <span class="toc-text">第14章-2-1 类字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-2-%E6%B3%9B%E5%8C%96%E7%9A%84Class%E5%BC%95%E7%94%A8"><span class="toc-number">15.2.2.</span> <span class="toc-text">第14章-2-2 泛化的Class引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-3-%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%8E%9F%EF%BC%9A%E6%96%B0%E7%9A%84%E8%BD%AC%E5%9E%8B%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-number">15.2.3.</span> <span class="toc-text">第14章-2-3 类的转换（原：新的转型语法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%8D%E5%85%88%E5%81%9A%E6%A3%80%E6%9F%A5"><span class="toc-number">15.3.</span> <span class="toc-text">第14章-3 类型转换前先做检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-4-%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82"><span class="toc-number">15.4.</span> <span class="toc-text">第14章-4 注册工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-5-instanceof%E4%B8%8EClass%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-number">15.5.</span> <span class="toc-text">第14章-5 instanceof与Class的等价性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-%E5%8F%8D%E5%B0%84%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-number">15.6.</span> <span class="toc-text">第14章-6 反射：运行时的类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-1-%E7%B1%BB%E6%96%B9%E6%B3%95%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-number">15.6.1.</span> <span class="toc-text">第14章-6-1 类方法提取器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-7-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">15.7.</span> <span class="toc-text">第14章-7 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">15.8.</span> <span class="toc-text">第14章-8 空对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-1-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A1%A9"><span class="toc-number">15.8.1.</span> <span class="toc-text">第14章-8-1 模拟对象与桩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">15.9.</span> <span class="toc-text">第14章-9 接口与类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-number">15.10.</span> <span class="toc-text">第14章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.</span> <span class="toc-text">第15章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-1-%E4%B8%8EC-%E6%AF%94%E8%BE%83"><span class="toc-number">16.1.</span> <span class="toc-text">第15章-1 与C++比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.2.</span> <span class="toc-text">第15章-2 简单泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-1-%E4%B8%80%E4%B8%AA%E5%85%83%E7%A5%96%E7%B1%BB%E5%BA%93"><span class="toc-number">16.2.1.</span> <span class="toc-text">第15章-2-1 一个元祖类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-2-%E4%B8%80%E4%B8%AA%E5%A0%86%E6%A0%88%E7%B1%BB"><span class="toc-number">16.2.2.</span> <span class="toc-text">第15章-2-2 一个堆栈类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-3-RandomList"><span class="toc-number">16.2.3.</span> <span class="toc-text">第15章-2-3 RandomList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-3-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.3.</span> <span class="toc-text">第15章-3 泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.</span> <span class="toc-text">第15章-4 泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-1-%E6%9D%A0%E6%9D%86%E5%88%A9%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%88%A4%E6%96%AD"><span class="toc-number">16.4.1.</span> <span class="toc-text">第15章-4-1 杠杆利用类型参数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.2.</span> <span class="toc-text">第15章-4-2 可变参数与泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-3-%E7%94%A8%E4%BA%8EGenerator%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">16.4.3.</span> <span class="toc-text">第15章-4-3 用于Generator的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-4-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Generator"><span class="toc-number">16.4.4.</span> <span class="toc-text">第15章-4-4 一个通用的Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-5-%E7%AE%80%E5%8C%96%E5%85%83%E7%A5%96%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.4.5.</span> <span class="toc-text">第15章-4-5 简化元祖的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-6-%E4%B8%80%E4%B8%AASet%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">16.4.6.</span> <span class="toc-text">第15章-4-6 一个Set实用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">16.5.</span> <span class="toc-text">第15章-5 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">16.6.</span> <span class="toc-text">第15章-6 构建复杂模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-%E6%93%A6%E9%99%A4%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-number">16.7.</span> <span class="toc-text">第15章-7 擦除的神秘之处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-1-C-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">16.7.1.</span> <span class="toc-text">第15章-7-1 C++的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-2-%E8%BF%81%E7%A7%BB%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">16.7.2.</span> <span class="toc-text">第15章-7-2 迁移兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-3-%E6%93%A6%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">16.7.3.</span> <span class="toc-text">第15章-7-3 擦除的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-4-%E8%BE%B9%E7%95%8C%E5%A4%84%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-number">16.7.4.</span> <span class="toc-text">第15章-7-4 边界处的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-%E6%93%A6%E9%99%A4%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">16.8.</span> <span class="toc-text">第15章-8 擦除的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-1-%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="toc-number">16.8.1.</span> <span class="toc-text">第15章-8-1 创建类型实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-2-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">16.8.2.</span> <span class="toc-text">第15章-8-2 泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-9-%E8%BE%B9%E7%95%8C"><span class="toc-number">16.9.</span> <span class="toc-text">第15章-9 边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">16.10.</span> <span class="toc-text">第15章-10 通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-1-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E5%A4%9A%E8%81%AA%E6%98%8E"><span class="toc-number">16.10.1.</span> <span class="toc-text">第15章-10-1 编译器有多聪明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-2-%E9%80%86%E5%8F%98"><span class="toc-number">16.10.2.</span> <span class="toc-text">第15章-10-2 逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-3-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">16.10.3.</span> <span class="toc-text">第15章-10-3 无界通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-4-%E6%8D%95%E8%8E%B7%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7%EF%BC%89"><span class="toc-number">16.10.4.</span> <span class="toc-text">第15章-10-4 捕获转换（通配符捕获）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-%E9%97%AE%E9%A2%98"><span class="toc-number">16.11.</span> <span class="toc-text">第15章-11 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-1-%E4%BB%BB%E4%BD%95%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E9%83%BD%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.11.1.</span> <span class="toc-text">第15章-11-1 任何基本类型都不能作为类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-2-%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.11.2.</span> <span class="toc-text">第15章-11-2 实现参数化接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-3-%E8%BD%AC%E5%9E%8B%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="toc-number">16.11.3.</span> <span class="toc-text">第15章-11-3 转型和警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-4-%E9%87%8D%E8%BD%BD"><span class="toc-number">16.11.4.</span> <span class="toc-text">第15章-11-4 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-5-%E5%9F%BA%E7%B1%BB%E5%8A%AB%E6%8C%81%E4%BA%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.11.5.</span> <span class="toc-text">第15章-11-5 基类劫持了接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-%E8%87%AA%E9%99%90%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.12.</span> <span class="toc-text">第15章-12 自限定的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-1-%E5%8F%A4%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">16.12.1.</span> <span class="toc-text">第15章-12-1 古怪的循环泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-2-%E8%87%AA%E9%99%90%E5%AE%9A"><span class="toc-number">16.12.2.</span> <span class="toc-text">第15章-12-2 自限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-3-%E5%8F%82%E6%95%B0%E5%8D%8F%E5%8F%98"><span class="toc-number">16.12.3.</span> <span class="toc-text">第15章-12-3 参数协变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-13-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">16.13.</span> <span class="toc-text">第15章-13 动态类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-14-%E5%BC%82%E5%B8%B8"><span class="toc-number">16.14.</span> <span class="toc-text">第15章-14 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-%E6%B7%B7%E5%9E%8B"><span class="toc-number">16.15.</span> <span class="toc-text">第15章-15 混型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-1-C-%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%9E%8B"><span class="toc-number">16.15.1.</span> <span class="toc-text">第15章-15-1 C++中的混型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-2-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B7%E5%90%88"><span class="toc-number">16.15.2.</span> <span class="toc-text">第15章-15-2 与接口混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-3-%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.15.3.</span> <span class="toc-text">第15章-15-3 使用装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-4-%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%B7%B7%E5%90%88"><span class="toc-number">16.15.4.</span> <span class="toc-text">第15章-15-4 与动态代理混合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-16-%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">16.16.</span> <span class="toc-text">第15章-16 潜在类型机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-%E5%AF%B9%E7%BC%BA%E4%B9%8F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">16.17.</span> <span class="toc-text">第15章-17 对缺乏潜在类型机制的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-1-%E5%8F%8D%E5%B0%84"><span class="toc-number">16.17.1.</span> <span class="toc-text">第15章-17-1 反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-2-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E4%BA%8E%E5%BA%8F%E5%88%97"><span class="toc-number">16.17.2.</span> <span class="toc-text">第15章-17-2 将一个方法应用于序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-3-%E5%BD%93%E4%BD%A0%E5%B9%B6%E4%B8%BA%E7%A2%B0%E5%B7%A7%E6%8B%A5%E6%9C%89%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6"><span class="toc-number">16.17.3.</span> <span class="toc-text">第15章-17-3 当你并为碰巧拥有正确的接口时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-4-%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%BB%BF%E7%9C%9F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">16.17.4.</span> <span class="toc-text">第15章-17-4 用适配器仿真潜在类型机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-18-%E5%B0%86%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="toc-number">16.18.</span> <span class="toc-text">第15章-18 将函数对象用作策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-%E6%80%BB%E7%BB%93%EF%BC%9A%E8%BD%AC%E5%9E%8B%E7%9C%9F%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%B3%9F%E5%90%97%EF%BC%9F"><span class="toc-number">16.19.</span> <span class="toc-text">第15章-19 总结：转型真的如此之糟吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-1-%E8%BF%9B%E9%98%B6%E8%AF%BB%E7%89%A9"><span class="toc-number">16.19.1.</span> <span class="toc-text">第15章-19-1 进阶读物</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-number">17.</span> <span class="toc-text">第16章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-1-%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E6%AE%8A"><span class="toc-number">17.1.</span> <span class="toc-text">第16章-1 数组为什么特殊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-2-%E6%95%B0%E7%BB%84%E6%98%AF%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.2.</span> <span class="toc-text">第16章-2 数组是第一级对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-3-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">17.3.</span> <span class="toc-text">第16章-3 返回一个数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">17.4.</span> <span class="toc-text">第16章-4 多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-5-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">17.5.</span> <span class="toc-text">第16章-5 数组与泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">17.6.</span> <span class="toc-text">第16章-6 创建测试数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-1-Arrays-fill"><span class="toc-number">17.6.1.</span> <span class="toc-text">第16章-6-1 Arrays.fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-2-%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">17.6.2.</span> <span class="toc-text">第16章-6-2 数据生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-3-%E4%BB%8EGenerator%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">17.6.3.</span> <span class="toc-text">第16章-6-3 从Generator中创建数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-Arrays%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">17.7.</span> <span class="toc-text">第16章-7 Arrays实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-1-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-number">17.7.1.</span> <span class="toc-text">第16章-7-1 复制数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-2-%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">17.7.2.</span> <span class="toc-text">第16章-7-2 数组的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-3-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">17.7.3.</span> <span class="toc-text">第16章-7-3 数组元素的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-4-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">17.7.4.</span> <span class="toc-text">第16章-7-4 数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-5-%E5%9C%A8%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-number">17.7.5.</span> <span class="toc-text">第16章-7-5 在已排序的数组中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-8-%E6%80%BB%E7%BB%93"><span class="toc-number">17.8.</span> <span class="toc-text">第16章-8 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="toc-number">18.</span> <span class="toc-text">第17章 容器深入研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-1-%E5%AE%8C%E6%95%B4%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-number">18.1.</span> <span class="toc-text">第17章-1 完整容器分类法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-%E5%A1%AB%E5%85%85%E5%AE%B9%E5%99%A8"><span class="toc-number">18.2.</span> <span class="toc-text">第17章-2 填充容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-1-%E4%B8%80%E7%A7%8DGenerator%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">18.2.1.</span> <span class="toc-text">第17章-2-1 一种Generator解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-2-Map%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">18.2.2.</span> <span class="toc-text">第17章-2-2 Map生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-3-%E4%BD%BF%E7%94%A8Abstract%E7%B1%BB"><span class="toc-number">18.2.3.</span> <span class="toc-text">第17章-2-3 使用Abstract类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-3-Collection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">18.3.</span> <span class="toc-text">第17章-3 Collection的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C"><span class="toc-number">18.4.</span> <span class="toc-text">第17章-4 可选操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-1-%E6%9C%AA%E8%8E%B7%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">18.4.1.</span> <span class="toc-text">第17章-4-1 未获支持的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-5-List%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-number">18.5.</span> <span class="toc-text">第17章-5 List的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-Set%E5%92%8C%E5%AD%98%E5%82%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">18.6.</span> <span class="toc-text">第17章-6 Set和存储排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-1-SortedSet"><span class="toc-number">18.6.1.</span> <span class="toc-text">第17章-6-1 SortedSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-%E9%98%9F%E5%88%97"><span class="toc-number">18.7.</span> <span class="toc-text">第17章-7 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-1-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">18.7.1.</span> <span class="toc-text">第17章-7-1 优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-2-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-number">18.7.2.</span> <span class="toc-text">第17章-7-2 双向队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-%E7%90%86%E8%A7%A3Map"><span class="toc-number">18.8.</span> <span class="toc-text">第17章-8 理解Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-1-%E6%80%A7%E8%83%BD"><span class="toc-number">18.8.1.</span> <span class="toc-text">第17章-8-1 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-2-SortedMap"><span class="toc-number">18.8.2.</span> <span class="toc-text">第17章-8-2 SortedMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-3-LinkedHashMap"><span class="toc-number">18.8.3.</span> <span class="toc-text">第17章-8-3 LinkedHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-%E6%95%A3%E5%88%97%E4%B8%8E%E6%95%A3%E5%88%97%E7%A0%81"><span class="toc-number">18.9.</span> <span class="toc-text">第17章-9 散列与散列码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-1-%E7%90%86%E8%A7%A3hashCode"><span class="toc-number">18.9.1.</span> <span class="toc-text">第17章-9-1 理解hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-2-%E4%B8%BA%E9%80%9F%E5%BA%A6%E8%80%8C%E6%95%A3%E5%88%97"><span class="toc-number">18.9.2.</span> <span class="toc-text">第17章-9-2 为速度而散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-3-%E8%A6%86%E7%9B%96hashCode"><span class="toc-number">18.9.3.</span> <span class="toc-text">第17章-9-3 覆盖hashCode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.10.</span> <span class="toc-text">第17章-10 选择接口的不同实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-1-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-number">18.10.1.</span> <span class="toc-text">第17章-10-1 性能测试框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-2-%E5%AF%B9List%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">18.10.2.</span> <span class="toc-text">第17章-10-2 对List的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-3-%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-number">18.10.3.</span> <span class="toc-text">第17章-10-3 微基准测试的危险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-4-%E5%AF%B9Set%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">18.10.4.</span> <span class="toc-text">第17章-10-4 对Set的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-5-%E5%AF%B9Map%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">18.10.5.</span> <span class="toc-text">第17章-10-5 对Map的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.11.</span> <span class="toc-text">第17章-11 实用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-1-List%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">18.11.1.</span> <span class="toc-text">第17章-11.1 List的排序和查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-2-%E8%AE%BE%E5%AE%9ACollection%E6%88%96Map%E4%B8%BA%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-number">18.11.2.</span> <span class="toc-text">第17章-11.2 设定Collection或Map为不可修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-3-Collection%E6%88%96Map%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">18.11.3.</span> <span class="toc-text">第17章-11.3 Collection或Map的同步控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-%E6%8C%81%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-number">18.12.</span> <span class="toc-text">第17章-12 持有引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-1-WeakHashMap"><span class="toc-number">18.12.1.</span> <span class="toc-text">第17章-12.1 WeakHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-Java-1-0-1-1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">18.13.</span> <span class="toc-text">第17章-13 Java 1.0-1.1的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-1-Vector%E5%92%8CEnumeration"><span class="toc-number">18.13.1.</span> <span class="toc-text">第17章-13.1 Vector和Enumeration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-2-Hashtable"><span class="toc-number">18.13.2.</span> <span class="toc-text">第17章-13.2 Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-3-Stack"><span class="toc-number">18.13.3.</span> <span class="toc-text">第17章-13.3 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-4-BitSet"><span class="toc-number">18.13.4.</span> <span class="toc-text">第17章-13.4 BitSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-number">18.14.</span> <span class="toc-text">第17章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F"><span class="toc-number">19.</span> <span class="toc-text">第18章 Java IO系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-File%E7%B1%BB"><span class="toc-number">19.1.</span> <span class="toc-text">第18章-1 File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-1-%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E5%99%A8"><span class="toc-number">19.1.1.</span> <span class="toc-text">第18章-1-1 目录列表器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-2-%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">19.1.2.</span> <span class="toc-text">第18章-1-2 目录实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-3-%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E6%9F%A5%E5%8F%8A%E5%88%9B%E5%BB%BA"><span class="toc-number">19.1.3.</span> <span class="toc-text">第18章-1-3 目录的检查及创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-%E8%BE%93%E5%85%A5%EF%BC%88Input%EF%BC%89%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88Output%EF%BC%89"><span class="toc-number">19.2.</span> <span class="toc-text">第18章-2 输入（Input）和输出（Output）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-1-InputStream%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.2.1.</span> <span class="toc-text">第18章-2-1 InputStream类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-2-OutputStream%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.2.2.</span> <span class="toc-text">第18章-2-2 OutputStream类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">19.3.</span> <span class="toc-text">第18章-3 添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-1-%E9%80%9A%E8%BF%87FilterInputStream%E4%BB%8EInputStream%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">19.3.1.</span> <span class="toc-text">第18章-3-1 通过FilterInputStream从InputStream读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-2-%E9%80%9A%E8%BF%87FilterOutputStream%E4%BB%8EOutputStream%E5%86%99%E5%85%A5"><span class="toc-number">19.3.2.</span> <span class="toc-text">第18章-3-2 通过FilterOutputStream从OutputStream写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-Reader%E5%92%8CWriter"><span class="toc-number">19.4.</span> <span class="toc-text">第18章-4 Reader和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9D%A5%E6%BA%90%E5%92%8C%E5%8E%BB%E5%A4%84%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%89"><span class="toc-number">19.4.1.</span> <span class="toc-text">第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-2-%E6%9B%B4%E6%94%B9%E6%B5%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">19.4.2.</span> <span class="toc-text">第18章-4-2 更改流的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-3-%E6%9C%AA%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E7%B1%BB"><span class="toc-number">19.4.3.</span> <span class="toc-text">第18章-4-3 未发生变化的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-5-%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="toc-number">19.5.</span> <span class="toc-text">第18章-5 自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-IO%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">19.6.</span> <span class="toc-text">第18章-6 IO流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-1-%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-number">19.6.1.</span> <span class="toc-text">第18章-6-1 缓冲输入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-2-%E4%BB%8E%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-number">19.6.2.</span> <span class="toc-text">第18章-6-2 从内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-number">19.6.3.</span> <span class="toc-text">第18章-6-3 格式化的内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-number">19.6.4.</span> <span class="toc-text">第18章-6-4 基本的文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-5-%E5%AD%98%E5%82%A8%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">19.6.5.</span> <span class="toc-text">第18章-6-5 存储和恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-6-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">19.6.6.</span> <span class="toc-text">第18章-6-6 随机读写访问文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-7-%E7%AE%A1%E9%81%93%E6%B5%81"><span class="toc-number">19.6.7.</span> <span class="toc-text">第18章-6-7 管道流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">19.7.</span> <span class="toc-text">第18章-7 文件读写的实用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-1-%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">19.7.1.</span> <span class="toc-text">第18章-7-1 读取二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-%E6%A0%87%E5%87%86IO"><span class="toc-number">19.8.</span> <span class="toc-text">第18章-8 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-1-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-number">19.8.1.</span> <span class="toc-text">第18章-8-1 从标准输入中读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-2-%E5%B0%86System-out%E8%BD%AC%E6%8D%A2%E6%88%90PrintWriter"><span class="toc-number">19.8.2.</span> <span class="toc-text">第18章-8-2 将System.out转换成PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-3-%E6%A0%87%E5%87%86IO%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">19.8.3.</span> <span class="toc-text">第18章-8-3 标准IO重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-9-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">19.9.</span> <span class="toc-text">第18章-9 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-%E6%96%B0IO"><span class="toc-number">19.10.</span> <span class="toc-text">第18章-10 新IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-1-%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">19.10.1.</span> <span class="toc-text">第18章-10-1 转换数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-2-%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.10.2.</span> <span class="toc-text">第18章-10-2 获取基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-3-%E8%A7%86%E5%9B%BE%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-number">19.10.3.</span> <span class="toc-text">第18章-10-3 视图缓冲器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-4-%E7%94%A8%E7%BC%93%E5%86%B2%E5%99%A8%E6%93%8D%E7%BA%B5%E6%95%B0%E6%8D%AE"><span class="toc-number">19.10.4.</span> <span class="toc-text">第18章-10-4 用缓冲器操纵数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-5-%E7%BC%93%E5%86%B2%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">19.10.5.</span> <span class="toc-text">第18章-10-5 缓冲器的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">19.10.6.</span> <span class="toc-text">第18章-10-6 内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-7-%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-number">19.10.7.</span> <span class="toc-text">第18章-10-7 文件加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-%E5%8E%8B%E7%BC%A9"><span class="toc-number">19.11.</span> <span class="toc-text">第18章-11 压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-1-%E7%94%A8GZIP%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%8E%8B%E7%BC%A9"><span class="toc-number">19.11.1.</span> <span class="toc-text">第18章-11-1 用GZIP进行简单压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-2-%E7%94%A8Zip%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98"><span class="toc-number">19.11.2.</span> <span class="toc-text">第18章-11-2 用Zip进行多文件保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-3-Java%E6%A1%A3%E6%A1%88%E6%96%87%E4%BB%B6"><span class="toc-number">19.11.3.</span> <span class="toc-text">第18章-11-3 Java档案文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">19.12.</span> <span class="toc-text">第18章-12 对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-1-%E5%AF%BB%E6%89%BE%E7%B1%BB"><span class="toc-number">19.12.1.</span> <span class="toc-text">第18章-12-1 寻找类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-2-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">19.12.2.</span> <span class="toc-text">第18章-12-2 序列化的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-3-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%8C%81%E4%B9%85%E6%80%A7%E2%80%9D"><span class="toc-number">19.12.3.</span> <span class="toc-text">第18章-12-3 使用“持久性”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-13-XML"><span class="toc-number">19.13.</span> <span class="toc-text">第18章-13 XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-14-Preferences"><span class="toc-number">19.14.</span> <span class="toc-text">第18章-14 Preferences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-15-%E6%80%BB%E7%BB%93"><span class="toc-number">19.15.</span> <span class="toc-text">第18章-15 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">20.</span> <span class="toc-text">第19章 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-%E5%9F%BA%E6%9C%ACenum%E7%89%B9%E6%80%A7"><span class="toc-number">20.1.</span> <span class="toc-text">第19章-1 基本enum特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-1-%E5%B0%86%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E7%94%A8%E4%BA%8Eenum"><span class="toc-number">20.1.1.</span> <span class="toc-text">第19章-1-1 将静态导入用于enum</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-%E5%90%91enum%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-number">20.2.</span> <span class="toc-text">第19章-2 向enum中添加新方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-1-%E8%A6%86%E7%9B%96enum%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">20.2.1.</span> <span class="toc-text">第19章-2-1 覆盖enum的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-3-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84enum"><span class="toc-number">20.3.</span> <span class="toc-text">第19章-3 switch语句中的enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-4-values-%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-number">20.4.</span> <span class="toc-text">第19章-4 values()的神秘之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-5-%E5%AE%9E%E7%8E%B0%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-number">20.5.</span> <span class="toc-text">第19章-5 实现而非继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-6-%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96"><span class="toc-number">20.6.</span> <span class="toc-text">第19章-6 随机选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-7-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE"><span class="toc-number">20.7.</span> <span class="toc-text">第19章-7 使用接口组织枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-8-%E4%BD%BF%E7%94%A8EnumSet%E6%9B%BF%E4%BB%A3%E6%A0%87%E5%BF%97"><span class="toc-number">20.8.</span> <span class="toc-text">第19章-8 使用EnumSet替代标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-9-%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-number">20.9.</span> <span class="toc-text">第19章-9 使用EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">20.10.</span> <span class="toc-text">第19章-10 常量相关的方法（枚举类的抽象方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-1-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE"><span class="toc-number">20.10.1.</span> <span class="toc-text">第19章-10-1 使用enum的职责链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-2-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">20.10.2.</span> <span class="toc-text">第19章-10-2 使用enum的状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91"><span class="toc-number">20.11.</span> <span class="toc-text">第19章-11 多路分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-1-%E4%BD%BF%E7%94%A8enum%E5%88%86%E5%8F%91"><span class="toc-number">20.11.1.</span> <span class="toc-text">第19章-11-1 使用enum分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-2-%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">20.11.2.</span> <span class="toc-text">第19章-11-2 使用常量相关的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-3-%E4%BD%BF%E7%94%A8EnumMap%E5%88%86%E5%8F%91"><span class="toc-number">20.11.3.</span> <span class="toc-text">第19章-11-3 使用EnumMap分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-4-%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">20.11.4.</span> <span class="toc-text">第19章-11-4 使用二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-12-%E6%80%BB%E7%BB%93"><span class="toc-number">20.12.</span> <span class="toc-text">第19章-12 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.</span> <span class="toc-text">第20章 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">21.1.</span> <span class="toc-text">第20章-1 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-1-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.1.1.</span> <span class="toc-text">第20章-1-1 定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-2-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.1.2.</span> <span class="toc-text">第20章-1-2 元注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-%E7%BC%96%E5%86%99%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">21.2.</span> <span class="toc-text">第20章-2 编写注解处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-1-%E6%B3%A8%E8%A7%A3%E5%85%83%E7%B4%A0"><span class="toc-number">21.2.1.</span> <span class="toc-text">第20章-2-1 注解元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-2-%E9%BB%98%E8%AE%A4%E5%80%BC%E9%99%90%E5%88%B6"><span class="toc-number">21.2.2.</span> <span class="toc-text">第20章-2-2 默认值限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-3-%E7%94%9F%E6%88%90%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="toc-number">21.2.3.</span> <span class="toc-text">第20章-2-3 生成外部文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-4-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF"><span class="toc-number">21.2.4.</span> <span class="toc-text">第20章-2-4 注解不支持继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-5-%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">21.2.5.</span> <span class="toc-text">第20章-2-5 实现处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-3-%E4%BD%BF%E7%94%A8apt%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-number">21.3.</span> <span class="toc-text">第20章-3 使用apt处理注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-4-%E5%B0%86%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BA%8Eapt"><span class="toc-number">21.4.</span> <span class="toc-text">第20章-4 将观察者模式用于apt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">21.5.</span> <span class="toc-text">第20章-5 基于注解的单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-1-%E5%B0%86-Unit%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">21.5.1.</span> <span class="toc-text">第20章-5-1 将@Unit用于泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-2-%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BB%BB%E4%BD%95%E2%80%9C%E5%A5%97%E4%BB%B6%E2%80%9D"><span class="toc-number">21.5.2.</span> <span class="toc-text">第20章-5-2 不需要任何“套件”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-3-%E5%AE%9E%E7%8E%B0-Unit"><span class="toc-number">21.5.3.</span> <span class="toc-text">第20章-5-3 实现@Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-4-%E7%A7%BB%E9%99%A4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">21.5.4.</span> <span class="toc-text">第20章-5-4 移除测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-number">21.6.</span> <span class="toc-text">第20章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-number">22.</span> <span class="toc-text">第21章 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-1-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%80%A7"><span class="toc-number">22.1.</span> <span class="toc-text">第21章-1 并发的多面性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-number">22.2.</span> <span class="toc-text">第21章-2 基本的线程机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-3-%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90"><span class="toc-number">22.3.</span> <span class="toc-text">第21章-3 共享受限资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-4-%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="toc-number">22.4.</span> <span class="toc-text">第21章-4 终结任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-5-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-number">22.5.</span> <span class="toc-text">第21章-5 线程之间的协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-6-%E6%AD%BB%E9%94%81"><span class="toc-number">22.6.</span> <span class="toc-text">第21章-6 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-7-%E6%96%B0%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="toc-number">22.7.</span> <span class="toc-text">第21章-7 新类库中的构件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-8-%E4%BB%BF%E7%9C%9F"><span class="toc-number">22.8.</span> <span class="toc-text">第21章-8 仿真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-9-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">22.9.</span> <span class="toc-text">第21章-9 性能调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-10-%E6%B4%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">22.10.</span> <span class="toc-text">第21章-10 活动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-11-%E6%80%BB%E7%BB%93"><span class="toc-number">22.11.</span> <span class="toc-text">第21章-11 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC22%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-number">23.</span> <span class="toc-text">第22章 图形化用户界面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%96%E5%8F%82%E7%9C%8B"><span class="toc-number">24.</span> <span class="toc-text">📖参看</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%BB%E5%8F%82%E8%80%83%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">25.</span> <span class="toc-text">※参考和引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%97%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-number">26.</span> <span class="toc-text">🔗外部链接</span></a></li></ol>
                    </div>
                
                <hr />
                <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><blockquote>
<p>《Thinking in Java》(4th)&thinsp;的译本《Java编程思想》(第四版)&thinsp;的整理笔记。</p>
<p>该手册中还包括&thinsp;本人添加的&thinsp;一些知识更新和拓展。</p>
<span id="more"></span>

<p>顺便吐槽一下，译本的翻译比较生硬，很多地方使用<span class="hint--info hint--rounded hint--top" data-hint="从根源上分析，这是 汉语 和 English 在语言体系上的区别 导致的。" ontouchstart>容易出现歧义的长句</span></p>
</blockquote>
<hr>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol>
<li><p><a id="index_1" href="#第1章-面向对象导论" aria-label="跳转到章节" title="跳转到章节">第1章 面向对象导论</a></p>
<ul>
<li><a id="index_1-1" href="#第1章-1-抽象过程" aria-label="跳转到章节" title="跳转到章节">1.1 抽象过程</a></li>
<li><a id="index_1-2" href="#第1章-2-每个对象都有一个接口" aria-label="跳转到章节" title="跳转到章节">1.2 每个对象都有一个接口</a></li>
<li><a id="index_1-3" href="#第1章-3-每个对象都提供服务" aria-label="跳转到章节" title="跳转到章节">1.3 每个对象都提供服务</a></li>
<li><a id="index_1-4" href="#第1章-4-被隐藏的具体实现" aria-label="跳转到章节" title="跳转到章节">1.4 被隐藏的具体实现</a></li>
<li><a id="index_1-5" href="#第1章-5-复用具体实现" aria-label="跳转到章节" title="跳转到章节">1.5 复用具体实现</a></li>
<li><a id="index_1-6" href="#第1章-6-继承" aria-label="跳转到章节" title="跳转到章节">1.6 继承</a><ul>
<li><a id="index_1-6-1" href="#第1章-6-1-“是一个”与“像是一个”的关系" aria-label="跳转到章节" title="跳转到章节">1.6.1 “是一个”与“像是一个”的关系</a></li>
</ul>
</li>
<li><a id="index_1-7" href="#第1章-7-伴随多态的可互换对象" aria-label="跳转到章节" title="跳转到章节">1.7 伴随多态的可互换对象</a></li>
<li><a id="index_1-8" href="#第1章-8-单根继承结构" aria-label="跳转到章节" title="跳转到章节">1.8 单根继承结构</a></li>
<li><a id="index_1-9" href="#第1章-9-容器" aria-label="跳转到章节" title="跳转到章节">1.9 容器</a><ul>
<li><a id="index_1-9-1" href="#第1章-9-1-参数化类型" aria-label="跳转到章节" title="跳转到章节">1.9.1 参数化类型</a></li>
</ul>
</li>
<li><a id="index_1-10" href="#第1章-10-对象的创建和生命周期" aria-label="跳转到章节" title="跳转到章节">1.10 对象的创建和生命周期</a></li>
<li><a id="index_1-11" href="#第1章-11-异常处理：错误处理" aria-label="跳转到章节" title="跳转到章节">1.11 异常处理：错误处理</a></li>
<li><a id="index_1-12" href="#第1章-12-并发编程" aria-label="跳转到章节" title="跳转到章节">1.12 并发编程</a></li>
<li><a id="index_1-13" href="#第1章-13-Java与Internet" aria-label="跳转到章节" title="跳转到章节">1.13 Java与Internet</a><ul>
<li><a id="index_1-13-1" href="#第1章-13-1-Web是什么" aria-label="跳转到章节" title="跳转到章节">1.13.1 Web是什么</a></li>
<li><a id="index_1-13-2" href="#第1章-13-2-客户端编程" aria-label="跳转到章节" title="跳转到章节">1.13.2 客户端编程</a></li>
<li><a id="index_1-13-3" href="#第1章-13-3-服务器端编程" aria-label="跳转到章节" title="跳转到章节">1.13.3 服务器端编程</a></li>
</ul>
</li>
<li><a id="index_1-14" href="#第1章-14-总结" aria-label="跳转到章节" title="跳转到章节">1.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_2" href="#第2章-一切都是对象" aria-label="跳转到章节" title="跳转到章节">第2章 一切都是对象</a></p>
<ul>
<li><a id="index_2-1" href="#第2章-1-用引用操纵对象" aria-label="跳转到章节" title="跳转到章节">2.1 用引用操纵对象</a></li>
<li><a id="index_2-2" href="#第2章-2-必须由你创建所有对象【底层存储】" aria-label="跳转到章节" title="跳转到章节">2.2 必须由你创建所有对象【底层存储】</a><ul>
<li><a id="index_2-2-1" href="#第2章-2-1-存储到什么地方【对象的存储】" aria-label="跳转到章节" title="跳转到章节">2.2.1 存储到什么地方【对象的存储】</a></li>
<li><a id="index_2-2-2" href="#第2章-2-2-特例：基本类型" aria-label="跳转到章节" title="跳转到章节">2.2.2 特例：基本类型</a></li>
<li><a id="index_2-2-3" href="#第2章-2-3-Java中的数组" aria-label="跳转到章节" title="跳转到章节">2.2.3 Java中的数组</a></li>
</ul>
</li>
<li><a id="index_2-3" href="#第2章-3-永远不需要销毁对象" aria-label="跳转到章节" title="跳转到章节">2.3 永远不需要销毁对象</a></li>
<li><a id="index_2-4" href="#第2章-4-创建新的数据类型" aria-label="跳转到章节" title="跳转到章节">2.4 创建新的数据类型</a></li>
<li><a id="index_2-5" href="#第2章-5-方法、参数和返回值" aria-label="跳转到章节" title="跳转到章节">2.5 方法、参数和返回值</a></li>
<li><a id="index_2-6" href="#第2章-6-构建一个Java程序" aria-label="跳转到章节" title="跳转到章节">2.6 构建一个Java程序</a></li>
<li><a id="index_2-7" href="#第2章-7-你的第一个Java程序" aria-label="跳转到章节" title="跳转到章节">2.7 你的第一个Java程序</a></li>
<li><a id="index_2-8" href="#第2章-8-注释和嵌入式文档" aria-label="跳转到章节" title="跳转到章节">2.8 注释和嵌入式文档</a></li>
<li><a id="index_2-9" href="#第2章-9-编码风格" aria-label="跳转到章节" title="跳转到章节">2.9 编码风格</a></li>
<li><a id="index_2-10" href="#第2章-10-总结" aria-label="跳转到章节" title="跳转到章节">2.10 总结</a></li>
<li><a id="index_2-11" href="#第2章-11-练习" aria-label="跳转到章节" title="跳转到章节">2.11 练习</a></li>
</ul>
</li>
<li><p><a id="index_3" href="#第3章-操作符" aria-label="跳转到章节" title="跳转到章节">第3章 操作符</a></p>
<ul>
<li><a id="index_3-1" href="#第3章-1-更简单的打印语句" aria-label="跳转到章节" title="跳转到章节">3.1 更简单的打印语句</a></li>
<li><a id="index_3-2" href="#第3章-2-使用Java操作符" aria-label="跳转到章节" title="跳转到章节">3.2 使用Java操作符</a></li>
<li><a id="index_3-3" href="#第3章-3-优先级" aria-label="跳转到章节" title="跳转到章节">3.3 优先级</a></li>
<li><a id="index_3-4" href="#第3章-4-赋值" aria-label="跳转到章节" title="跳转到章节">3.4 赋值</a><ul>
<li><a id="index_3-4-1" href="#第3章-4-1-方法调用中的别名问题" aria-label="跳转到章节" title="跳转到章节">3.4.1 方法调用中的别名问题</a></li>
</ul>
</li>
<li><a id="index_3-5" href="#第3章-5-算数操作符" aria-label="跳转到章节" title="跳转到章节">3.5 算数操作符</a><ul>
<li><a id="index_3-5-1" href="#第3章-5-1-一元加减操作符" aria-label="跳转到章节" title="跳转到章节">3.5.1 一元加减操作符</a></li>
</ul>
</li>
<li><a id="index_3-6" href="#第3章-6-自动递增和递减" aria-label="跳转到章节" title="跳转到章节">3.6 自动递增和递减</a></li>
<li><a id="index_3-7" href="#第3章-7-关系操作符" aria-label="跳转到章节" title="跳转到章节">3.7 关系操作符</a><ul>
<li><a id="index_3-7-1" href="#第3章-7-1-测试对象的等价性" aria-label="跳转到章节" title="跳转到章节">3.7.1 测试对象的等价性</a></li>
</ul>
</li>
<li><a id="index_3-8" href="#第3章-8-逻辑操作符" aria-label="跳转到章节" title="跳转到章节">3.8 逻辑操作符</a><ul>
<li><a id="index_3-8-1" href="#第3章-8-1-短路" aria-label="跳转到章节" title="跳转到章节">3.8.1 短路</a></li>
</ul>
</li>
<li><a id="index_3-9" href="#第3章-9-直接常量" aria-label="跳转到章节" title="跳转到章节">3.9 直接常量</a><ul>
<li><a id="index_3-9-1" href="#第3章-9-1-指数记数法" aria-label="跳转到章节" title="跳转到章节">3.9.1 指数记数法</a></li>
</ul>
</li>
<li><a id="index_3-10" href="#第3章-10-按位操作符" aria-label="跳转到章节" title="跳转到章节">3.10 按位操作符</a></li>
<li><a id="index_3-11" href="#第3章-11-移位操作符" aria-label="跳转到章节" title="跳转到章节">3.11 移位操作符</a></li>
<li><a id="index_3-12" href="#第3章-12-三元操作符if-else" aria-label="跳转到章节" title="跳转到章节">3.12 三元操作符if-else</a></li>
<li><a id="index_3-13" href="#第3章-13-字符串操作符+和=" aria-label="跳转到章节" title="跳转到章节">3.13 字符串操作符+和=</a></li>
<li><a id="index_3-14" href="#第3章-14-使用操作符时常犯的错误" aria-label="跳转到章节" title="跳转到章节">3.14 使用操作符时常犯的错误</a></li>
<li><a id="index_3-15" href="#第3章-15-类型转换操作符" aria-label="跳转到章节" title="跳转到章节">3.15 类型转换操作符</a><ul>
<li><a id="index_3-15-1" href="#第3章-15-1-截尾和舍入" aria-label="跳转到章节" title="跳转到章节">3.15.1 截尾和舍入</a></li>
<li><a id="index_3-15-2" href="#第3章-15-2-提升" aria-label="跳转到章节" title="跳转到章节">3.15.2 提升</a></li>
</ul>
</li>
<li><a id="index_3-16" href="#第3章-16-Java没有sizeof" aria-label="跳转到章节" title="跳转到章节">3.16 Java没有sizeof</a></li>
<li><a id="index_3-17" href="#第3章-17-操作符小结" aria-label="跳转到章节" title="跳转到章节">3.17 操作符小结</a></li>
<li><a id="index_3-18" href="#第3章-18-总结" aria-label="跳转到章节" title="跳转到章节">3.18 总结</a></li>
</ul>
</li>
<li><p><a id="index_4" href="#第4章-控制执行流程" aria-label="跳转到章节" title="跳转到章节">第4章 控制执行流程</a></p>
</li>
<li><p><a id="index_5" href="#第5章-初始化与清理" aria-label="跳转到章节" title="跳转到章节">第5章 初始化与清理</a></p>
<ul>
<li><a id="index_5-1" href="#第5章-1-用构造器确保初始化" aria-label="跳转到章节" title="跳转到章节">5.1 用构造器确保初始化</a></li>
<li><a id="index_5-2" href="#第5章-2-方法重载" aria-label="跳转到章节" title="跳转到章节">5.2 方法重载</a></li>
<li><a id="index_5-3" href="#第5章-3-默认构造器" aria-label="跳转到章节" title="跳转到章节">5.3 默认构造器</a></li>
<li><a id="index_5-4" href="#第5章-4-this关键字" aria-label="跳转到章节" title="跳转到章节">5.4 this关键字</a><ul>
<li><a id="index_5-4-1" href="#第5章-4-1-在构造器中调用构造器" aria-label="跳转到章节" title="跳转到章节">5.4.1 在构造器中调用构造器</a></li>
<li><a id="index_5-4-2" href="#第5章-4-2-static的含义" aria-label="跳转到章节" title="跳转到章节">5.4.2 static的含义</a></li>
</ul>
</li>
<li><a id="index_5-5" href="#第5章-5-清理：终结处理和垃圾回收" aria-label="跳转到章节" title="跳转到章节">5.5 清理：终结处理和垃圾回收</a><ul>
<li><a id="index_5-5-1" href="#第5章-5-1-finalize-的用途何在" aria-label="跳转到章节" title="跳转到章节">5.5.1 finalize()的用途何在</a></li>
<li><a id="index_5-5-2" href="#第5章-5-2-你必须实施清理" aria-label="跳转到章节" title="跳转到章节">5.5.2 你必须实施清理</a></li>
<li><a id="index_5-5-3" href="#第5章-5-3-终结条件" aria-label="跳转到章节" title="跳转到章节">5.5.3 终结条件</a></li>
<li><a id="index_5-5-4" href="#第5章-5-4-垃圾回收器如何工作" aria-label="跳转到章节" title="跳转到章节">5.5.4 垃圾回收器如何工作</a></li>
</ul>
</li>
<li><a id="index_5-6" href="#第5章-6-成员初始化" aria-label="跳转到章节" title="跳转到章节">5.6 成员初始化</a><ul>
<li><a id="index_5-6-1" href="#第5章-6-1-指定初始化" aria-label="跳转到章节" title="跳转到章节">5.6.1 指定初始化</a></li>
</ul>
</li>
<li><a id="index_5-7" href="#第5章-7-构造器初始化" aria-label="跳转到章节" title="跳转到章节">5.7 构造器初始化</a><ul>
<li><a id="index_5-7-1" href="#第5章-7-1-初始化顺序" aria-label="跳转到章节" title="跳转到章节">5.7.1 初始化顺序</a></li>
<li><a id="index_5-7-2" href="#第5章-7-2-静态数据的初始化" aria-label="跳转到章节" title="跳转到章节">5.7.2 静态数据的初始化</a></li>
<li><a id="index_5-7-3" href="#第5章-7-3-显式的静态初始化" aria-label="跳转到章节" title="跳转到章节">5.7.3 显式的静态初始化</a></li>
<li><a id="index_5-7-4" href="#第5章-7-4-非静态实例初始化" aria-label="跳转到章节" title="跳转到章节">5.7.4 非静态实例初始化</a></li>
</ul>
</li>
<li><a id="index_5-8" href="#第5章-8-数组初始化" aria-label="跳转到章节" title="跳转到章节">5.8 数组初始化</a><ul>
<li><a id="index_5-8-1" href="#第5章-8-1-可变参数列表" aria-label="跳转到章节" title="跳转到章节">5.8.1 可变参数列表</a></li>
</ul>
</li>
<li><a id="index_5-9" href="#第5章-9-枚举类型" aria-label="跳转到章节" title="跳转到章节">5.9 枚举类型</a><ul>
<li><a id="index_5-9-1" href="#第5章-9-1-枚举类（enum）——基本概念" aria-label="跳转到章节" title="跳转到章节">5.9.1 枚举类（enum）——基本概念</a></li>
<li><a id="index_5-9-2" href="#第5章-9-2-枚举类的使用" aria-label="跳转到章节" title="跳转到章节">5.9.2 枚举类的使用</a></li>
</ul>
</li>
<li><a id="index_5-10" href="#第5章-10-总结" aria-label="跳转到章节" title="跳转到章节">5.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_6" href="#第6章-访问权限控制" aria-label="跳转到章节" title="跳转到章节">第6章 访问权限控制</a></p>
<ul>
<li><a id="index_6-1" href="#第6章-1-包：库单元" aria-label="跳转到章节" title="跳转到章节">6.1 包：库单元</a><ul>
<li><a id="index_6-1-1" href="#第6章-1-1-代码组织" aria-label="跳转到章节" title="跳转到章节">6.1.1 代码组织</a></li>
<li><a id="index_6-1-2" href="#第6章-1-2-创建独一无二的包名" aria-label="跳转到章节" title="跳转到章节">6.1.2 创建独一无二的包名</a></li>
<li><a id="index_6-1-3" href="#第6章-1-3-定制工具库" aria-label="跳转到章节" title="跳转到章节">6.1.3 定制工具库</a></li>
<li><a id="index_6-1-4" href="#第6章-1-4-用import改变行为" aria-label="跳转到章节" title="跳转到章节">6.1.4 用import改变行为</a></li>
<li><a id="index_6-1-5" href="#第6章-1-5-对使用包的忠告" aria-label="跳转到章节" title="跳转到章节">6.1.5 对使用包的忠告</a></li>
</ul>
</li>
<li><a id="index_6-2" href="#第6章-2-Java访问权限修饰词" aria-label="跳转到章节" title="跳转到章节">6.2 Java访问权限修饰词</a></li>
<li><a id="index_6-3" href="#第6章-3-接口和实现" aria-label="跳转到章节" title="跳转到章节">6.3 接口和实现</a></li>
<li><a id="index_6-4" href="#第6章-4-类的访问权限" aria-label="跳转到章节" title="跳转到章节">6.4 类的访问权限</a></li>
<li><a id="index_6-5" href="#第6章-5-总结" aria-label="跳转到章节" title="跳转到章节">6.5 总结</a></li>
</ul>
</li>
<li><p><a id="index_7" href="#第7章-复用类" aria-label="跳转到章节" title="跳转到章节">第7章 复用类</a></p>
<ul>
<li><a id="index_7-1" href="#第7章-1-组合语法" aria-label="跳转到章节" title="跳转到章节">7.1 组合语法</a></li>
<li><a id="index_7-2" href="#第7章-2-继承语法" aria-label="跳转到章节" title="跳转到章节">7.2 继承语法</a><ul>
<li><a id="index_7-2-1" href="#第7章-2-1-初始化基类" aria-label="跳转到章节" title="跳转到章节">7.2.1 初始化基类</a></li>
<li><a id="index_7-2-2" href="#第7章-2-2-重写" aria-label="跳转到章节" title="跳转到章节">【拓展】7.2.2 重写</a></li>
</ul>
</li>
<li><a id="index_7-3" href="#第7章-3-代理" aria-label="跳转到章节" title="跳转到章节">7.3 代理</a></li>
<li><a id="index_7-4" href="#第7章-4-结合使用组合和继承" aria-label="跳转到章节" title="跳转到章节">7.4 结合使用组合和继承</a><ul>
<li><a id="index_7-4-1" href="#第7章-4-1-确保正确清理" aria-label="跳转到章节" title="跳转到章节">7.4.1 确保正确清理</a></li>
<li><a id="index_7-4-2" href="#第7章-4-2-名称屏蔽" aria-label="跳转到章节" title="跳转到章节">7.4.2 名称屏蔽</a></li>
</ul>
</li>
<li><a id="index_7-5" href="#第7章-5-在组合与继承之间选择" aria-label="跳转到章节" title="跳转到章节">7.5 在组合与继承之间选择</a></li>
<li><a id="index_7-6" href="#第7章-6-protected关键字" aria-label="跳转到章节" title="跳转到章节">7.6 protected关键字</a></li>
<li><a id="index_7-7" href="#第7章-7-向上转型" aria-label="跳转到章节" title="跳转到章节">7.7 向上转型</a><ul>
<li><a id="index_7-7-1" href="#第7章-7-1-为什么称为向上转型" aria-label="跳转到章节" title="跳转到章节">7.7.1 为什么称为向上转型</a></li>
<li><a id="index_7-7-2" href="#第7章-7-2-再论组合与继承" aria-label="跳转到章节" title="跳转到章节">7.7.2 再论组合与继承</a></li>
</ul>
</li>
<li><a id="index_7-8" href="#第7章-8-final关键字" aria-label="跳转到章节" title="跳转到章节">7.8 final关键字</a><ul>
<li><a id="index_7-8-1" href="#第7章-8-1-final数据" aria-label="跳转到章节" title="跳转到章节">7.8.1 final数据</a></li>
<li><a id="index_7-8-2" href="#第7章-8-2-final方法" aria-label="跳转到章节" title="跳转到章节">7.8.2 final方法</a></li>
<li><a id="index_7-8-3" href="#第7章-8-3-final类" aria-label="跳转到章节" title="跳转到章节">7.8.3 final类</a></li>
<li><a id="index_7-8-4" href="#第7章-8-4-有关final的忠告" aria-label="跳转到章节" title="跳转到章节">7.8.4 有关final的忠告</a></li>
</ul>
</li>
<li><a id="index_7-9" href="#第7章-9-初始化类及类的加载" aria-label="跳转到章节" title="跳转到章节">7.9 初始化类及类的加载</a><ul>
<li><a id="index_7-9-1" href="#第7章-9-1-继承与初始化" aria-label="跳转到章节" title="跳转到章节">7.9.1 继承与初始化</a></li>
</ul>
</li>
<li><a id="index_7-10" href="#第7章-10-总结" aria-label="跳转到章节" title="跳转到章节">7.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_8" href="#第8章-多态" aria-label="跳转到章节" title="跳转到章节">第8章 多态</a></p>
<ul>
<li><a id="index_8-1" href="#第8章-1-再论向上转型" aria-label="跳转到章节" title="跳转到章节">8.1 再论向上转型</a><ul>
<li><a id="index_8-1-1" href="#第8章-1-1-忘记对象类型" aria-label="跳转到章节" title="跳转到章节">8.1.1 忘记对象类型</a></li>
</ul>
</li>
<li><a id="index_8-2" href="#第8章-2-转机" aria-label="跳转到章节" title="跳转到章节">8.2 转机</a><ul>
<li><a id="index_8-2-1" href="#第8章-2-1-方法调用绑定" aria-label="跳转到章节" title="跳转到章节">8.2.1 方法调用绑定</a></li>
<li><a id="index_8-2-2" href="#第8章-2-2-产生正确的行为" aria-label="跳转到章节" title="跳转到章节">8.2.2 产生正确的行为</a></li>
<li><a id="index_8-2-3" href="#第8章-2-3-可拓展性" aria-label="跳转到章节" title="跳转到章节">8.2.3 可拓展性</a></li>
<li><a id="index_8-2-4" href="#第8章-2-4-缺陷：“覆盖”私有方法" aria-label="跳转到章节" title="跳转到章节">8.2.4 缺陷：“覆盖”私有方法</a></li>
<li><a id="index_8-2-5" href="#第8章-2-5-缺陷：域与静态方法" aria-label="跳转到章节" title="跳转到章节">8.2.5 缺陷：域与静态方法</a></li>
</ul>
</li>
<li><a id="index_8-3" href="#第8章-3-构造器和多态" aria-label="跳转到章节" title="跳转到章节">8.3 构造器和多态</a><ul>
<li><a id="index_8-3-1" href="#第8章-3-1-构造器的调用顺序" aria-label="跳转到章节" title="跳转到章节">8.3.1 构造器的调用顺序</a></li>
<li><a id="index_8-3-2" href="#第8章-3-2-继承与清理" aria-label="跳转到章节" title="跳转到章节">8.3.2 继承与清理</a></li>
<li><a id="index_8-3-3" href="#第8章-3-3-构造器内部的多态方法的行为" aria-label="跳转到章节" title="跳转到章节">8.3.3 构造器内部的多态方法的行为</a></li>
</ul>
</li>
<li><a id="index_8-4" href="#第8章-4-协变返回类型" aria-label="跳转到章节" title="跳转到章节">8.4 协变返回类型</a></li>
<li><a id="index_8-5" href="#第8章-5-用继承进行设计" aria-label="跳转到章节" title="跳转到章节">8.5 用继承进行设计</a><ul>
<li><a id="index_8-5-1" href="#第8章-5-1-纯继承与拓展" aria-label="跳转到章节" title="跳转到章节">8.5.1 纯继承与拓展</a></li>
<li><a id="index_8-5-2" href="#第8章-5-2-向下转型与运行时类型识别" aria-label="跳转到章节" title="跳转到章节">8.5.2 向下转型与运行时类型识别</a></li>
</ul>
</li>
<li><a id="index_8-6" href="#第8章-6-总结" aria-label="跳转到章节" title="跳转到章节">8.6 总结</a></li>
</ul>
</li>
<li><p><a id="index_9" href="#第9章-接口" aria-label="跳转到章节" title="跳转到章节">第9章 接口</a></p>
<ul>
<li><a id="index_9-1" href="#第9章-1-抽象类和抽象方法" aria-label="跳转到章节" title="跳转到章节">9.1 抽象类和抽象方法</a></li>
<li><a id="index_9-2" href="#第9章-2-接口" aria-label="跳转到章节" title="跳转到章节">9.2 接口</a></li>
<li><a id="index_9-3" href="#第9章-3-完全解耦" aria-label="跳转到章节" title="跳转到章节">9.3 完全解耦</a></li>
<li><a id="index_9-4" href="#第9章-4-Java中的多重继承" aria-label="跳转到章节" title="跳转到章节">9.4 Java中的多重继承</a></li>
<li><a id="index_9-5" href="#第9章-5-通过继承来拓展接口" aria-label="跳转到章节" title="跳转到章节">9.5 通过继承来拓展接口</a></li>
<li><a id="index_9-6" href="#第9章-6-适配接口" aria-label="跳转到章节" title="跳转到章节">9.6 适配接口</a></li>
<li><a id="index_9-7" href="#第9章-7-接口中的域" aria-label="跳转到章节" title="跳转到章节">9.7 接口中的域</a></li>
<li><a id="index_9-8" href="#第9章-8-嵌套接口" aria-label="跳转到章节" title="跳转到章节">9.8 嵌套接口</a></li>
<li><a id="index_9-9" href="#第9章-9-接口与工厂" aria-label="跳转到章节" title="跳转到章节">9.9 接口与工厂</a></li>
<li><a id="index_9-10" href="#第9章-10-总结" aria-label="跳转到章节" title="跳转到章节">9.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_10" href="#第10章-内部类" aria-label="跳转到章节" title="跳转到章节">第10章 内部类</a></p>
<ul>
<li><a id="index_10-1" href="#第10章-1-创建内部类" aria-label="跳转到章节" title="跳转到章节">10.1 创建内部类</a></li>
<li><a id="index_10-2" href="#第10章-2-链接到外部类" aria-label="跳转到章节" title="跳转到章节">10.2 链接到外部类</a></li>
<li><a id="index_10-3" href="#第10章-3-使用.this与.new" aria-label="跳转到章节" title="跳转到章节">10.3 使用.this与.new</a></li>
<li><a id="index_10-4" href="#第10章-4-内部类与向上转型" aria-label="跳转到章节" title="跳转到章节">10.4 内部类与向上转型</a></li>
<li><a id="index_10-5" href="#第10章-5-在方法和作用域内的内部类" aria-label="跳转到章节" title="跳转到章节">10.5 在方法和作用域内的内部类</a></li>
<li><a id="index_10-6" href="#第10章-6-匿名内部类" aria-label="跳转到章节" title="跳转到章节">10.6 匿名内部类</a></li>
<li><a id="index_10-7" href="#第10章-7-嵌套类" aria-label="跳转到章节" title="跳转到章节">10.7 嵌套类</a></li>
<li><a id="index_10-8" href="#第10章-8-为什么需要内部类" aria-label="跳转到章节" title="跳转到章节">10.8 为什么需要内部类</a></li>
<li><a id="index_10-9" href="#第10章-9-内部类的继承" aria-label="跳转到章节" title="跳转到章节">10.9 内部类的继承</a></li>
<li><a id="index_10-10" href="#第10章-10-内部类可以被覆盖吗" aria-label="跳转到章节" title="跳转到章节">10.10 内部类可以被覆盖吗</a></li>
<li><a id="index_10-11" href="#第10章-11-局部内部类" aria-label="跳转到章节" title="跳转到章节">10.11 局部内部类</a></li>
<li><a id="index_10-12" href="#第10章-12-内部类标识符" aria-label="跳转到章节" title="跳转到章节">10.12 内部类标识符</a></li>
<li><a id="index_10-13" href="#第10章-13-总结" aria-label="跳转到章节" title="跳转到章节">10.13 总结</a></li>
</ul>
</li>
<li><p><a id="index_11" href="#第11章-持有对象" aria-label="跳转到章节" title="跳转到章节">第11章 持有对象</a></p>
<ul>
<li><a id="index_11-1" href="#第11章-1-泛型和类型安全的容器" aria-label="跳转到章节" title="跳转到章节">11.1 泛型和类型安全的容器</a></li>
<li><a id="index_11-2" href="#第11章-2-基本概念" aria-label="跳转到章节" title="跳转到章节">11.2 基本概念</a></li>
<li><a id="index_11-3" href="#第11章-3-添加一组元素" aria-label="跳转到章节" title="跳转到章节">11.3 添加一组元素</a></li>
<li><a id="index_11-4" href="#第11章-4-容器的打印" aria-label="跳转到章节" title="跳转到章节">11.4 容器的打印</a></li>
<li><a id="index_11-5" href="#第11章-5-List（原理-amp-简介）" aria-label="跳转到章节" title="跳转到章节">11.5 List（原理 &amp; 简介）</a></li>
<li><a id="index_11-6" href="#第11章-6-迭代器" aria-label="跳转到章节" title="跳转到章节">11.6 迭代器</a></li>
<li><a id="index_11-7" href="#第11章-7-LinkedList" aria-label="跳转到章节" title="跳转到章节">11.7 LinkedList</a></li>
<li><a id="index_11-8" href="#第11章-8-Stack" aria-label="跳转到章节" title="跳转到章节">11.8 Stack</a></li>
<li><a id="index_11-9" href="#第11章-9-Set" aria-label="跳转到章节" title="跳转到章节">11.9 Set</a></li>
<li><a id="index_11-10" href="#第11章-10-Map" aria-label="跳转到章节" title="跳转到章节">11.10 Map</a></li>
<li><a id="index_11-11" href="#第11章-11-Queue" aria-label="跳转到章节" title="跳转到章节">11.11 Queue</a></li>
<li><a id="index_11-12" href="#第11章-12-Collection和Iterator" aria-label="跳转到章节" title="跳转到章节">11.12 Collection和Iterator</a></li>
<li><a id="index_11-13" href="#第11章-13-Foreach与迭代器" aria-label="跳转到章节" title="跳转到章节">11.13 Foreach与迭代器</a><ul>
<li><a id="index_11-13-1" href="#第11章-13-1-适配器方法惯用法→示例源码说明" aria-label="跳转到章节" title="跳转到章节">11.13.1 适配器方法惯用法→示例源码说明</a></li>
</ul>
</li>
<li><a id="index_11-14" href="#第11章-14-总结" aria-label="跳转到章节" title="跳转到章节">11.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_12" href="#第12章-通过异常处理错误" aria-label="跳转到章节" title="跳转到章节">第12章 通过异常处理错误</a></p>
<ul>
<li><a id="index_12-1" href="#第12章-1-概念" aria-label="跳转到章节" title="跳转到章节">12.1 概念</a></li>
<li><a id="index_12-2" href="#第12章-2-基本异常" aria-label="跳转到章节" title="跳转到章节">12.2 基本异常</a><ul>
<li><a id="index_12-2-1" href="#第12章-2-1-捕获异常参数" aria-label="跳转到章节" title="跳转到章节">12.2.1 捕获异常参数</a></li>
</ul>
</li>
<li><a id="index_12-3" href="#第12章-3-捕获异常" aria-label="跳转到章节" title="跳转到章节">12.3 捕获异常</a><ul>
<li><a id="index_12-3-1" href="#第12章-3-1-try块" aria-label="跳转到章节" title="跳转到章节">12.3.1 try块</a></li>
<li><a id="index_12-3-2" href="#第12章-3-2-异常处理程序" aria-label="跳转到章节" title="跳转到章节">12.3.2 异常处理程序</a></li>
</ul>
</li>
<li><a id="index_12-4" href="#第12章-4-创建自定义异常" aria-label="跳转到章节" title="跳转到章节">12.4 创建自定义异常</a><ul>
<li><a id="index_12-4-1" href="#第12章-4-1-异常与记录日志" aria-label="跳转到章节" title="跳转到章节">12.4.1 异常与记录日志</a></li>
</ul>
</li>
<li><a id="index_12-5" href="#第12章-5-异常说明" aria-label="跳转到章节" title="跳转到章节">12.5 异常说明</a></li>
<li><a id="index_12-6" href="#第12章-6-捕获所有异常" aria-label="跳转到章节" title="跳转到章节">12.6 捕获所有异常</a><ul>
<li><a id="index_12-6-1" href="#第12章-6-1-栈轨迹" aria-label="跳转到章节" title="跳转到章节">12.6.1 栈轨迹</a></li>
<li><a id="index_12-6-2" href="#第12章-6-2-重新抛出异常" aria-label="跳转到章节" title="跳转到章节">12.6.2 重新抛出异常</a></li>
<li><a id="index_12-6-3" href="#第12章-6-3-异常链" aria-label="跳转到章节" title="跳转到章节">12.6.3 异常链</a></li>
</ul>
</li>
<li><a id="index_12-7" href="#第12章-7-Java标准异常" aria-label="跳转到章节" title="跳转到章节">12.7 Java标准异常</a><ul>
<li><a id="index_12-7-1" href="#第12章-7-1-特例：RuntimeException" aria-label="跳转到章节" title="跳转到章节">12.7.1 特例：RuntimeException</a></li>
</ul>
</li>
<li><a id="index_12-8" href="#第12章-8-使用finally进行清理" aria-label="跳转到章节" title="跳转到章节">12.8 使用finally进行清理</a><ul>
<li><a id="index_12-8-1" href="#第12章-8-1-finally用来做什么" aria-label="跳转到章节" title="跳转到章节">12.8.1 finally用来做什么</a></li>
<li><a id="index_12-8-2" href="#第12章-8-2-在return中使用finally" aria-label="跳转到章节" title="跳转到章节">12.8.2 在return中使用finally</a></li>
<li><a id="index_12-8-3" href="#第12章-8-3-缺憾：异常缺失" aria-label="跳转到章节" title="跳转到章节">12.8.3 缺憾：异常缺失</a></li>
</ul>
</li>
<li><a id="index_12-9" href="#第12章-9-异常的限制" aria-label="跳转到章节" title="跳转到章节">12.9 异常的限制</a></li>
<li><a id="index_12-10" href="#第12章-10-构造器" aria-label="跳转到章节" title="跳转到章节">12.10 构造器</a></li>
<li><a id="index_12-11" href="#第12章-11-异常匹配" aria-label="跳转到章节" title="跳转到章节">12.11 异常匹配</a></li>
<li><a id="index_12-12" href="#第12章-12-其他可选方式" aria-label="跳转到章节" title="跳转到章节">12.12 其他可选方式</a><ul>
<li><a id="index_12-12-1" href="#第12章-12-1-历史" aria-label="跳转到章节" title="跳转到章节">12.12.1 历史</a></li>
<li><a id="index_12-12-2" href="#第12章-12-2-观点" aria-label="跳转到章节" title="跳转到章节">12.12.2 观点</a></li>
<li><a id="index_12-12-3" href="#第12章-12-3-把异常传递给控制台" aria-label="跳转到章节" title="跳转到章节">12.12.3 把异常传递给控制台</a></li>
<li><a id="index_12-12-4" href="#第12章-12-4-把“被检查的异常”转换为“不检查的异常”" aria-label="跳转到章节" title="跳转到章节">12.12.4 把“被检查的异常”转换为“不检查的异常”</a></li>
</ul>
</li>
<li><a id="index_12-13" href="#第12章-13-异常使用指南" aria-label="跳转到章节" title="跳转到章节">12.13 异常使用指南</a></li>
<li><a id="index_12-14" href="#第12章-14-总结" aria-label="跳转到章节" title="跳转到章节">12.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_13" href="#第13章-字符串" aria-label="跳转到章节" title="跳转到章节">第13章 字符串</a></p>
<ul>
<li><a id="index_13-1" href="#第13章-1-不可变String" aria-label="跳转到章节" title="跳转到章节">13.1 不可变String</a></li>
<li><a id="index_13-2" href="#第13章-2-重载“-”与StringBuilder" aria-label="跳转到章节" title="跳转到章节">13.2 重载“+”与StringBuilder</a></li>
<li><a id="index_13-3" href="#第13章-3-无意识的递归" aria-label="跳转到章节" title="跳转到章节">13.3 无意识的递归</a></li>
<li><a id="index_13-4" href="#第13章-4-String上的操作" aria-label="跳转到章节" title="跳转到章节">13.4 String上的操作</a></li>
<li><a id="index_13-5" href="#第13章-5-格式化输出" aria-label="跳转到章节" title="跳转到章节">13.5 格式化输出</a><ul>
<li><a id="index_13-5-4" href="#第13章-5-4 格式化说明符" aria-label="跳转到章节" title="跳转到章节">13.5.4 格式化说明符</a></li>
</ul>
</li>
<li><a id="index_13-6" href="#第13章-6-正则表达式" aria-label="跳转到章节" title="跳转到章节">13.6 正则表达式</a></li>
<li><a id="index_13-7" href="#第13章-7-扫描输入" aria-label="跳转到章节" title="跳转到章节">13.7 扫描输入</a></li>
<li><a id="index_13-8" href="#第13章-8-StringTokenizer（已废弃）" aria-label="跳转到章节" title="跳转到章节">13.8 StringTokenizer（已废弃）</a></li>
<li><a id="index_13-9" href="#第13章-9-总结" aria-label="跳转到章节" title="跳转到章节">13.9 总结</a></li>
</ul>
</li>
<li><p><a id="index_14" href="#第14章-类型信息（RTTI）" aria-label="跳转到章节" title="跳转到章节">第14章 类型信息（RTTI）</a></p>
<ul>
<li><a id="index_14-1" href="#第14章-1-为什么需要RTTI" aria-label="跳转到章节" title="跳转到章节">14.1 为什么需要RTTI</a></li>
<li><a id="index_14-2" href="#第14章-2-Class对象" aria-label="跳转到章节" title="跳转到章节">14.2 Class对象</a><ul>
<li><a id="index_14-2-1" href="#第14章-2-1-类字面量" aria-label="跳转到章节" title="跳转到章节">14.2.1 类字面量</a></li>
<li><a id="index_14-2-2" href="#第14章-2-2-泛化的Class引用" aria-label="跳转到章节" title="跳转到章节">14.2.2 泛化的Class引用</a></li>
<li><a id="index_14-2-3" href="#第14章-2-3-类的转换（原：新的转型语法）" aria-label="跳转到章节" title="跳转到章节">14.2.3 类的转换（原：新的转型语法）</a></li>
</ul>
</li>
<li><a id="index_14-3" href="#第14章-3-类型转换前先做检查" aria-label="跳转到章节" title="跳转到章节">14.3 类型转换前先做检查</a></li>
<li><a id="index_14-4" href="#第14章-4-注册工厂" aria-label="跳转到章节" title="跳转到章节">14.4 注册工厂</a></li>
<li><a id="index_14-5" href="#第14章-5-instanceof与Class的等价性" aria-label="跳转到章节" title="跳转到章节">14.5 instanceof与Class的等价性</a></li>
<li><a id="index_14-6" href="#第14章-6-反射：运行时的类信息" aria-label="跳转到章节" title="跳转到章节">14.6 反射：运行时的类信息</a><ul>
<li><a id="index_14-6-1" href="#第14章-6-1-类方法提取器" aria-label="跳转到章节" title="跳转到章节">14.6.1 类方法提取器</a></li>
</ul>
</li>
<li><a id="index_14-7" href="#第14章-7-动态代理" aria-label="跳转到章节" title="跳转到章节">14.7 动态代理</a></li>
<li><a id="index_14-8" href="#第14章-8-空对象" aria-label="跳转到章节" title="跳转到章节">14.8 空对象</a><ul>
<li><a id="index_14-8-1" href="#第14章-8-1-模拟对象与桩" aria-label="跳转到章节" title="跳转到章节">14.8.1 模拟对象与桩</a></li>
</ul>
</li>
<li><a id="index_14-9" href="#第14章-9-接口与类型信息" aria-label="跳转到章节" title="跳转到章节">14.9 接口与类型信息</a></li>
<li><a id="index_14-10" href="#第14章-10-总结" aria-label="跳转到章节" title="跳转到章节">14.10 总结</a></li>
</ul>
</li>
<li><p><a id="index_15" href="#第15章-泛型" aria-label="跳转到章节" title="跳转到章节">第15章 泛型</a></p>
<ul>
<li><a id="index_15-1" href="#第15章-1-与C-比较" aria-label="跳转到章节" title="跳转到章节">15.1 与C++比较</a></li>
<li><a id="index_15-2" href="#第15章-2-简单泛型" aria-label="跳转到章节" title="跳转到章节">15.2 简单泛型</a><ul>
<li><a id="index_15-2-1" href="#第15章-2-1-一个元祖类库" aria-label="跳转到章节" title="跳转到章节">15.2.1 一个元祖类库</a></li>
<li><a id="index_15-2-2" href="#第15章-2-2-一个堆栈类" aria-label="跳转到章节" title="跳转到章节">15.2.2 一个堆栈类</a></li>
<li><a id="index_15-2-3" href="#第15章-2-3-RandomList" aria-label="跳转到章节" title="跳转到章节">15.2.3 RandomList</a></li>
</ul>
</li>
<li><a id="index_15-3" href="#第15章-3-泛型接口" aria-label="跳转到章节" title="跳转到章节">15.3 泛型接口</a></li>
<li><a id="index_15-4" href="#第15章-4-泛型方法" aria-label="跳转到章节" title="跳转到章节">15.4 泛型方法</a><ul>
<li><a id="index_15-4-1" href="#第15章-4-1-杠杆利用类型参数判断" aria-label="跳转到章节" title="跳转到章节">15.4.1 杠杆利用类型参数判断</a></li>
<li><a id="index_15-4-2" href="#第15章-4-2-可变参数与泛型方法" aria-label="跳转到章节" title="跳转到章节">15.4.2 可变参数与泛型方法</a></li>
<li><a id="index_15-4-3" href="#第15章-4-3-用于Generator的泛型方法" aria-label="跳转到章节" title="跳转到章节">15.4.3 用于Generator的泛型方法</a></li>
<li><a id="index_15-4-4" href="#第15章-4-4-一个通用的Generator" aria-label="跳转到章节" title="跳转到章节">15.4.4 一个通用的Generator</a></li>
<li><a id="index_15-4-5" href="#第15章-4-5-简化元祖的使用" aria-label="跳转到章节" title="跳转到章节">15.4.5 简化元祖的使用</a></li>
<li><a id="index_15-4-6" href="#第15章-4-6-一个Set实用工具" aria-label="跳转到章节" title="跳转到章节">15.4.6 一个Set实用工具</a></li>
</ul>
</li>
<li><a id="index_15-5" href="#第15章-5-匿名内部类" aria-label="跳转到章节" title="跳转到章节">15.5 匿名内部类</a></li>
<li><a id="index_15-6" href="#第15章-6-构建复杂模型" aria-label="跳转到章节" title="跳转到章节">15.6 构建复杂模型</a></li>
<li><a id="index_15-7" href="#第15章-7-擦除的神秘之处" aria-label="跳转到章节" title="跳转到章节">15.7 擦除的神秘之处</a><ul>
<li><a id="index_15-7-1" href="#第15章-7-1-C-的方式" aria-label="跳转到章节" title="跳转到章节">15.7.1 C++的方式</a></li>
<li><a id="index_15-7-2" href="#第15章-7-2-迁移兼容性" aria-label="跳转到章节" title="跳转到章节">15.7.2 迁移兼容性</a></li>
<li><a id="index_15-7-3" href="#第15章-7-3-擦除的问题" aria-label="跳转到章节" title="跳转到章节">15.7.3 擦除的问题</a></li>
<li><a id="index_15-7-4" href="#第15章-7-4-边界处的动作" aria-label="跳转到章节" title="跳转到章节">15.7.4 边界处的动作</a></li>
</ul>
</li>
<li><a id="index_15-8" href="#第15章-8-擦除的补偿" aria-label="跳转到章节" title="跳转到章节">15.8 擦除的补偿</a><ul>
<li><a id="index_15-8-1" href="#第15章-8-1-创建类型实例" aria-label="跳转到章节" title="跳转到章节">15.8.1 创建类型实例</a></li>
<li><a id="index_15-8-2" href="#第15章-8-2-泛型数组" aria-label="跳转到章节" title="跳转到章节">15.8.2 泛型数组</a></li>
</ul>
</li>
<li><a id="index_15-9" href="#第15章-9-边界" aria-label="跳转到章节" title="跳转到章节">15.9 边界</a></li>
<li><a id="index_15-10" href="#第15章-10-通配符" aria-label="跳转到章节" title="跳转到章节">15.10 通配符</a><ul>
<li><a id="index_15-10-1" href="#第15章-10-1-编译器有多聪明" aria-label="跳转到章节" title="跳转到章节">15.10.1 编译器有多聪明</a></li>
<li><a id="index_15-10-2" href="#第15章-10-2-逆变" aria-label="跳转到章节" title="跳转到章节">15.10.2 逆变</a></li>
<li><a id="index_15-10-3" href="#第15章-10-3-无界通配符" aria-label="跳转到章节" title="跳转到章节">15.10.3 无界通配符</a></li>
<li><a id="index_15-10-4" href="#第15章-10-4-捕获转换（通配符捕获）" aria-label="跳转到章节" title="跳转到章节">15.10.4 捕获转换（通配符捕获）</a></li>
</ul>
</li>
<li><a id="index_15-11" href="#第15章-11-问题" aria-label="跳转到章节" title="跳转到章节">15.11 问题</a><ul>
<li><a id="index_15-11-1" href="#第15章-11-1-任何基本类型都不能作为类型" aria-label="跳转到章节" title="跳转到章节">15.11.1 任何基本类型都不能作为类型</a></li>
<li><a id="index_15-11-2" href="#第15章-11-2-实现参数化接口" aria-label="跳转到章节" title="跳转到章节">15.11.2 实现参数化接口</a></li>
<li><a id="index_15-11-3" href="#第15章-11-3-转型和警告" aria-label="跳转到章节" title="跳转到章节">15.11.3 转型和警告</a></li>
<li><a id="index_15-11-4" href="#第15章-11-4-重载" aria-label="跳转到章节" title="跳转到章节">15.11.4 重载</a></li>
<li><a id="index_15-11-5" href="#第15章-11-5-基类劫持了接口" aria-label="跳转到章节" title="跳转到章节">15.11.5 基类劫持了接口</a></li>
</ul>
</li>
<li><a id="index_15-12" href="#第15章-12-自限定的类型" aria-label="跳转到章节" title="跳转到章节">15.12 自限定的类型</a><ul>
<li><a id="index_15-12-1" href="#第15章-12-1-古怪的循环泛型" aria-label="跳转到章节" title="跳转到章节">15.12.1 古怪的循环泛型</a></li>
<li><a id="index_15-12-2" href="#第15章-12-2-自限定" aria-label="跳转到章节" title="跳转到章节">15.12.2 自限定</a></li>
<li><a id="index_15-12-3" href="#第15章-12-3-参数协变" aria-label="跳转到章节" title="跳转到章节">15.12.3 参数协变</a></li>
</ul>
</li>
<li><a id="index_15-13" href="#第15章-13-动态类型安全" aria-label="跳转到章节" title="跳转到章节">15.13 动态类型安全</a></li>
<li><a id="index_15-14" href="#第15章-14-异常" aria-label="跳转到章节" title="跳转到章节">15.14 异常</a></li>
<li><a id="index_15-15" href="#第15章-15-混型" aria-label="跳转到章节" title="跳转到章节">15.15 混型</a><ul>
<li><a id="index_15-15-1" href="#第15章-15-1-C-中的混型" aria-label="跳转到章节" title="跳转到章节">15.15.1 C++中的混型</a></li>
<li><a id="index_15-15-2" href="#第15章-15-2-与接口混合" aria-label="跳转到章节" title="跳转到章节">15.15.2 与接口混合</a></li>
<li><a id="index_15-15-3" href="#第15章-15-3-使用装饰器模式" aria-label="跳转到章节" title="跳转到章节">15.15.3 使用装饰器模式</a></li>
<li><a id="index_15-15-4" href="#第15章-15-4-与动态代理混合" aria-label="跳转到章节" title="跳转到章节">15.15.4 与动态代理混合</a></li>
</ul>
</li>
<li><a id="index_15-16" href="#第15章-16-潜在类型机制" aria-label="跳转到章节" title="跳转到章节">15.16 潜在类型机制</a></li>
<li><a id="index_15-17" href="#第15章-17-对缺乏潜在类型机制的补偿" aria-label="跳转到章节" title="跳转到章节">15.17 对缺乏潜在类型机制的补偿</a><ul>
<li><a id="index_15-17-1" href="#第15章-17-1-反射" aria-label="跳转到章节" title="跳转到章节">15.17.1 反射</a></li>
<li><a id="index_15-17-2" href="#第15章-17-2-将一个方法应用于序列" aria-label="跳转到章节" title="跳转到章节">15.17.2 将一个方法应用于序列</a></li>
<li><a id="index_15-17-3" href="#第15章-17-3-当你并为碰巧拥有正确的接口时" aria-label="跳转到章节" title="跳转到章节">15.17.3 当你并为碰巧拥有正确的接口时</a></li>
<li><a id="index_15-17-4" href="#第15章-17-4-用适配器仿真潜在类型机制" aria-label="跳转到章节" title="跳转到章节">15.17.4 用适配器仿真潜在类型机制</a></li>
</ul>
</li>
<li><a id="index_15-18" href="#第15章-18-将函数对象用作策略" aria-label="跳转到章节" title="跳转到章节">15.18 将函数对象用作策略</a></li>
<li><a id="index_15-19" href="#第15章-19-总结：转型真的如此之糟吗？" aria-label="跳转到章节" title="跳转到章节">15.19 总结：转型真的如此之糟吗？</a><ul>
<li><a id="index_15-19-1" href="#第15章-19-1-进阶读物" aria-label="跳转到章节" title="跳转到章节">15.19.1 进阶读物</a></li>
</ul>
</li>
</ul>
</li>
<li><p><a id="index_16" href="#第16章-数组" aria-label="跳转到章节" title="跳转到章节">第16章 数组</a></p>
<ul>
<li><a id="index_16-1" href="#第16章-1-数组为什么特殊" aria-label="跳转到章节" title="跳转到章节">16.1 数组为什么特殊</a></li>
<li><a id="index_16-2" href="#第16章-2-数组是第一级对象" aria-label="跳转到章节" title="跳转到章节">16.2 数组是第一级对象</a></li>
<li><a id="index_16-3" href="#第16章-3-返回一个数组" aria-label="跳转到章节" title="跳转到章节">16.3 返回一个数组</a></li>
<li><a id="index_16-4" href="#第16章-4-多维数组" aria-label="跳转到章节" title="跳转到章节">16.4 多维数组</a></li>
<li><a id="index_16-5" href="#第16章-5-数组与泛型" aria-label="跳转到章节" title="跳转到章节">16.5 数组与泛型</a></li>
<li><a id="index_16-6" href="#第16章-6-创建测试数据" aria-label="跳转到章节" title="跳转到章节">16.6 创建测试数据</a><ul>
<li><a id="index_16-6-1" href="#第16章-6-1-Arrays-fill" aria-label="跳转到章节" title="跳转到章节">16.6.1 Arrays.fill()</a></li>
<li><a id="index_16-6-2" href="#第16章-6-2-数据生成器" aria-label="跳转到章节" title="跳转到章节">16.6.2 数据生成器</a></li>
<li><a id="index_16-6-3" href="#第16章-6-3-从Generator中创建数组" aria-label="跳转到章节" title="跳转到章节">16.6.3 从Generator中创建数组</a></li>
</ul>
</li>
<li><a id="index_16-7" href="#第16章-7-Arrays实用功能" aria-label="跳转到章节" title="跳转到章节">16.7 Arrays实用功能</a><ul>
<li><a id="index_16-7-1" href="#第16章-7-1-复制数组" aria-label="跳转到章节" title="跳转到章节">16.7.1 复制数组</a></li>
<li><a id="index_16-7-2" href="#第16章-7-2-数组的比较" aria-label="跳转到章节" title="跳转到章节">16.7.2 数组的比较</a></li>
<li><a id="index_16-7-3" href="#第16章-7-3-数组元素的比较" aria-label="跳转到章节" title="跳转到章节">16.7.3 数组元素的比较</a></li>
<li><a id="index_16-7-4" href="#第16章-7-4-数组排序" aria-label="跳转到章节" title="跳转到章节">16.7.4 数组排序</a></li>
<li><a id="index_16-7-5" href="#第16章-7-5-在已排序的数组中查找" aria-label="跳转到章节" title="跳转到章节">16.7.5 在已排序的数组中查找</a></li>
</ul>
</li>
<li><a id="index_16-8" href="#第16章-8-总结" aria-label="跳转到章节" title="跳转到章节">16.8 总结</a></li>
</ul>
</li>
<li><p><a id="index_17" href="#第17章-容器深入研究" aria-label="跳转到章节" title="跳转到章节">第17章 容器深入研究</a></p>
<ul>
<li><a id="index_17-1" href="#第17章-1-完整容器分类法" aria-label="跳转到章节" title="跳转到章节">17.1 完整容器分类法</a></li>
<li><a id="index_17-2" href="#第17章-2-填充容器" aria-label="跳转到章节" title="跳转到章节">17.2 填充容器</a><ul>
<li><a id="index_17-2-1" href="#第17章-2-1-一种Generator解决方案" aria-label="跳转到章节" title="跳转到章节">17.2.1 一种Generator解决方案</a></li>
<li><a id="index_17-2-2" href="#第17章-2-2-Map生成器" aria-label="跳转到章节" title="跳转到章节">17.2.2 Map生成器</a></li>
<li><a id="index_17-2-3" href="#第17章-2-3-使用Abstract类" aria-label="跳转到章节" title="跳转到章节">17.2.3 使用Abstract类</a></li>
</ul>
</li>
<li><a id="index_17-3" href="#第17章-3-Collection的功能方法" aria-label="跳转到章节" title="跳转到章节">17.3 Collection的功能方法</a></li>
<li><a id="index_17-4" href="#第17章-4-可选操作" aria-label="跳转到章节" title="跳转到章节">17.4 可选操作</a><ul>
<li><a id="index_17-4-1" href="#第17章-4-1-未获支持的操作" aria-label="跳转到章节" title="跳转到章节">17.4.1 未获支持的操作</a></li>
</ul>
</li>
<li><a id="index_17-5" href="#第17章-5-List的功能方法" aria-label="跳转到章节" title="跳转到章节">17.5 List的功能方法</a></li>
<li><a id="index_17-6" href="#第17章-6-Set和存储排序" aria-label="跳转到章节" title="跳转到章节">17.6 Set和存储排序</a><ul>
<li><a id="index_17-6-1" href="#第17章-6-1-SortedSet" aria-label="跳转到章节" title="跳转到章节">17.6.1 SortedSet</a></li>
</ul>
</li>
<li><a id="index_17-7" href="#第17章-7-队列" aria-label="跳转到章节" title="跳转到章节">17.7 队列</a><ul>
<li><a id="index_17-7-1" href="#第17章-7-1-优先级队列" aria-label="跳转到章节" title="跳转到章节">17.7.1 优先级队列</a></li>
<li><a id="index_17-7-2" href="#第17章-7-2-双向队列" aria-label="跳转到章节" title="跳转到章节">17.7.2 双向队列</a></li>
</ul>
</li>
<li><a id="index_17-8" href="#第17章-8-理解Map" aria-label="跳转到章节" title="跳转到章节">17.8 理解Map</a><ul>
<li><a id="index_17-8-1" href="#第17章-8-1-性能" aria-label="跳转到章节" title="跳转到章节">17.8.1 性能</a></li>
<li><a id="index_17-8-2" href="#第17章-8-2-SortedMap" aria-label="跳转到章节" title="跳转到章节">17.8.2 SortedMap</a></li>
<li><a id="index_17-8-3" href="#第17章-8-3-LinkedHashMap" aria-label="跳转到章节" title="跳转到章节">17.8.3 LinkedHashMap</a></li>
</ul>
</li>
<li><a id="index_17-9" href="#第17章-9-散列与散列码" aria-label="跳转到章节" title="跳转到章节">17.9 散列与散列码</a><ul>
<li><a id="index_17-9-1" href="#第17章-9-1-理解hashCode" aria-label="跳转到章节" title="跳转到章节">17.9.1 理解hashCode()</a></li>
<li><a id="index_17-9-2" href="#第17章-9-2-为速度而散列" aria-label="跳转到章节" title="跳转到章节">17.9.2 为速度而散列</a></li>
<li><a id="index_17-9-3" href="#第17章-9-3-覆盖hashCode" aria-label="跳转到章节" title="跳转到章节">17.9.3 覆盖hashCode()</a></li>
</ul>
</li>
<li><a id="index_17-10" href="#第17章-10-选择接口的不同实现" aria-label="跳转到章节" title="跳转到章节">17.10 选择接口的不同实现</a><ul>
<li><a id="index_17-10-1" href="#第17章-10-1-性能测试框架" aria-label="跳转到章节" title="跳转到章节">17.10.1 性能测试框架</a></li>
<li><a id="index_17-10-2" href="#第17章-10-2-对List的选择" aria-label="跳转到章节" title="跳转到章节">17.10.2 对List的选择</a></li>
<li><a id="index_17-10-3" href="#第17章-10-3-微基准测试的危险" aria-label="跳转到章节" title="跳转到章节">17.10.3 微基准测试的危险</a></li>
<li><a id="index_17-10-4" href="#第17章-10-4-对Set的选择" aria-label="跳转到章节" title="跳转到章节">17.10.4 对Set的选择</a></li>
<li><a id="index_17-10-5" href="#第17章-10-5-对Map的选择" aria-label="跳转到章节" title="跳转到章节">17.10.5 对Map的选择</a></li>
</ul>
</li>
<li><a id="index_17-11" href="#第17章-11-实用方法" aria-label="跳转到章节" title="跳转到章节">17.11 实用方法</a><ul>
<li><a id="index_17-11-1" href="#第17章-11-1-List的排序和查询" aria-label="跳转到章节" title="跳转到章节">17.11.1 List的排序和查询</a></li>
<li><a id="index_17-11-2" href="#第17章-11-2-设定Collection或Map为不可修改" aria-label="跳转到章节" title="跳转到章节">17.11.2 设定Collection或Map为不可修改</a></li>
<li><a id="index_17-11-3" href="#第17章-11-3-Collection或Map的同步控制" aria-label="跳转到章节" title="跳转到章节">17.11.3 Collection或Map的同步控制</a></li>
</ul>
</li>
<li><a id="index_17-12" href="#第17章-12-持有引用" aria-label="跳转到章节" title="跳转到章节">17.12 持有引用</a><ul>
<li><a id="index_17-12-1" href="#第17章-12-1-WeakHashMap" aria-label="跳转到章节" title="跳转到章节">17.12.1 WeakHashMap</a></li>
</ul>
</li>
<li><a id="index_17-13" href="#第17章-13-Java 1.0-1.1的容器" aria-label="跳转到章节" title="跳转到章节">17.13 Java 1.0-1.1的容器</a><ul>
<li><a id="index_17-13-1" href="#第17章-13-1-Vector和Enumeration" aria-label="跳转到章节" title="跳转到章节">17.13.1 Vector和Enumeration</a></li>
<li><a id="index_17-13-2" href="#第17章-13-2-Hashtable" aria-label="跳转到章节" title="跳转到章节">17.13.2 Hashtable</a></li>
<li><a id="index_17-13-3" href="#第17章-13-3-Stack" aria-label="跳转到章节" title="跳转到章节">17.13.3 Stack</a></li>
<li><a id="index_17-13-4" href="#第17章-13-4-BitSet" aria-label="跳转到章节" title="跳转到章节">17.13.4 BitSet</a></li>
</ul>
</li>
<li><a id="index_17-14" href="#第17章-14-总结" aria-label="跳转到章节" title="跳转到章节">17.14 总结</a></li>
</ul>
</li>
<li><p><a id="index_18" href="#第18章-Java-IO系统" aria-label="跳转到章节" title="跳转到章节">第18章 Java IO系统</a></p>
<ul>
<li><a id="index_18-1" href="#第18章-1-File类" aria-label="跳转到章节" title="跳转到章节">18.1 File类</a><ul>
<li><a id="index_18-1-1" href="#第18章-1-1-目录列表器" aria-label="跳转到章节" title="跳转到章节">18.1.1 目录列表器</a></li>
<li><a id="index_18-1-2" href="#第18章-1-2-目录实用工具" aria-label="跳转到章节" title="跳转到章节">18.1.2 目录实用工具</a></li>
<li><a id="index_18-1-3" href="#第18章-1-3-目录的检查及创建" aria-label="跳转到章节" title="跳转到章节">18.1.3 目录的检查及创建</a></li>
</ul>
</li>
<li><a id="index_18-2" href="#第18章-2-输入（Input）和输出（Output）" aria-label="跳转到章节" title="跳转到章节">18.2 输入（Input）和输出（Output）</a><ul>
<li><a id="index_18-2-1" href="#第18章-2-1-InputStream类型" aria-label="跳转到章节" title="跳转到章节">18.2.1 InputStream类型</a></li>
<li><a id="index_18-2-2" href="#第18章-2-2-OutputStream类型" aria-label="跳转到章节" title="跳转到章节">18.2.2 OutputStream类型</a></li>
</ul>
</li>
<li><a id="index_18-3" href="#第18章-3-添加属性和有用的接口" aria-label="跳转到章节" title="跳转到章节">18.3 添加属性和有用的接口</a><ul>
<li><a id="index_18-3-1" href="#第18章-3-1-通过FilterInputStream从InputStream读取数据" aria-label="跳转到章节" title="跳转到章节">18.3.1 通过FilterInputStream从InputStream读取数据</a></li>
<li><a id="index_18-3-2" href="#第18章-3-2-通过FilterOutputStream从OutputStream写入" aria-label="跳转到章节" title="跳转到章节">18.3.2 通过FilterOutputStream从OutputStream写入</a></li>
</ul>
</li>
<li><a id="index_18-4" href="#第18章-4-Reader和Writer" aria-label="跳转到章节" title="跳转到章节">18.4 Reader和Writer</a><ul>
<li><a id="index_18-4-1" href="#第18章-4-1-数据的来源和去处（字节流和字符流类库的关联）" aria-label="跳转到章节" title="跳转到章节">18.4.1 数据的来源和去处（字节流和字符流类库的关联）</a></li>
<li><a id="index_18-4-2" href="#第18章-4-2-更改流的行为" aria-label="跳转到章节" title="跳转到章节">18.4.2 更改流的行为</a></li>
<li><a id="index_18-4-3" href="#第18章-4-3-未发生变化的类" aria-label="跳转到章节" title="跳转到章节">18.4.3 未发生变化的类</a></li>
</ul>
</li>
<li><a id="index_18-5" href="#第18章-5-自我独立的类：RandomAccessFile" aria-label="跳转到章节" title="跳转到章节">18.5 自我独立的类：RandomAccessFile</a></li>
<li><a id="index_18-6" href="#第18章-6-IO流的典型使用方式" aria-label="跳转到章节" title="跳转到章节">18.6 IO流的典型使用方式</a><ul>
<li><a id="index_18-6-1" href="#第18章-6-1-缓冲输入文件" aria-label="跳转到章节" title="跳转到章节">18.6.1 缓冲输入文件</a></li>
<li><a id="index_18-6-2" href="#第18章-6-2-从内存输入" aria-label="跳转到章节" title="跳转到章节">18.6.2 从内存输入</a></li>
<li><a id="index_18-6-3" href="#第18章-6-3-格式化的内存输入" aria-label="跳转到章节" title="跳转到章节">18.6.3 格式化的内存输入</a></li>
<li><a id="index_18-6-4" href="#第18章-6-4-基本的文件输出" aria-label="跳转到章节" title="跳转到章节">18.6.4 基本的文件输出</a></li>
<li><a id="index_18-6-5" href="#第18章-6-5-存储和恢复数据" aria-label="跳转到章节" title="跳转到章节">18.6.5 存储和恢复数据</a></li>
<li><a id="index_18-6-6" href="#第18章-6-6-随机读写访问文件" aria-label="跳转到章节" title="跳转到章节">18.6.6 随机读写访问文件</a></li>
<li><a id="index_18-6-7" href="#第18章-6-7-管道流" aria-label="跳转到章节" title="跳转到章节">18.6.7 管道流</a></li>
</ul>
</li>
<li><a id="index_18-7" href="#第18章-7-文件读写的实用工具" aria-label="跳转到章节" title="跳转到章节">18.7 文件读写的实用工具</a><ul>
<li><a id="index_18-7-1" href="#第18章-7-1-读取二进制文件" aria-label="跳转到章节" title="跳转到章节">18.7.1 读取二进制文件</a></li>
</ul>
</li>
<li><a id="index_18-8" href="#第18章-8-标准IO" aria-label="跳转到章节" title="跳转到章节">18.8 标准IO</a><ul>
<li><a id="index_18-8-1" href="#第18章-8-1-从标准输入中读取" aria-label="跳转到章节" title="跳转到章节">18.8.1 从标准输入中读取</a></li>
<li><a id="index_18-8-2" href="#第18章-8-2-将System.out转换成PrintWriter" aria-label="跳转到章节" title="跳转到章节">18.8.2 将System.out转换成PrintWriter</a></li>
<li><a id="index_18-8-3" href="#第18章-8-3-标准IO重定向" aria-label="跳转到章节" title="跳转到章节">18.8.3 标准IO重定向</a></li>
</ul>
</li>
<li><a id="index_18-9" href="#第18章-9-进程控制" aria-label="跳转到章节" title="跳转到章节">18.9 进程控制</a></li>
<li><a id="index_18-10" href="#第18章-10-新IO" aria-label="跳转到章节" title="跳转到章节">18.10 新IO</a><ul>
<li><a id="index_18" href="#第18章-10-1-转换数据" aria-label="跳转到章节" title="跳转到章节">18.10.1 转换数据</a></li>
<li><a id="index_18-10-2" href="#第18章-10-2-获取基本类型" aria-label="跳转到章节" title="跳转到章节">18.10.2 获取基本类型</a></li>
<li><a id="index_18-10-3" href="#第18章-10-3-视图缓冲器" aria-label="跳转到章节" title="跳转到章节">18.10.3 视图缓冲器</a></li>
<li><a id="index_18-10-4" href="#第18章-10-4-用缓冲器操纵数据" aria-label="跳转到章节" title="跳转到章节">18.10.4 用缓冲器操纵数据</a></li>
<li><a id="index_18-10-5" href="#第18章-10-5-缓冲器的细节" aria-label="跳转到章节" title="跳转到章节">18.10.5 缓冲器的细节</a></li>
<li><a id="index_18-10-6" href="#第18章-10-6-内存映射文件" aria-label="跳转到章节" title="跳转到章节">18.10.6 内存映射文件</a></li>
<li><a id="index_18-10-7" href="#第18章-10-7-文件加锁" aria-label="跳转到章节" title="跳转到章节">18.10.7 文件加锁</a></li>
</ul>
</li>
<li><a id="index_18-11" href="#第18章-11-压缩" aria-label="跳转到章节" title="跳转到章节">18.11 压缩</a><ul>
<li><a id="index_18-11-1" href="#第18章-11-1-用GZIP进行简单压缩" aria-label="跳转到章节" title="跳转到章节">18.11.1 用GZIP进行简单压缩</a></li>
<li><a id="index_18-11-2" href="#第18章-11-2-用Zip进行多文件保存" aria-label="跳转到章节" title="跳转到章节">18.11.2 用Zip进行多文件保存</a></li>
<li><a id="index_18-11-3" href="#第18章-11-3-Java档案文件" aria-label="跳转到章节" title="跳转到章节">18.11.3 Java档案文件</a></li>
</ul>
</li>
<li><a id="index_18-12" href="#第18章-12-对象序列化" aria-label="跳转到章节" title="跳转到章节">18.12 对象序列化</a><ul>
<li><a id="index_18-12-1" href="#第18章-12-1-寻找类" aria-label="跳转到章节" title="跳转到章节">18.12.1 寻找类</a></li>
<li><a id="index_18-12-2" href="#第18章-12-2-序列化的控制" aria-label="跳转到章节" title="跳转到章节">18.12.2 序列化的控制</a></li>
<li><a id="index_18-12-3" href="#第18章-12-3-使用“持久性”" aria-label="跳转到章节" title="跳转到章节">18.12.3 使用“持久性”</a></li>
</ul>
</li>
<li><a id="index_18-13" href="#第18章-13-XML" aria-label="跳转到章节" title="跳转到章节">18.13 XML</a></li>
<li><a id="index_18-14" href="#第18章-14-Preferences" aria-label="跳转到章节" title="跳转到章节">18.14 Preferences</a></li>
<li><a id="index_18-15" href="#第18章-15-总结" aria-label="跳转到章节" title="跳转到章节">18.15 总结</a></li>
</ul>
</li>
<li><p><a id="index_19" href="#第19章-枚举类型" aria-label="跳转到章节" title="跳转到章节">第19章 枚举类型</a></p>
<ul>
<li><a id="index_19-1" href="#第19章-1-基本enum特性" aria-label="跳转到章节" title="跳转到章节">19.1 基本enum特性</a><ul>
<li><a id="index_19-1-1" href="#第19章-1-1-将静态导入用于enum" aria-label="跳转到章节" title="跳转到章节">19.1.1 将静态导入用于enum</a></li>
</ul>
</li>
<li><a id="index_19-2" href="#第19章-2-向enum中添加新方法" aria-label="跳转到章节" title="跳转到章节">19.2 向enum中添加新方法</a><ul>
<li><a id="index_19-2-1" href="#第19章-2-1-覆盖enum的方法" aria-label="跳转到章节" title="跳转到章节">19.2.1 覆盖enum的方法</a></li>
</ul>
</li>
<li><a id="index_19-3" href="#第19章-3-switch语句中的enum" aria-label="跳转到章节" title="跳转到章节">19.3 switch语句中的enum</a></li>
<li><a id="index_19-4" href="#第19章-4-values-的神秘之处" aria-label="跳转到章节" title="跳转到章节">19.4 values()的神秘之处</a></li>
<li><a id="index_19-5" href="#第19章-5-实现而非继承" aria-label="跳转到章节" title="跳转到章节">19.5 实现而非继承</a></li>
<li><a id="index_19-6" href="#第19章-6-随机选取" aria-label="跳转到章节" title="跳转到章节">19.6 随机选取</a></li>
<li><a id="index_19-7" href="#第19章-7-使用接口组织枚举" aria-label="跳转到章节" title="跳转到章节">19.7 使用接口组织枚举</a></li>
<li><a id="index_19-8" href="#第19章-8-使用EnumSet替代标志" aria-label="跳转到章节" title="跳转到章节">19.8 使用EnumSet替代标志</a></li>
<li><a id="index_19-9" href="#第19章-9-使用EnumMap" aria-label="跳转到章节" title="跳转到章节">19.9 使用EnumMap</a></li>
<li><a id="index_19-10" href="#第19章-10-常量相关的方法（枚举类的抽象方法）" aria-label="跳转到章节" title="跳转到章节">19.10 常量相关的方法（枚举类的抽象方法）</a><ul>
<li><a id="index_19-10-1" href="#第19章-10-1-使用enum的职责链" aria-label="跳转到章节" title="跳转到章节">19.10.1 使用enum的职责链</a></li>
<li><a id="index_19-10-2" href="#第19章-10-2-使用enum的状态机" aria-label="跳转到章节" title="跳转到章节">19.10.2 使用enum的状态机</a></li>
</ul>
</li>
<li><a id="index_19-11" href="#第19章-11-多路分发" aria-label="跳转到章节" title="跳转到章节">19.11 多路分发</a><ul>
<li><a id="index_19-11-1" href="#第19章-11-1-使用enum分发" aria-label="跳转到章节" title="跳转到章节">19.11.1 使用enum分发</a></li>
<li><a id="index_19-11-2" href="#第19章-11-2-使用常量相关的方法" aria-label="跳转到章节" title="跳转到章节">19.11.2 使用常量相关的方法</a></li>
<li><a id="index_19-11-3" href="#第19章-11-3-使用EnumMap分发" aria-label="跳转到章节" title="跳转到章节">19.11.3 使用EnumMap分发</a></li>
<li><a id="index_19-11-4" href="#第19章-11-4-使用二维数组" aria-label="跳转到章节" title="跳转到章节">19.11.4 使用二维数组</a></li>
</ul>
</li>
<li><a id="index_19-12" href="#第19章-12-总结" aria-label="跳转到章节" title="跳转到章节">19.12 总结</a></li>
</ul>
</li>
<li><p><a id="index_20" href="#第20章-注解" aria-label="跳转到章节" title="跳转到章节">第20章 注解</a></p>
<ul>
<li><a id="index_20-1" href="#第20章-1-基本语法" aria-label="跳转到章节" title="跳转到章节">20.1 基本语法</a><ul>
<li><a id="index_20-1-1" href="#第20章-1-1-定义注解" aria-label="跳转到章节" title="跳转到章节">20.1.1 定义注解</a></li>
<li><a id="index_20-1-2" href="#第20章-1-2-元注解" aria-label="跳转到章节" title="跳转到章节">20.1.2 元注解</a></li>
</ul>
</li>
<li><a id="index_20-2" href="#第20章-2-编写注解处理器" aria-label="跳转到章节" title="跳转到章节">20.2 编写注解处理器</a><ul>
<li><a id="index_20-2-1" href="#第20章-2-1-注解元素" aria-label="跳转到章节" title="跳转到章节">20.2.1 注解元素</a></li>
<li><a id="index_20-2-2" href="#第20章-2-2-默认值限制" aria-label="跳转到章节" title="跳转到章节">20.2.2 默认值限制</a></li>
<li><a id="index_20-2-3" href="#第20章-2-3-生成外部文件" aria-label="跳转到章节" title="跳转到章节">20.2.3 生成外部文件</a></li>
<li><a id="index_20-2-4" href="#第20章-2-4-注解不支持继承" aria-label="跳转到章节" title="跳转到章节">20.2.4 注解不支持继承</a></li>
<li><a id="index_20-2-5" href="#第20章-2-5-实现处理器" aria-label="跳转到章节" title="跳转到章节">20.2.5 实现处理器</a></li>
</ul>
</li>
<li><a id="index_20-3" href="#第20章-3-使用apt处理注解" aria-label="跳转到章节" title="跳转到章节">20.3 使用apt处理注解</a></li>
<li><a id="index_20-4" href="#第20章-4-将观察者模式用于apt" aria-label="跳转到章节" title="跳转到章节">20.4 将观察者模式用于apt</a></li>
<li><a id="index_20-5" href="#第20章-5-基于注解的单元测试" aria-label="跳转到章节" title="跳转到章节">20.5 基于注解的单元测试</a><ul>
<li><a id="index_20-5-1" href="#第20章-5-1-将-Unit用于泛型" aria-label="跳转到章节" title="跳转到章节">20.5.1 将@Unit用于泛型</a></li>
<li><a id="index_20-5-2" href="#第20章-5-2-不需要任何“套件”" aria-label="跳转到章节" title="跳转到章节">20.5.2 不需要任何“套件”</a></li>
<li><a id="index_20-5-3" href="#第20章-5-3-实现-Unit" aria-label="跳转到章节" title="跳转到章节">20.5.3 实现@Unit</a></li>
<li><a id="index_20-5-4" href="#第20章-5-4-移除测试代码" aria-label="跳转到章节" title="跳转到章节">20.5.4 移除测试代码</a></li>
</ul>
</li>
<li><a id="index_20-6" href="#第20章-6-总结" aria-label="跳转到章节" title="跳转到章节">20.6 总结</a></li>
</ul>
</li>
<li><p><a id="index_21" href="#第21章-并发" aria-label="跳转到章节" title="跳转到章节">第21章 并发</a></p>
<ul>
<li><a id="index_21-1" href="#第21章-1-并发的多面性" aria-label="跳转到章节" title="跳转到章节">21.1 并发的多面性</a></li>
<li><a id="index_21-2" href="#第21章-2-基本的线程机制" aria-label="跳转到章节" title="跳转到章节">21.2 基本的线程机制</a></li>
<li><a id="index_21-3" href="#第21章-3-共享受限资源" aria-label="跳转到章节" title="跳转到章节">21.3 共享受限资源</a></li>
<li><a id="index_21-4" href="#第21章-4-终结任务" aria-label="跳转到章节" title="跳转到章节">21.4 终结任务</a></li>
<li><a id="index_21-5" href="#第21章-5-线程之间的协作" aria-label="跳转到章节" title="跳转到章节">21.5 线程之间的协作</a></li>
<li><a id="index_21-6" href="#第21章-6-死锁" aria-label="跳转到章节" title="跳转到章节">21.6 死锁</a></li>
<li><a id="index_21-7" href="#第21章-7-新类库中的构件" aria-label="跳转到章节" title="跳转到章节">21.7 新类库中的构件</a></li>
<li><a id="index_21-8" href="#第21章-8-仿真" aria-label="跳转到章节" title="跳转到章节">21.8 仿真</a></li>
<li><a id="index_21-9" href="#第21章-9-性能调优" aria-label="跳转到章节" title="跳转到章节">21.9 性能调优</a></li>
<li><a id="index_21-10" href="#第21章-10-活动对象" aria-label="跳转到章节" title="跳转到章节">21.10 活动对象</a></li>
<li><a id="index_21-11" href="#第21章-11-总结" aria-label="跳转到章节" title="跳转到章节">21.11 总结</a></li>
</ul>
</li>
<li><p><a id="index_22" href="#第22章-图形化用户界面" aria-label="跳转到章节" title="跳转到章节">第22章 图形化用户界面</a></p>
</li>
</ol>
<hr>
<h1 id="第1章-面向对象导论"><a href="#第1章-面向对象导论" class="headerlink" title="第1章 面向对象导论"></a><a href="#index_1">第1章 面向对象导论</a></h1><h2 id="面向对象程序设计（Object-oriend-Programming，OOP）。"><a href="#面向对象程序设计（Object-oriend-Programming，OOP）。" class="headerlink" title="面向对象程序设计（Object-oriend Programming，OOP）。"></a><strong>面向对象程序设计</strong>（Object-oriend Programming，<strong>OOP</strong>）。</h2><p>本章将介绍包括开发方法概述在内的&thinsp;OOP&thinsp;的基本概念。</p>
<p>相关资料：🗎<sup id="cite_ref-1"><em><font color="#808080">[</font><a href="#cite_note-1">1</a><font color="#808080">]</font></em></sup>🗎<sup id="cite_ref-2"><em><font color="#808080">[</font><a href="#cite_note-2">2</a><font color="#808080">]</font></em></sup></p>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>面向对象程序设计（OOP）是一种具有<strong>对象</strong>概念的<u>程序编程规范</u>，同时也是一种程序开发的<strong>抽象</strong>方针。</p>
<ul>
<li>它可以包含<strong>数据</strong>、<strong>属性</strong>、<strong>代码</strong>&thinsp;与&thinsp;<strong>方法</strong>。</li>
<li>在面向对象程序设计（OOP）中，计算机程序会被设计成彼此相关的&thinsp;<strong>对象</strong>。</li>
<li>这种在程序中包含各种独立而又相互调用的对象的思想，与传统编程思想正好相反：传统的程序设计主张把程序看成一系列函数的集合，或者直接对计算机下达的指令。</li>
<li>OOP&thinsp;中的每个对象都应该能接受和处理数据，并且能将数据传达给其他对象。</li>
<li>OOP = <strong>对象</strong> + <strong>类</strong> + <strong>继承</strong> + <strong>多态</strong> + <strong>消息</strong>，其中的核心概念是类和对象。<ul>
<li>其中，<strong>对象</strong>&thinsp;指的是&thinsp;<strong>类的实例</strong>。</li>
<li>对象是程序的基本单元，将程序的数据封装在其中，以提高软件的重用性、灵活性和拓展性。对象里的程序可以访问和修改该对象相关联的数据。</li>
</ul>
</li>
</ul>
<h3 id="主要特征：封装性、继承性、多态性"><a href="#主要特征：封装性、继承性、多态性" class="headerlink" title="主要特征：封装性、继承性、多态性"></a>主要特征：封装性、继承性、多态性</h3><ol>
<li><p><strong>封装性</strong>：封装是指将计算机程序的数据，以及此数据相关的一切操作语言（即描述对象的属性和行为的代码）组装到一起，一并封装到一个有机实体（也就是“类”）中。</p>
<ul>
<li>封装的最基本单位是对象。</li>
<li>封装增强了软件结构的模块性，是软件在结构上实现“<strong>高内聚</strong>，<strong>低耦合</strong>”的基础。</li>
<li>封装的原则：隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li>
<li>封装的好处：<ul>
<li>（1）<strong>高内聚</strong>：将变化隔离，提高安全性；</li>
<li>（2）<strong>低耦合</strong>：便于使用，提高重用性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>继承性</strong>：继承是一种多种类之间的联系和区别关系。在面向对象中，继承是指一类对象针对另一类对象的某些特点和能力进行复制或者延续。</p>
<ul>
<li>父类又称为基类、超类；子类又称为派生类。子类可以直接访问父类中的非私有的属性和行为。关键字为<code>extends</code>。</li>
<li>按照继承源进行划分，继承可以分为单继承和多继承。</li>
<li>按照继承中包含的内容进行划分，继承可以分为4类，分别为取代继承、包含继承、受限继承、特化继承。</li>
<li>继承的好处：</li>
</ul>
</li>
<li><p><strong>多态性</strong>：在面向对象技术中——</p>
<ul>
<li>从宏观角度来讲，多态是指当不同的对象同时接收到同一个完全相同的消息时，所表现出来的动作是各不相同的，具有多种形态。</li>
<li>从微观角度来讲，多态是指在一个类中，调用同一个函数名，使用不同的参数（注：参数列表，包括参数数量和参数类型），得到不同的执行效果。</li>
<li>多态实现的前提条件：<ul>
<li>（1）有<strong>继承</strong>关系；</li>
<li>（2）有方法<strong>重写</strong>；</li>
<li>（3）有<strong>父类引用指向子类对象</strong>。</li>
</ul>
</li>
<li>多态有三种体现形式：<ul>
<li>（1）类多态；</li>
<li>（2）抽象类多态；</li>
<li>（3）接口多态。</li>
</ul>
</li>
<li>多态的优点：提高软件的<u>拓展性</u>和<u>可维护性</u>。</li>
<li>多态的缺点（？）：父类引用不能使用子类特有的功能。</li>
<li>多态在类型转换中的体现：<ul>
<li>（1）<u>基本类型：隐式转换（小到大），强制转换（大到小）</u>；</li>
<li>（2）<u>引用类型：向上转型（小到大），向下转型（大到小）</u>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="设计优点"><a href="#设计优点" class="headerlink" title="设计优点"></a>设计优点</h3><p>面向对象出现以前，结构化程序设计是程序设计的主流，结构化程序设计又称为<u>面向过程</u>的程序设计。在面向过程程序设计中，问题被看作一系列需要完成的任务，函数（在此泛指例程、函数、过程）用于完成这些任务，解决问题的焦点集中于函数。其中函数是面向过程的，即它关注如何根据规定的条件完成指定的任务。</p>
<p>比较面向对象程序设计和面向过程程序设计，还可以得到面向对象程序设计的其他优点：</p>
<ol>
<li>数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少甚至避免对外界的干扰；</li>
<li>通过继承大幅减少冗余的代码，并可以方便地扩展现有代码，提高编码效率，也减低了出错概率，降低软件维护的难度；</li>
<li>结合面向对象分析、面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中中间环节的转换过程；</li>
<li>通过对对象的辨别、划分可以将软件系统分割为若干相对为独立的部分，在一定程度上更便于控制<u>软件复杂度</u>；</li>
<li>以对象为中心的设计可以帮助开发人员从静态（属性）和动态（方法）两个方面把握问题，从而更好地实现系统；</li>
<li>通过对象的聚合、联合可以在保证封装与抽象的原则下实现对象在内在结构以及外在功能上的扩充，从而实现对象由低到高的升级。</li>
</ol>
<h3 id="设计缺陷"><a href="#设计缺陷" class="headerlink" title="设计缺陷"></a>设计缺陷</h3><ol>
<li><p>运行效率较低。</p>
<blockquote>
<p>类的大量加载会牺牲系统性能，降低运行速度。虽然CPU速度在提高，内存容量在增加，但这一问题仍会随着系统规模变大而逐渐显示出来，变得越发严重。</p>
</blockquote>
</li>
<li><p>类库庞大。</p>
<blockquote>
<p>由于类库都过于庞大，程序员对它们的掌握需要一段时间，从普及、推广的角度来看，类库应在保证其功能完备的基础上进行相应的缩减。</p>
</blockquote>
</li>
<li><p>类库可靠性。</p>
<blockquote>
<p>越庞大的系统必会存在我们无法预知的问题隐患，程序员无法完全保证类库中的每个类在各种环境中百分之百的正确，当使用的类发生了问题，就会影响后续工作，程序员也有可能推翻原来的全部工作。</p>
</blockquote>
</li>
</ol>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul>
<li><p>面向对象程序设计中的概念主要包括：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递。通过这些概念面向对象的思想得到了具体的体现。</p>
<ul>
<li><p>（1）对象（Object）：</p>
<blockquote>
<p>可以对其做事情的一些东西。对象有3种属性：状态、行为、标识。</p>
</blockquote>
</li>
<li><p>（2）类（Class）：</p>
<blockquote>
<p>一个共享相同结构和行为的对象的集合。类（Class）定义了一件事物的抽象特点。通常来说，类定义了事物的属性和它可以做到的（它的行为）。举例来说，“狗”这个类会包含狗的一切基础特征，例如它的孕育、毛皮颜色和吠叫的能力。类可以为程序提供模版和结构。一个类的方法和属性被称为“成员”。</p>
</blockquote>
</li>
<li><p>（3）封装（Encapsulation）：</p>
<blockquote>
<p>第一层意思：将数据和操作捆绑在一起，创造出一个新的类型的过程。第二层意思：将接口与实现分离的过程。</p>
</blockquote>
</li>
<li><p>（4）继承：</p>
<blockquote>
<p>类之间的关系，在这种关系中，一个类共享了一个或多个其他类定义的结构和行为。继承描述了类之间的“是一种”关系。子类可以对基类的行为进行扩展、覆盖、重定义。</p>
</blockquote>
</li>
<li><p>（5）组合：</p>
<blockquote>
<p>既是类之间的关系也是对象之间的关系。在这种关系中一个对象或者类包含了其他的对象和类。</p>
</blockquote>
</li>
<li><p>（6）多态：</p>
<blockquote>
<p>类型理论中的一个概念，一个名称可以表示很多不同类的对象，这些类和一个共同超类有关。因此，这个名称表示的任何对象可以以不同的方式响应一些共同的操作集合。</p>
</blockquote>
</li>
<li><p>（7）动态绑定：</p>
<blockquote>
<p>也称动态类型，指的是一个对象或者表达式的类型直到运行时才确定。通常由编译器插入特殊代码来实现。与之对立的是静态类型。</p>
</blockquote>
</li>
<li><p>（8）静态绑定：</p>
<blockquote>
<p>也称静态类型，指的是一个对象或者表达式的类型在编译时确定。</p>
</blockquote>
</li>
<li><p>（9）消息传递：</p>
<blockquote>
<p>指的是一个对象调用了另一个对象的方法（或者称为成员函数）。</p>
</blockquote>
</li>
<li><p>（10）方法：</p>
<blockquote>
<p>也称为成员函数，是指对象上的操作，作为类声明的一部分来定义。方法定义了可以对一个对象执行那些操作。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="第1章-1-抽象过程"><a href="#第1章-1-抽象过程" class="headerlink" title="第1章-1 抽象过程"></a><a href="#index_1-1">第1章-1 抽象过程</a></h2><p>所有编程语言都提供抽象机制。可以认为，人们所能够解决的问题的复杂性直接取决于抽象的类型和质量。所谓的“类型”指的是“所抽象的是什么”。</p>
<p>汇编语言是对底层机器的轻微抽象。接着出现的许多所谓“命令式”语言（如FORTRAN、BASIC、C等）都是对汇编语言的抽象。……</p>
<p>另一种对机器建模的方式就是只针对待解决问题建模。……</p>
<p>面向对象方式通过向程序员提供表示问题空间中的元素的工具而更近了一步。……</p>
<p>Alan Kay&thinsp;曾经总结了第一个[成功的面向对象语言、同时也是&thinsp;Java&thinsp;所基于的语言之一的&thinsp;Smalltalk&thinsp;的]五个基本特性，这些特性表现了一种纯粹的面向对象程序设计方式：</p>
<ul>
<li>(1)&ensp;<strong>万物皆为对象</strong>。将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身身上执行操作。理论上讲，你可以抽取待求解问题的任何概念化构件（示例：狗、建筑物、服务等），将其表示为程序中的对象。</li>
<li>(2)&ensp;<strong>程序是对象的集合，它们通过发送消息来告知彼此所要做的</strong>。……</li>
<li>(3)&ensp;<strong>每个对象都有自己的由其他对象所构成的存储</strong>。……</li>
<li>(4)&ensp;<strong>每个对象都拥有其类型</strong>。……</li>
<li>(5)&ensp;<strong>某一特定类型的所有对象都可以接收同样的消息</strong>。……</li>
</ul>
<p>Booch&thinsp;对&thinsp;对象&thinsp;提供了一个更加简洁的描述：<font color="#2b72ee"><strong>对象具有状态、行为和标识</strong></font>。<br>这意味着每一个对象都可以拥有<strong>内部数据</strong>（它们给出了该&thinsp;<strong>对象的状态</strong>）和<strong>方法</strong>（它们产生&thinsp;<strong>对象的行为</strong>），并且每一个对象都可以唯一地与其他对象区分开来（<strong>标识</strong>），具体说来，就是<span class="hint--info hint--rounded hint--top" data-hint="狭义说法；广义来说，
因为对象可以存在于不同的机器和地址空间中，它们还可以被存储在硬盘上。
在这些情况下，对象的标识就必须由内存之外的某些东西来确定。" ontouchstart>每一个对象在其内存中都有一个唯一的地址</span>。</p>
<h2 id="第1章-2-每个对象都有一个接口"><a href="#第1章-2-每个对象都有一个接口" class="headerlink" title="第1章-2 每个对象都有一个接口"></a><a href="#index_1-2">第1章-2 每个对象都有一个接口</a></h2><p>亚里士多德是第一个深入研究类型（type）的哲学家，他曾提出过鱼类和鸟类这样的概念。<u>所有的对象都是唯一的，但同时也是具有相同的特性和行为的对象所属的类的一部分</u>。这种思想被直接应用于第一个面向对象语言&thinsp;Simula-67，它在程序中使用基本关键字<code>class</code>来引入新的类型。</p>
<p>Simula，就像其名字一样，是为了开发诸如经典的“银行出纳员问题”（bank teller problem）这样的仿真程序而创建的。……</p>
<p>所以，尽管我们在面向对象程序设计中实际上进行的是创建新的数据类型，但事实上所有的面向对象程序设计语言都使用<code>class</code>这个关键词来表示数据类型。……<br>因为<u>类（class）描述了相同特性（数据元素）和行为（功能）的对象集合</u>，所以一个类（class）实际上就是一个数据类型，例如所有的浮点型数字都具有相同的特性和行为集合。……<br>……</p>
<p>UML（Unified Modelling Language，统一建模语言）形式的图，……</p>
<h2 id="第1章-3-每个对象都提供服务"><a href="#第1章-3-每个对象都提供服务" class="headerlink" title="第1章-3 每个对象都提供服务"></a><a href="#index_1-3">第1章-3 每个对象都提供服务</a></h2><p>……</p>
<h2 id="第1章-4-被隐藏的具体实现"><a href="#第1章-4-被隐藏的具体实现" class="headerlink" title="第1章-4 被隐藏的具体实现"></a><a href="#index_1-4">第1章-4 被隐藏的具体实现</a></h2><p>将程序开发人员按照角色分为类创建者（创建新数据类型的程序员）和<span class="hint--info hint--rounded hint--top" data-hint="This description is from Scott Meyers" ontouchstart>客户端程序员</span>（在应用程序中使用数据类型的类消费者）是大有裨益的。客户端程序员的目标，是收集各种用来实现快速应用开发的类。类创建者的目标是构建类，这种类只向客户端程序员暴露必需的部分，同时隐藏其他部分。构建类的只向客户端程序员暴露必需部分而隐藏其他部分的设计，能保证类的稳定安全，避免人为攻击，减少程序&thinsp;Bug。</p>
<p>明确边界：在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。……</p>
<p>因此，访问控制的存在原因：</p>
<ul>
<li>（1）让客户端程序员无法触及他们不应该接触的部分&thinsp;——&thinsp;这部分对数据类型的内部操作是必需的，但是对于解决问题所需的接口的一部分。</li>
<li>（2）允许库设计者可以改变&thinsp;<u>类内部</u>&thinsp;的工作方式，同时不用担心会影响到客户端程序员。<blockquote>
<p>Java&thinsp;用3个关键字在类的内部设定边界：<font color="#2b72ee"><strong>public</strong></font>，<font color="#2b72ee"><strong>private</strong></font>，<font color="#2b72ee"><strong>protected</strong></font>。这些<strong>访问指定词</strong>（access specifier）决定了紧跟其后被定义的东西可以被谁使用。……<br>Java&thinsp;还有一种默认的访问权限，当没有使用前面提到的任何访问指定词时，它将发挥作用。这种权限通常被称为&thinsp;<strong>包访问权限</strong>，在这种权限下，类可以访问在同一个包中的其他类的成员。</p>
</blockquote>
</li>
</ul>
<h2 id="第1章-5-复用具体实现"><a href="#第1章-5-复用具体实现" class="headerlink" title="第1章-5 复用具体实现"></a><a href="#index_1-5">第1章-5 复用具体实现</a></h2><p>一旦类被设计创建并被测试完，那么它就应该（在理想情况下）代表一个有用的代码单元。……。<strong>代码复用</strong>是面向对象程序设计语言提供的最了不起的优点之一。</p>
<p>最简单地复用某个类的方式就是直接使用该类的一个对象，此外也可以将那个类的一个对象置于某个新的类中。我们称其为“创建一个成员对象”。新的类可以由任意数量、任意类型的其他对象，以任意可以实现新的类中想要的功能的方式所组成。……</p>
<p>……</p>
<h2 id="第1章-6-继承"><a href="#第1章-6-继承" class="headerlink" title="第1章-6 继承"></a><a href="#index_1-6">第1章-6 继承</a></h2><p>对象这种概念，本身就是十分方便的工具，方便你通过概念将数据和功能封装到一起，因此可以对问题空间的观念给出恰当的表示，而不用受制于&thinsp;必须使用底层机器语言。这些概念用关键字<code>class</code>来表示，它们形成了编程语言中的基本单位。</p>
<p>当继承现有类型时，也就创造了新的类型。这个新的类型不仅包括&thinsp;<strong>现有类型的所有成员</strong>（尽管<code>private</code>成员被隐藏了起来，并且不可被访问），而且更重要的是它复制了&thinsp;<strong>基类的接口</strong>。也就是说，所有可以发送给基类对象的消息同时也能发送给派生类对象。由于通过发送给类的消息类型可以判断类的类型，所以派生类与基类具有相同的类型。</p>
<p>……</p>
<h3 id="第1章-6-1-“是一个”与“像是一个”的关系"><a href="#第1章-6-1-“是一个”与“像是一个”的关系" class="headerlink" title="第1章-6-1 “是一个”与“像是一个”的关系"></a><a href="#index_1-6-1">第1章-6-1 “是一个”与“像是一个”的关系</a></h3><p>对于继承可能会引发某些争论：继承是否应该只覆盖基类的方法，而并不添加在基类中没有的新方法？</p>
<p>略<del>（原文此处论述太过智障）</del>。</p>
<h2 id="第1章-7-伴随多态的可互换对象"><a href="#第1章-7-伴随多态的可互换对象" class="headerlink" title="第1章-7 伴随多态的可互换对象"></a><a href="#index_1-7">第1章-7 伴随多态的可互换对象</a></h2><p>在处理类型的层次结构时，经常想把一个对象不当作的它所属的特定类型来看待，而是将其当作其基类的对象来处理。这使得程序员可以编写出不依赖于特定类型的代码。</p>
<p><strong>泛化</strong>（<strong>generic</strong>），涉及到<strong>向上转型</strong>。<br>泛化处理的负面作用是导致编译器无法明确实际执行的代码，而代码的执行只能在编译完成后运行时才能确定。</p>
<p>因为面向对象程序设计语言使用了&thinsp;<strong>后期绑定</strong>&thinsp;的概念——当向对象发送消息时，被调用的代码直到运行时才能确定：编译器确保被调用的方法的存在，并对调用参数和返回值执行类型检查（<u>无法提供此类语言保证的语言</u>被称为&thinsp;<strong>弱类型语言</strong>），但是不能确定将被执行的确切代码。</p>
<p>为了执行&thinsp;<strong>后期绑定</strong>，Java&thinsp;使用一小段特殊的代码来<u>替代绝对地址调用</u>。这段代码<u>使用在对象中存储的信息来计算方法体的地址</u>（这个过程将在第八章中体现）。这样，根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能够知道通过这条消息应该做什么。</p>
<p>在某些语言中，必须明确地声明某个方法具备后期绑定属性所带来的灵活性（C++是使用virtual关键字来实现的）。在这些语言中，方法在默认情况下不是<strong>动态绑定</strong>的。而<u>在&thinsp;Java&thinsp;中，动态绑定是默认行为</u>，不需要添加额外的关键字来实现多态。</p>
<p>示例：多态的表现 - 示例</p>
<h2 id="第1章-8-单根继承结构"><a href="#第1章-8-单根继承结构" class="headerlink" title="第1章-8 单根继承结构"></a><a href="#index_1-8">第1章-8 单根继承结构</a></h2><blockquote>
<p>在&thinsp;OOP（面向对象编程）中，自&thinsp;C++&thinsp;面世以来就令人关注的一个问题：是否所有的类最终都继承自同一个基类。<br>在&thinsp;Java&thinsp;中（事实上还包括&thinsp;C++&thinsp;以外的所有&thinsp;OOP&thinsp;语言），答案是&thinsp;yes<div style="display:inline-block;margin-bottom:-18px;"> <img src="/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/Chapter1-8__All_classes_derived_from_java-lang-Object.jpg" class="" width="190" height="60" title="String也属于Object"> </div>&ensp;<div style="display:inline-block;margin-bottom:-18px;"> <img src="/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/Chapter1-8__String_belongTo_Object.jpg" class="" width="130" height="60" title="String也属于Object"> </div>，这个终极基类是&thinsp;<code>Object</code>。</p>
</blockquote>
<p>事实证明，<font color="#009100">单根继承结构</font>&thinsp;带来了很多好处。</p>
<p>在&thinsp;<font color="#009100">单根继承结构</font>&thinsp;中，所有对象都具有一个共用接口，所以它们归根结底都是相同的基本类型。</p>
<ul>
<li><p><font color="#009100"><strong>单根继承结构</strong></font>&thinsp;保证<u>所有对象都具备某些功能</u>，可以在每个对象上执行基本操作。所有对象<u>都很容易地在[&thinsp;堆（Heap）]上创建</u>，同时&thinsp;<strong>参数的传递</strong>&thinsp;也被极大地简化。</p>
</li>
<li><p><font color="#009100"><strong>单根继承结构</strong></font>&thinsp;使得<u>垃圾回收器的实现变得容易很多</u>，而垃圾回收器正是&thinsp;Java&thinsp;相对&thinsp;C++&thinsp;的重要改进之一。由于<u>所有对象都保证具有其自身的类型信息</u>，因此不会因为无法确定对象的类型而陷入僵局；这对于系统级操作（如异常处理）显得尤其重要，并且给编程带来了更大的灵活性。</p>
</li>
</ul>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>在另一种（C++所提供的）非单根继承结构中……</span></div>
    <div class="xContent"><div class="inner">
        <p>在另一种（C++所提供的）<strong>非单根继承结构</strong>中，无法确保所有的对象都属于同一个基本类型，从向后兼容的角度来看，这么做能够更好地适应C模型，且受限较少；除此以外不值得……</p>
 
    </div></div>
    </div>

<h2 id="第1章-9-容器"><a href="#第1章-9-容器" class="headerlink" title="第1章-9 容器"></a><a href="#index_1-9">第1章-9 容器</a></h2><h3 id="第1章-9-1-参数化类型"><a href="#第1章-9-1-参数化类型" class="headerlink" title="第1章-9-1 参数化类型"></a><a href="#index_1-9-1">第1章-9-1 参数化类型</a></h3><h2 id="第1章-10-对象的创建和生命周期"><a href="#第1章-10-对象的创建和生命周期" class="headerlink" title="第1章-10 对象的创建和生命周期"></a><a href="#index_1-10">第1章-10 对象的创建和生命周期</a></h2><h2 id="第1章-11-异常处理：错误处理"><a href="#第1章-11-异常处理：错误处理" class="headerlink" title="第1章-11 异常处理：错误处理"></a><a href="#index_1-11">第1章-11 异常处理：错误处理</a></h2><h2 id="第1章-12-并发编程"><a href="#第1章-12-并发编程" class="headerlink" title="第1章-12 并发编程"></a><a href="#index_1-12">第1章-12 并发编程</a></h2><h2 id="第1章-13-Java与Internet"><a href="#第1章-13-Java与Internet" class="headerlink" title="第1章-13 Java与Internet"></a><a href="#index_1-13">第1章-13 Java与Internet</a></h2><h3 id="第1章-13-1-Web是什么"><a href="#第1章-13-1-Web是什么" class="headerlink" title="第1章-13-1 Web是什么"></a><a href="#index_1-13-1">第1章-13-1 Web是什么</a></h3><h3 id="第1章-13-2-客户端编程"><a href="#第1章-13-2-客户端编程" class="headerlink" title="第1章-13-2 客户端编程"></a><a href="#index_1-13-2">第1章-13-2 客户端编程</a></h3><h3 id="第1章-13-3-服务器端编程"><a href="#第1章-13-3-服务器端编程" class="headerlink" title="第1章-13-3 服务器端编程"></a><a href="#index_1-13-3">第1章-13-3 服务器端编程</a></h3><h2 id="第1章-14-总结"><a href="#第1章-14-总结" class="headerlink" title="第1章-14 总结"></a><a href="#index_1-14">第1章-14 总结</a></h2><h1 id="第2章-一切都是对象"><a href="#第2章-一切都是对象" class="headerlink" title="第2章 一切都是对象"></a><a href="#index_2">第2章 一切都是对象</a></h1><h2 id="第2章-1-用引用操纵对象"><a href="#第2章-1-用引用操纵对象" class="headerlink" title="第2章-1 用引用操纵对象"></a><a href="#index_2-1">第2章-1 用引用操纵对象</a></h2><blockquote>
<p>每种编程语言都会有自己的操纵内存中元素的方式。很多时候，程序员必须注意将要处理的数据是什么类型。是选择直接操纵元素，还是用某种基于特殊语法的间接表示（）来操纵对象？</p>
<p>所有这一切在&thinsp;Java&thinsp;里得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都看做对象，但操纵的标识符实际上是对象的一个“引用”（<code>reference</code>）</p>
</blockquote>
<h2 id="第2章-2-必须由你创建所有对象【底层存储】"><a href="#第2章-2-必须由你创建所有对象【底层存储】" class="headerlink" title="第2章-2 必须由你创建所有对象【底层存储】"></a><a href="#index_2-2">第2章-2 必须由你创建所有对象【底层存储】</a></h2><p>一旦创建了一个引用，我们通常希望它能够与一个新的对象关联。<br>通常使用<code>new</code>操作符来实现这一目的。<code>new</code>关键字的意思是“分配一个新对象”。</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(“abcdef”);</span><br></pre></td></tr></table></figure>

<p>上述代码不仅表示“分配一个新的字符串”，还通过给构造方法提供的初始字符串，确定了如何构建这个<code>String</code>对象的信息。</p>
<p>这是&thinsp;Java&thinsp;程序设计中的一项基本行为。</p>
</blockquote>
<h3 id="第2章-2-1-存储到什么地方【对象的存储】"><a href="#第2章-2-1-存储到什么地方【对象的存储】" class="headerlink" title="第2章-2-1 存储到什么地方【对象的存储】"></a><a href="#index_2-2-1">第2章-2-1 存储到什么地方【对象的存储】</a></h3><div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>程序运行时……</span></div>
    <div class="xContent"><div class="inner">
        <p>程序运行时，对象是怎么进行存放安排的呢？特别是内存是怎样分配的呢？<br>对这些方面的了解对程序员会有很大的帮助。</p>
 
    </div></div>
    </div>

<p>有五个不同的地方可以存储数据：</p>
<ol>
<li><h4 id="寄存器。"><a href="#寄存器。" class="headerlink" title="寄存器。"></a><font color="#ff3333"><strong>寄存器</strong></font>。</h4><p>位于&thinsp;<strong>处理器内部</strong>。</p>
<blockquote>
<ul>
<li><p>这是&thinsp;<font color="#FCC000"><strong>最快的存储区</strong></font>。因为它位于不同于其他存储区的地方&thinsp;——&thinsp;<strong>处理器内部</strong>。</p>
</li>
<li><p>但是&thinsp;寄存器的数量&thinsp;极其有限，所以寄存器&thinsp;根据需求进行分配，且&thinsp;Java&thinsp;不允许程序员直接或间接地控制寄存器，甚至屏蔽寄存器的存在概念。<br>⤴&ensp;（另一方面，C&thinsp;和&thinsp;C++&thinsp;允许程序员向编译器建议寄存器的分配方式）</p>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="堆栈（Heap）。"><a href="#堆栈（Heap）。" class="headerlink" title="堆栈（Heap）。"></a><font color="#ff3333"><strong>堆栈</strong></font>（<font color="#ff3333"><strong>Heap</strong></font>）。</h4><p>位于通用&thinsp;<u><strong>RAM</strong>（随机访问存储器）</u>&thinsp;中。</p>
<blockquote>
<ul>
<li><p>通过&thinsp;<font color="#4343FF"><strong>堆栈指针</strong></font>&thinsp;可以从&thinsp;处理器&thinsp;那里获得&thinsp;直接支持。</p>
<ul>
<li><strong>堆栈指针</strong>，若向下移动，则<u>分配</u>新的内存；若向上移动，则<u>释放</u>已分配的内存。</li>
</ul>
</li>
<li><p><font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）是一个快速存储区域，存取效率仅次于&thinsp;<font color="#6AA84F">寄存器</font>。</p>
</li>
<li><p><strong><font color="#6AA84F">堆栈</font>（<font color="#6AA84F"><strong>Heap</strong></font>）中存放的数据</strong>&thinsp;必须明确其&thinsp;<font color="#FFC000"><strong>数据大小</strong></font>&thinsp;和&thinsp;<font color="#FFC000"><strong>生命周期</strong></font>&thinsp;，导致&thinsp;堆栈（Heap）区&thinsp;的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作<u>不灵活</u>。</p>
</li>
<li><p>在&thinsp;Java&thinsp;中，<font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）用来存放&thinsp;<font color="#4343FF"><strong>基本类型数据</strong></font>&thinsp;和&thinsp;<font color="#4343FF"><strong>对象的引用</strong></font>（对象句柄）。</p>
</li>
</ul>
</blockquote>
</li>
<li><h4 id="堆（Stack）。"><a href="#堆（Stack）。" class="headerlink" title="堆（Stack）。"></a><strong><font color="#ff3333">堆</font>（<font color="#ff3333">Stack</font>）</strong>。</h4><p>位于&thinsp;<strong>RAM</strong>&thinsp;中；是一种&thinsp;通用内存池。</p>
<blockquote>
<ul>
<li><font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Stack</strong></font>）中的数据不需要明确&thinsp;<font color="#FCC000"><strong>数据大小</strong></font>&thinsp;和&thinsp;<font color="#FCC000"><strong>生命周期</strong></font>，相比于&thinsp;<font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）&thinsp;具有很好的<u>灵活性</u>。</li>
<li>但相应的代价是：<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Stack</strong></font>）的&thinsp;存储分配&thinsp;和&thinsp;清理释放&thinsp;操作，相比于&thinsp;<font color="#6AA84F"><strong>堆栈</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>），速度慢很多。</li>
<li>在&thinsp;Java&thinsp;中，<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Stack</strong></font>）用于存放&thinsp;<u><font color="#FCC000"><strong>所有的&thinsp;Java&thinsp;对象</strong></font></u>。</li>
</ul>
</blockquote>
</li>
<li><h4 id="常量存储（常量池）。"><a href="#常量存储（常量池）。" class="headerlink" title="常量存储（常量池）。"></a><strong><font color="#ff3333">常量存储</font>（<font color="#ff3333">常量池</font>）</strong>。</h4><p>通常位于&thinsp;<u><strong>程序代码内部</strong></u>，随着&thinsp;JDK&thinsp;的迭代而存在不同的设计。（另外在嵌入式系统中，常量会和其他部分隔离，此时可以选择&thinsp;ROM&thinsp;作为常量存储区）</p>
<ul>
<li><p><font color="#6AA84F"><strong>常量存储</strong></font>（<font color="#6AA84F"><strong>常量池</strong></font>）位于&thinsp;<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）&thinsp;中。</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>JDK&thinsp;7&thinsp;之前的版本</span></div>
    <div class="xContent"><div class="inner">
        <p><font color="#6AA84F"><strong>运行时常量池</strong></font>&thinsp;是&thinsp;<strong>方法区</strong>&thinsp;的一部分。Class文件中除了有&thinsp;类的版本、字段、方法、接口&thinsp;等描述信息外，还有&thinsp;常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然&thinsp;<font color="#6AA84F"><strong>运行时常量池</strong></font>&thinsp;是&thinsp;<strong>方法区</strong>&thinsp;的一部分，自然受到&thinsp;方法区内存&thinsp;的限制，当&thinsp;<strong>常量池</strong>&thinsp;无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p>
 
    </div></div>
    </div>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>JDK&thinsp;7&thinsp;及之后的版本</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>JDK&thinsp;7&thinsp;及之后的版本中，JVM&thinsp;已经将&thinsp;<font color="#6AA84F"><strong>运行时常量池</strong></font>&thinsp;从&thinsp;方法区&thinsp;中移了出来，并在&thinsp;<font color="#6AA84F"><strong>堆</strong></font>（<font color="#6AA84F"><strong>Heap</strong></font>）&thinsp;中开辟了一块区域存放&thinsp;<font color="#6AA84F"><strong>运行时常量池</strong></font>。</p>
 
    </div></div>
    </div></li>
<li><p><font color="#6AA84F"><strong>常量存储</strong></font>（<font color="#6AA84F"><strong>常量池</strong></font>）&thinsp;用于存储&thinsp;常量。<br>⤷&ensp;因为常量是永远不会被改变的，所以&thinsp;Java&thinsp;中将&thinsp;常量池&thinsp;设置在&thinsp;<strong>程序内部</strong>&thinsp;的设计是安全的。</p>
</li>
</ul>
</li>
<li><h4 id="非RAM存储。"><a href="#非RAM存储。" class="headerlink" title="非RAM存储。"></a><font color="#ff3333"><strong>非RAM存储</strong></font>。</h4><p>在&thinsp;<font color="#6AA84F"><strong>非&thinsp;RAM&thinsp;存储</strong></font>&thinsp;中，存储的数据的生命周期不受程序本身的生命周期影响。<br>⤷&ensp;其中两个基本的例子是&thinsp;<font color="#4343FF"><strong>流对象</strong></font>&thinsp;和&thinsp;<font color="#4343FF"><strong>持久化对象</strong></font>。</p>
<blockquote>
<ul>
<li><p>在&thinsp;<font color="#4343FF"><strong>流对象</strong></font>&thinsp;中，对象被转化为<font color="#4343FF"><strong>字节流</strong></font><strong>（Bit Stream）</strong>；通常被发送给另一台机器。</p>
</li>
<li><p>在&thinsp;<font color="#4343FF"><strong>持久化对象</strong></font>&thinsp;中，对象被存放于磁盘上，对象的存储形式与其存储媒介有关。<br>⤷&ensp;在需要时，可以将&thinsp;持久化对象&thinsp;从&thinsp;具体的存储形式&thinsp;恢复成&thinsp;常规的、基于&thinsp;RAM&thinsp;的对象。</p>
</li>
</ul>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>Java 提供了对&thinsp;轻量级持久化&thinsp;的支持……</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>Java&thinsp;提供了&thinsp;对&thinsp;<u><strong>轻量级持久化</strong></u>&thinsp;的支持。诸如&thinsp;JDBC&thinsp;和&thinsp;Hibernate&thinsp;这样的机制，提供了&thinsp;更加复杂的、对数据库中的对象信息的&thinsp;存取支持。</p>
 
    </div></div>
    </div></li>
</ol>
<h3 id="第2章-2-2-特例：基本类型"><a href="#第2章-2-2-特例：基本类型" class="headerlink" title="第2章-2-2 特例：基本类型"></a><a href="#index_2-2-2">第2章-2-2 特例：基本类型</a></h3><p>基本类型对象&thinsp;直接存储“值”，而不是引用；基本类型对象直接存储于&thinsp;堆栈（Heap）&thinsp;中，所以其所占空间大小是确定的。</p>
<blockquote>
<p>Java&thinsp;要确定每种&thinsp;<strong>基本类型</strong>&thinsp;所占空间大小。它们的大小不会随着机器硬件架构的变化而变化，这种&thinsp;所占存储空间大小的不变性&thinsp;是&thinsp;Java&thinsp;<strong>可移植性</strong>&thinsp;好的原因之一。</p>
</blockquote>


<table class="wikitable" style="margin-top:18px;margin-left:0;margin-right:0;">
  <tbody>
    <tr align="center">
      <th style="width:15%;min-width:75px;">基本类型</th>
      <th style="width:15%;min-width:75px;">中文名称</th>
      <th style="width:16%;min-width:75px;">数据大小(单位：位)</th>
      <th style="width:16%;min-width:75px;">最小值</th>
      <th style="width:16%;min-width:75px;">最大值</th>
      <th style="width:15%;min-width:75px;">对应包装器类型</th>
    </tr>
    <tr>
      <td>boolean</td>
      <td>布尔型</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td>Boolean</td>
    </tr>
    <tr>
      <td>char</td>
      <td>字符型</td>
      <td>16 bit</td>
      <td>Unicode 0</td>
      <td>Unicode 2^16-1</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>byte</td>
      <td>字节型</td>
      <td>8 bit</td>
      <td>-2^7（-128）</td>
      <td>+2^7-1（127）</td>
      <td>Byte</td>
    </tr>

    <tr>
      <td>short</td>
      <td>短整型</td>
      <td>16 bit</td>
      <td>-2^15</td>
      <td>+2^15-1</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>int</td>
      <td>整型</td>
      <td>32 bit</td>
      <td>-2^31</td>
      <td>+2^31-1</td>
      <td>Integer</td>
    </tr>
    <tr>
      <td>long</td>
      <td>长整型</td>
      <td>64 bit</td>
      <td>-2^63</td>
      <td>+2^63-1</td>
      <td>Long</td>
    </tr>
    <tr>
      <td>float</td>
      <td>浮点型</td>
      <td>32 bit</td>
      <td>IEEE754</td>
      <td>IEEE754</td>
      <td>Character</td>
    </tr>
    <tr>
      <td>double</td>
      <td>双精度浮点型</td>
      <td>64 bit</td>
      <td>IEEE754</td>
      <td>IEEE754</td>
      <td>Double</td>
    </tr>
    <tr>
      <td>void</td>
      <td>字符型</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td align="center">——</td>
      <td>Void</td>
    </tr>
  </tbody>
</table>



<blockquote>
<p>boolean&thinsp;类型所占空间大小没有明确地指定，仅定义为能够取字面值<code>true</code>或<code>false</code>。</p>
</blockquote>
<p>所有的&thinsp;<strong>数值类型</strong>&thinsp;都有&thinsp;<strong>符号</strong>，所以不要去寻找无符号的&thinsp;数值类型。</p>
<h3 id="第2章-2-3-Java中的数组"><a href="#第2章-2-3-Java中的数组" class="headerlink" title="第2章-2-3 Java中的数组"></a><a href="#index_2-2-3">第2章-2-3 Java中的数组</a></h3><h3 id="第2章-3-永远不需要销毁对象"><a href="#第2章-3-永远不需要销毁对象" class="headerlink" title="第2章-3 永远不需要销毁对象"></a><a href="#index_2-3">第2章-3 永远不需要销毁对象</a></h3><h3 id="第2章-4-创建新的数据类型"><a href="#第2章-4-创建新的数据类型" class="headerlink" title="第2章-4 创建新的数据类型"></a><a href="#index_2-4">第2章-4 创建新的数据类型</a></h3><h3 id="第2章-5-方法、参数和返回值"><a href="#第2章-5-方法、参数和返回值" class="headerlink" title="第2章-5 方法、参数和返回值"></a><a href="#index_2-5">第2章-5 方法、参数和返回值</a></h3><h3 id="第2章-6-构建一个Java程序"><a href="#第2章-6-构建一个Java程序" class="headerlink" title="第2章-6 构建一个Java程序"></a><a href="#index_2-6">第2章-6 构建一个Java程序</a></h3><h3 id="第2章-7-你的第一个Java程序"><a href="#第2章-7-你的第一个Java程序" class="headerlink" title="第2章-7 你的第一个Java程序"></a><a href="#index_2-7">第2章-7 你的第一个Java程序</a></h3><h3 id="第2章-8-注释和嵌入式文档"><a href="#第2章-8-注释和嵌入式文档" class="headerlink" title="第2章-8 注释和嵌入式文档"></a><a href="#index_2-8">第2章-8 注释和嵌入式文档</a></h3><h3 id="第2章-9-编码风格"><a href="#第2章-9-编码风格" class="headerlink" title="第2章-9 编码风格"></a><a href="#index_2-9">第2章-9 编码风格</a></h3><h3 id="第2章-10-总结"><a href="#第2章-10-总结" class="headerlink" title="第2章-10 总结"></a><a href="#index_2-10">第2章-10 总结</a></h3><h3 id="第2章-11-练习"><a href="#第2章-11-练习" class="headerlink" title="第2章-11 练习"></a><a href="#index_2-11">第2章-11 练习</a></h3><h1 id="第3章-操作符"><a href="#第3章-操作符" class="headerlink" title="第3章 操作符"></a><a href="#index_3">第3章 操作符</a></h1><p>在最底层，Java&thinsp;中的数据是通过使用&thinsp;<strong>操作符</strong>&thinsp;来操作的。</p>
<h2 id="第3章-1-更简单的打印语句"><a href="#第3章-1-更简单的打印语句" class="headerlink" title="第3章-1 更简单的打印语句"></a><a href="#index_3-1">第3章-1 更简单的打印语句</a></h2><h2 id="第3章-2-使用Java操作符"><a href="#第3章-2-使用Java操作符" class="headerlink" title="第3章-2 使用Java操作符"></a><a href="#index_3-2">第3章-2 使用Java操作符</a></h2><ul>
<li><p>操作符&thinsp;接受一个或多个&thinsp;<strong>参数</strong>，并生成一个新值。</p>
<blockquote>
<p>参数的形式&thinsp;与普通的&thinsp;方法调用&thinsp;不同，但效果是相同的。</p>
</blockquote>
</li>
<li><p>加号和一元的正号<code>+</code>、减号和一元的负号<code>-</code>、乘号<code>*</code>、除号<code>/</code>以及赋值号<code>=</code>的用法与其他编程语言类似。</p>
</li>
<li><p>操作符&thinsp;用于操作&thinsp;数，生成一个新值。</p>
<blockquote>
<p>另外，有些操作符可能会<u>改变&thinsp;操作数自身的值</u>，这被称为“<strong>副作用</strong>”。</p>
<p>那些能改变其操作数的操作符，最普遍的用途就是用来产生副作用；但要记住，使用此类操作符生成的值，与使用无副作用的操作符生成的值，没有什么区别。</p>
</blockquote>
</li>
<li><p>几乎所有的&thinsp;操作符&thinsp;都只能操作“<strong>基本类型</strong>”。</p>
<ul>
<li>例外的操作符是<code>=</code>、<code>==</code>和<code>!=</code>：这些操作符能操作所有的对象（这也是&thinsp;对象&thinsp;易令人糊涂的地方）。</li>
<li>除此之外，<code>String</code>类支持<code>+</code>和<code>+=</code>：操作<code>String</code>类的<code>+</code>和<code>+=</code>意味着字符串拼接，并且如果必要（被操作的对象不属于<code>String</code>类），编译器会先尝试将非<code>String</code>类型的对象转换为<code>String</code>类型对象，再进行字符串拼接的操作。<blockquote>
<p>注意：操作<code>String</code>类型对象的<code>+</code>和<code>+=</code>操作符，必须要小心使用（…），显式执行（？），杜绝在&thinsp;<strong>循环体</strong>&thinsp;中使用<code>+=</code>操作<code>String</code>造成内存的不可控使用（最坏结果：<u>内存溢出</u>）。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="第3章-3-优先级"><a href="#第3章-3-优先级" class="headerlink" title="第3章-3 优先级"></a><a href="#index_3-3">第3章-3 优先级</a></h2><ul>
<li>当一个&thinsp;<strong>表达式</strong>&thinsp;中存在多个&thinsp;<strong>操作符</strong>&thinsp;时，<strong>操作符的优先级</strong>&thinsp;就决定了各部分的计算顺序。<br>Java&thinsp;对&thinsp;计算顺序&thinsp;做了特别的规定。</li>
</ul>
<h2 id="第3章-4-赋值"><a href="#第3章-4-赋值" class="headerlink" title="第3章-4 赋值"></a><a href="#index_3-4">第3章-4 赋值</a></h2><h3 id="第3章-4-1-方法调用中的别名问题"><a href="#第3章-4-1-方法调用中的别名问题" class="headerlink" title="第3章-4.1 方法调用中的别名问题"></a><a href="#index_3-4-1">第3章-4.1 方法调用中的别名问题</a></h3><h2 id="第3章-5-算数操作符"><a href="#第3章-5-算数操作符" class="headerlink" title="第3章-5 算数操作符"></a><a href="#index_3-5">第3章-5 算数操作符</a></h2><h3 id="第3章-5-1-一元加减操作符"><a href="#第3章-5-1-一元加减操作符" class="headerlink" title="第3章-5-1 一元加减操作符"></a><a href="#index_3-5-1">第3章-5-1 一元加减操作符</a></h3><h2 id="第3章-6-自动递增和递减"><a href="#第3章-6-自动递增和递减" class="headerlink" title="第3章-6 自动递增和递减"></a><a href="#index_3-6">第3章-6 自动递增和递减</a></h2><h2 id="第3章-7-关系操作符"><a href="#第3章-7-关系操作符" class="headerlink" title="第3章-7 关系操作符"></a><a href="#index_3-7">第3章-7 关系操作符</a></h2><ul>
<li><p>关系操作符生成的是一个<code>boolean</code>（布尔）类型结果，计算的是&thinsp;操作数的值之间的关系。如果关系是真实的，则关系表达式会生成<code>true</code>（真），否则生成<code>false</code>（假）。</p>
</li>
<li><p>关系操作符包括：小于<code>&lt;</code>、大于<code>&gt;</code>、小于或等于<code>&lt;=</code>、大于或等于<code>&gt;=</code>、等于<code>==</code>、不等于<code>!=</code>。</p>
<blockquote>
<p>其中等于<code>==</code>、不等于<code>!=</code>适用于<u>所有的&thinsp;<strong>基本数据类型</strong></u>，而其他比较符适用于&thinsp;<u>除<code>boolean</code>类型以外的&thinsp;<strong>基本数据类型</strong></u>。</p>
<p>因为<code>boolean</code>值只能为<code>true</code>或<code>false</code>，对于&thinsp;大于&thinsp;和&thinsp;小于&thinsp;的逻辑来说没有实际意义。</p>
</blockquote>
</li>
</ul>
<h3 id="第3章-7-1-测试对象的等价性"><a href="#第3章-7-1-测试对象的等价性" class="headerlink" title="第3章-7-1 测试对象的等价性"></a><a href="#index_3-7-1">第3章-7-1 测试对象的等价性</a></h3><p>关系操作符<code>==</code>和<code>!=</code>适用于所有对象。</p>
<blockquote>
<p>注意：关系运算符&thinsp;比较的是&thinsp;<strong>对象的值</strong>。</p>
</blockquote>
<p>若要比较&thinsp;<strong>对象的引用</strong>，可以使用&thinsp;对象的<code>equals</code>方法（来自<code>Object</code>）实现。</p>
<h2 id="第3章-8-逻辑操作符"><a href="#第3章-8-逻辑操作符" class="headerlink" title="第3章-8 逻辑操作符"></a><a href="#index_3-8">第3章-8 逻辑操作符</a></h2><ul>
<li><p>逻辑操作符：与<code>&amp;&amp;</code>、或<code>||</code>、非<code>!</code>。</p>
</li>
<li><p>逻辑操作符&thinsp;能根据&thinsp;参数的逻辑关系，生成一个&thinsp;布尔值<code>boolean</code>（<code>true</code>或<code>false</code>）。</p>
</li>
<li><p>在&thinsp;Java&thinsp;中，逻辑操作符（与<code>&amp;&amp;</code>、或<code>||</code>、非<code>!</code>）只可应用于&thinsp;布尔值<code>boolean</code>。</p>
<blockquote>
<p>而在&thinsp;C&thinsp;和&thinsp;C++&thinsp;中，不可将一个&thinsp;布尔值&thinsp;当做&thinsp;非布尔值&thinsp;在&thinsp;<strong>逻辑表达式</strong>&thinsp;中使用。</p>
<p>注意：如果在使用<code>String</code>值的地方使用布尔值，该布尔值会自动转换为<code>String</code>形式。</p>
</blockquote>
</li>
</ul>
<h3 id="第3章-8-1-短路"><a href="#第3章-8-1-短路" class="headerlink" title="第3章-8-1 短路"></a><a href="#index_3-8-1">第3章-8-1 短路</a></h3><p>当使用逻辑运算符时，我们会遇到一种“短路”现象：一旦能够明确无误地确定&thinsp;<strong>整个表达式的值</strong>，就不再计算表达式的余下部分。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3.8.1 短路 - “短路”现象示例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Suite</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span> 2019-02-23 13:10:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortCircuitDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag2 = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag3 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【逻辑运算符】&#x27;&amp;&amp;&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;【逻辑运算符】&#x27;&amp;&amp;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 &amp;&amp; (flag2 = <span class="keyword">false</span>) &amp;&amp; (flag3 = <span class="keyword">false</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;&amp;&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&#x27;&amp;&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 &amp; (flag2 = ! flag2) &amp; (flag3 = ! flag3)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【逻辑运算符】&#x27;||&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;【逻辑运算符】&#x27;||&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 || (flag2 = <span class="keyword">false</span>) || (flag3 = <span class="keyword">false</span>)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;|&#x27;</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&#x27;|&#x27;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag1 | (flag2 = ! flag2) | (flag3 = ! flag3)) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;flag1 = &quot;</span>+ flag1 +<span class="string">&quot;,flag2 = &quot;</span>+ flag2 +<span class="string">&quot;,flag3 = &quot;</span>+ flag3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//!output: 【逻辑运算符】&#x27;||&#x27;</span></span><br><span class="line">    <span class="comment">//!output: flag1 = true,flag2 = true,flag3 = false</span></span><br><span class="line">    <span class="comment">//!output: &#x27;|&#x27;</span></span><br><span class="line">    <span class="comment">//!output: flag1 = true,flag2 = false,flag3 = true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【应用】我们可以借助“短路”这种设计，节省不必要的代码，使业务逻辑的实现（在编码层面）更精简方便。</p>
</blockquote>
<h2 id="第3章-9-直接常量"><a href="#第3章-9-直接常量" class="headerlink" title="第3章-9 直接常量"></a><a href="#index_3-9">第3章-9 直接常量</a></h2><h3 id="第3章-9-1-指数记数法"><a href="#第3章-9-1-指数记数法" class="headerlink" title="第3章-9-1 指数记数法"></a><a href="#index_3-9-1">第3章-9-1 指数记数法</a></h3><h2 id="第3章-10-按位操作符"><a href="#第3章-10-按位操作符" class="headerlink" title="第3章-10 按位操作符"></a><a href="#index_3-10">第3章-10 按位操作符</a></h2><h2 id="第3章-11-移位操作符"><a href="#第3章-11-移位操作符" class="headerlink" title="第3章-11 移位操作符"></a><a href="#index_3-11">第3章-11 移位操作符</a></h2><h2 id="第3章-12-三元操作符if-else"><a href="#第3章-12-三元操作符if-else" class="headerlink" title="第3章-12 三元操作符if-else"></a><a href="#index_3-12">第3章-12 三元操作符if-else</a></h2><h2 id="第3章-13-字符串操作符-和"><a href="#第3章-13-字符串操作符-和" class="headerlink" title="第3章-13 字符串操作符+和="></a><a href="#index_3-13">第3章-13 字符串操作符+和=</a></h2><h2 id="第3章-14-使用操作符时常犯的错误"><a href="#第3章-14-使用操作符时常犯的错误" class="headerlink" title="第3章-14 使用操作符时常犯的错误"></a><a href="#index_3-14">第3章-14 使用操作符时常犯的错误</a></h2><h2 id="第3章-15-类型转换操作符"><a href="#第3章-15-类型转换操作符" class="headerlink" title="第3章-15 类型转换操作符"></a><a href="#index_3-15">第3章-15 类型转换操作符</a></h2><h3 id="第3章-15-1-截尾和舍入"><a href="#第3章-15-1-截尾和舍入" class="headerlink" title="第3章-15-1 截尾和舍入"></a><a href="#index_3-15-1">第3章-15-1 截尾和舍入</a></h3><h3 id="第3章-15-2-提升"><a href="#第3章-15-2-提升" class="headerlink" title="第3章-15-2 提升"></a><a href="#index_3-15-2">第3章-15-2 提升</a></h3><h2 id="第3章-16-Java没有sizeof"><a href="#第3章-16-Java没有sizeof" class="headerlink" title="第3章-16 Java没有sizeof"></a><a href="#index_3-16">第3章-16 Java没有sizeof</a></h2><h2 id="第3章-17-操作符小结"><a href="#第3章-17-操作符小结" class="headerlink" title="第3章-17 操作符小结"></a><a href="#index_3-17">第3章-17 操作符小结</a></h2><h2 id="第3章-18-总结"><a href="#第3章-18-总结" class="headerlink" title="第3章-18 总结"></a><a href="#index_3-18">第3章-18 总结</a></h2><h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a><a href="#index_4">第4章 控制执行流程</a></h1><h1 id="第5章-初始化与清理"><a href="#第5章-初始化与清理" class="headerlink" title="第5章 初始化与清理"></a><a href="#index_5">第5章 初始化与清理</a></h1><p>随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。<br><strong>初始化</strong>&thinsp;和&thinsp;<strong>清理</strong>（<strong>cleanup</strong>）&thinsp;正是涉及<strong>安全</strong>的两个问题。</p>
<blockquote>
<ul>
<li><p>许多&thinsp;C&thinsp;程序的错误都源于程序员忘记&thinsp;<strong>初始化</strong>变量。特别是在使用程序库，且用户不知道如何正确地初始化库的构件（或者是必须初始化的其他东西）时，更是如此。</p>
</li>
<li><p><strong>清理</strong>&thinsp;也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记，导致这个元素占用的资源一直得不到释放，最终结果是资源（尤其是内存）用尽。</p>
</li>
</ul>
</blockquote>
<p>C++&thinsp;引入了&thinsp;<strong>构造器</strong>（<strong>constructor</strong>）&thinsp;的概念，这是一个&thinsp;<u>在<strong>创建对象</strong>时&thinsp;被自动调用的<strong>特殊方法</strong></u>。Java&thinsp;中也采用了&thinsp;<strong>构造器</strong>，并额外提供了“<strong>垃圾回收器</strong>”。对于不再使用的内存资源，垃圾回收器能自动将其释放。</p>
<p>本章就讨论&thinsp;<strong>初始化</strong>&thinsp;和&thinsp;<strong>清理</strong>&thinsp;的相关问题，以及&thinsp;Java&thinsp;对它们的支持。</p>
<h2 id="第5章-1-用构造器确保初始化"><a href="#第5章-1-用构造器确保初始化" class="headerlink" title="第5章-1 用构造器确保初始化"></a><a href="#index_5-1">第5章-1 用构造器确保初始化</a></h2><blockquote>
<p>可以假想为编写的每个类都定义一个<code>initialize()</code>方法，该方法的名称提醒你在使用其对象之前，应首先调用<code>initialize()</code>。然而，这同时意味着用户必须记得自己去调用此方法。</p>
</blockquote>
<p>在&thinsp;Java&thinsp;中，<u>通过提供构造器，类的设计者可以确保每个对象都会得到初始化</u>。创建对象时，如果其类具有构造器，Java&thinsp;就会在用户能够操作对象之前自动调用相应的构造器，从而保证了初始化的顺利进行。</p>
<blockquote>
<p>接下来的问题就是如何命名这个方法，2个考虑点：<br>①&ensp;构造器按照方法命名规范所取的任何名字，都可能与类的某个成员名称冲突；<br>②&ensp;调用构造器是编译器的责任，所以必须让编译器知道构造器对应哪一个方法。</p>
</blockquote>
<p>C++&thinsp;中采用了的解决方案看起来是最简单且更符合逻辑的，所以&thinsp;Java&thinsp;中也采用了这种方案：<u>构造器采用与类相同的名称</u>（<u>符合类的命名规范，但不符合方法的命名规范</u>）。</p>
<blockquote>
<p>注意，由于构造器名称必须与类名完全一致，所以“每个方法首字母小写”的编码风格并不适用于构造器。</p>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>以下是一个带有构造器的简单类……</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>以下是一个带有构造器的简单类：<br>……<br>现在，在创建对象时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Rock()</span><br></pre></td></tr></table></figure>
<p>将会为对象分配存储空间，并调用相应的构造器。这就保证了在你能操作对象之前，它已经被恰当地初始化了。</p>
<ul>
<li><p><strong>默认构造器</strong>（<strong>无参构造器</strong>）：不接收形式参数的构造器。</p>
</li>
<li><p><strong>有参构造器</strong>。如果<code>Tree(int)</code>是<code>Tree</code>类中唯一的构造器，那么编译器将不会允许你以其他任何方式创建<code>Tree</code>对象。</p>
</li>
<li><p><strong>构造器</strong>&thinsp;有助于减少错误，并使代码更易阅读。从概念上讲，“<strong>初始化</strong>”与“<strong>创建</strong>”是彼此独立的，然而在上面的代码中，你却找不到对<code>initialize()</code>方法的明确调用。<u>在&thinsp;Java&thinsp;中，“<strong>初始化</strong>”和“<strong>创建</strong>”是捆绑在一起，不可分离的</u>。</p>
</li>
<li><p><u><strong>构造器</strong>&thinsp;是一种特殊类型的<strong>方法</strong>，因为它<strong>没有返回值</strong></u>。<br>这与&thinsp;<strong>返回值为空</strong>（<strong>void</strong>）&thinsp;明显不同。对于空返回值，尽管方法本身不会自动返回什么，但仍可选择让它返回别的东西；<strong>构造器</strong>&thinsp;则不会返回任何东西，你别无选择（<strong>new</strong>&thinsp;表达式确实返回了对新建对象的引用，但<strong>构造器</strong>本身并没有返回任何值）。假如构造器具有返回值，并且允许程序员自行选择返回类型，那么势必得让编译器知道该如何处理此返回值。</p>
</li>
</ul>
 
    </div></div>
    </div>

<h2 id="第5章-2-方法重载"><a href="#第5章-2-方法重载" class="headerlink" title="第5章-2 方法重载"></a><a href="#index_5-2">第5章-2 方法重载</a></h2><blockquote>
<p>任何程序设计语言都具备一项重要特性，就是对<strong>名字</strong>的运用。</p>
<ul>
<li><u>当创建一个<strong>对象</strong>时，也就是给这个对象分配到的<strong>存储空间</strong>取了一个<strong>名字</strong></u>。</li>
<li><u>所谓<strong>方法</strong>就是给某个<strong>动作</strong>取的名字</u>。</li>
</ul>
<p>通过使用名字，你可以引用所有的对象和方法。</p>
<p>名字起的好可以更易于理解和修改。</p>
</blockquote>
<h2 id="第5章-3-默认构造器"><a href="#第5章-3-默认构造器" class="headerlink" title="第5章-3 默认构造器"></a><a href="#index_5-3">第5章-3 默认构造器</a></h2><p><font color="#6AA84F"><strong>默认构造器</strong></font>（又称&thinsp;<font color="#6AA84F"><strong>无参构造器</strong></font>）是没有形式参数的，<u>它的作用是<strong>创建</strong>一个默认对象</u>。</p>
<blockquote>
<p>如果一个类中没有构造器，则编译器会自动创建一个该类的默认构造器；而如果类中已经定义了构造器（无论是否有参数），则编译器不会再为该类创建默认构造器。</p>
</blockquote>
<h2 id="第5章-4-this关键字"><a href="#第5章-4-this关键字" class="headerlink" title="第5章-4 this关键字"></a><a href="#index_5-4">第5章-4 this关键字</a></h2><p><u>方法调用时，往往需要指定&thinsp;<strong>对象</strong></u>（<u><code>static</code>方法&thinsp;还可以直接指定&thinsp;<strong>类</strong><code>class</code></u>）。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
<p>同一个类型的对象，a&thinsp;和&thinsp;b，想要让它们都能调用同一个方法<code>peel()</code>，该如何实现？</p>
 
    </div></div>
    </div>

<p>在&thinsp;Java&thinsp;中，使用了简便且面向对象的语法来编写代码 —— 即“<strong>发送消息给对象</strong>”，编译器做了一些幕后处理 —— 它将“<strong>所操作对象的引用</strong>”作为第一个&thinsp;<strong>参数</strong>&thinsp;传递给&thinsp;<strong>方法</strong>。</p>
<blockquote>
<p>所以，示例中的方法调用代码可以如下解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.peel();</span><br><span class="line">a.peel(<span class="number">1</span>);</span><br><span class="line">b.peel();</span><br><span class="line">b.peel(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>↓ 以下是内部的表现形式（注意：不符合编码规范，编译会报错）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//=== (不符合编码规范，编译会报错) ===//</span></span><br><span class="line">Banana.peel(a);</span><br><span class="line">Banana.peel(a,<span class="number">1</span>);</span><br><span class="line">Banana.peel(b);</span><br><span class="line">Banana.peel(b,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//======//</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><font color="#CC0000"><strong>this</strong></font>&thinsp;关键字为此而生，它表示<u><strong>对</strong>“<strong>调用方法的那个对象</strong>”<strong>的引用</strong></u>，且<u>只能在&thinsp;<font color="#2D2DFF"><strong>方法内部</strong></font>&thinsp;使用</u>（指代<u>发起方法调用时，该方法对应的对象</u>）。</p>
<blockquote>
<ul>
<li><p><strong>this</strong>&thinsp;的用法与其他对象引用并无不同。<br>注意，如果在方法内部调用同一个类的另一个方法，不必使用&thinsp;<strong>this</strong>，直接调用即可。</p>
</li>
<li><p>只有当需要明确指出<strong>对当前对象的引用时</strong>，才需要使用&thinsp;<strong>this</strong>&thinsp;关键字。例如，当需要返回对当前对象的引用时，就可以这样写：<br>……</p>
</li>
<li><p><strong>this</strong>&thinsp;引用对于将当前对象传递给其他方法也很有用。<br>……</p>
</li>
</ul>
</blockquote>
<h3 id="第5章-4-1-在构造器中调用构造器"><a href="#第5章-4-1-在构造器中调用构造器" class="headerlink" title="第5章-4-1 在构造器中调用构造器"></a><a href="#index_5-4-1">第5章-4-1 在构造器中调用构造器</a></h3><p>调用形式：<code>this(</code>参数类型列表<code>)</code></p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>例子：</span></div>
    <div class="xContent"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<ul>
<li><p><u>在&thinsp;<font color="#6AA84F"><strong>构造器</strong></font>&thinsp;中，<font color="#2D2DFF"><strong>最多只能调用一次&thinsp;构造器</strong></font></u>。（否则编译报错）</p>
</li>
<li><p><u>在&thinsp;<font color="#6AA84F"><strong>构造器</strong></font>&thinsp;中，[&thinsp;<font color="#2D2DFF"><strong>调用构造器&thinsp;的代码</strong></font>&thinsp;]&thinsp;必须在&thinsp;<font color="#2D2DFF"><strong>最开始的地方</strong></font></u>。（否则编译报错）</p>
</li>
<li><p>这个例子中也展示了&thinsp;<u><strong>this</strong>&thinsp;的另一种用法&ensp;——&ensp;<strong>避免歧义</strong></u>。</p>
<blockquote>
<p>由于参数<code>s</code>的名称和数据成员<code>s</code>的名称相同，同时使用会产生歧义；使用<code>this.s</code>来代表数据成员就能解决这个问题。</p>
</blockquote>
</li>
</ul>
<h3 id="第5章-4-2-static的含义"><a href="#第5章-4-2-static的含义" class="headerlink" title="第5章-4-2 static的含义"></a><a href="#index_5-4-2">第5章-4-2 static的含义</a></h3><p>了解<code>this</code>关键字以后，就能更好地理解<code>static</code>（<font color="#CC0000"><strong>静态</strong></font>）<font color="#CC0000"><strong>方法</strong></font>的含义。</p>
<ul>
<li><p><u><code>static</code><font color="#6AA84F"><strong>方法</strong></font>&thinsp;中不能使用&thinsp;<code>this</code></u>。</p>
<blockquote>
<p>使用<code>static</code>方法时，由于不存在<code>this</code>，所以它不是通过“向对象发送消息”来完成的。</p>
</blockquote>
</li>
<li><p><u><code>static</code><font color="#6AA84F"><strong>方法</strong></font>&thinsp;中不能（直接）调用&thinsp;<font color="#2F2FFF"><strong>非静态方法</strong></font>&thinsp;和&thinsp;<font color="#2F2FFF"><strong>非静态对象</strong></font></u>（涉及到底层加载顺序）；而&thinsp;非静态方法&thinsp;中可以调用&thinsp;静态方法&thinsp;和&thinsp;静态对象。</p>
</li>
<li><p><u><code>static</code><font color="#6AA84F"><strong>方法</strong></font>&thinsp;的&thinsp;<strong>加载</strong>&thinsp;是依附于&thinsp;<strong>类</strong><code>class</code>&thinsp;而不是&thinsp;<strong>类的对象</strong><code>Object</code></u>：可以在没有创建任何对象的前提下，通过&thinsp;<strong>类</strong>本身&thinsp;来调用<code>static</code>方法，这正是<u><code>static</code>方法&thinsp;的主要用途</u>。</p>
<blockquote>
<p><code>static</code>方法很像&thinsp;全局方法；Java&thinsp;中禁止使用全局方法，但你在<code>static</code>方法中就能访问其他<code>static</code>方法&thinsp;和&thinsp;<code>static</code>域。</p>
</blockquote>
</li>
</ul>
<h2 id="第5章-5-清理：终结处理和垃圾回收"><a href="#第5章-5-清理：终结处理和垃圾回收" class="headerlink" title="第5章-5 清理：终结处理和垃圾回收"></a><a href="#index_5-5">第5章-5 清理：终结处理和垃圾回收</a></h2><p>在&thinsp;Java&thinsp;中，有&thinsp;<strong>垃圾回收器</strong>&thinsp;负责回收无用对象占据的<strong>内存资源</strong>。但也有特殊情况，由于&thinsp;<strong>垃圾回收器</strong>&thinsp;只能释放那些经由<code>new</code>分配的内存，所以那些不使用<code>new</code>获得的特殊内存将不会被垃圾回收器正常处理释放。</p>
<p>为了应对这种情况，Java&thinsp;允许在类中定义一个名为<code>finalize()</code>的方法。<br>……</p>
<p>Java&thinsp;中的&thinsp;垃圾回收：</p>
<ol>
<li><strong>对象</strong>&thinsp;可能不被&thinsp;<strong>垃圾回收</strong>。</li>
<li><strong>垃圾回收</strong>&thinsp;不等于“<strong>析构</strong>”。</li>
<li><strong>垃圾回收</strong>&thinsp;只与&thinsp;<strong>内存</strong>&thinsp;有关。</li>
</ol>
<p>……</p>
<h3 id="第5章-5-1-finalize-的用途何在"><a href="#第5章-5-1-finalize-的用途何在" class="headerlink" title="第5章-5-1 finalize()的用途何在"></a><a href="#index_5-5-1">第5章-5-1 finalize()的用途何在</a></h3><p>此时，已经明确了不该将<code>finalize()</code>作为通用的清理方法，那么<code>finalize()</code>真正的用途是什么呢？</p>
<p><u>垃圾回收只与内存有关</u><br>……</p>
<h3 id="第5章-5-2-你必须实施清理"><a href="#第5章-5-2-你必须实施清理" class="headerlink" title="第5章-5-2 你必须实施清理"></a><a href="#index_5-5-2">第5章-5-2 你必须实施清理</a></h3><p>……</p>
<h3 id="第5章-5-3-终结条件"><a href="#第5章-5-3-终结条件" class="headerlink" title="第5章-5-3 终结条件"></a><a href="#index_5-5-3">第5章-5-3 终结条件</a></h3><p>……</p>
<h3 id="第5章-5-4-垃圾回收器如何工作"><a href="#第5章-5-4-垃圾回收器如何工作" class="headerlink" title="第5章-5-4 垃圾回收器如何工作"></a><a href="#index_5-5-4">第5章-5-4 垃圾回收器如何工作</a></h3><p>……</p>
<h2 id="第5章-6-成员初始化"><a href="#第5章-6-成员初始化" class="headerlink" title="第5章-6 成员初始化"></a><a href="#index_5-6">第5章-6 成员初始化</a></h2><p>Java&thinsp;尽力保证：所有变量在使用前都能得到恰当的&thinsp;初始化。<u>Java&thinsp;不允许使用&thinsp;<font color="#4343FF"><strong>方法的局部变量</strong></font></u>。<br>……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">t</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  i++; <span class="comment">// Error --  Variable &#x27;i&#x27; might not have been initialized</span></span><br><span class="line">  a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u><strong>方法中定义的变量</strong>&thinsp;没有初值，但是&thinsp;<strong>类的数据成员</strong>（即字段）会有&thinsp;<strong>默认值</strong></u>。<br>……</p>
<p>在&thinsp;<strong>类</strong>&thinsp;中定义一个&thinsp;<strong>对象引用</strong>&thinsp;时，如果不将其&thinsp;<strong>初始化</strong>，此引用会获得一个特殊值<code>null</code>。<br>类中定义的&thinsp;<strong>基本数据类型</strong>，会有&thinsp;<strong>对应类型的默认值</strong>。</p>
<h3 id="第5章-6-1-指定初始化"><a href="#第5章-6-1-指定初始化" class="headerlink" title="第5章-6-1 指定初始化"></a><a href="#index_5-6-1">第5章-6-1 指定初始化</a></h3><h2 id="第5章-7-构造器初始化"><a href="#第5章-7-构造器初始化" class="headerlink" title="第5章-7 构造器初始化"></a><a href="#index_5-7">第5章-7 构造器初始化</a></h2><p>可以用构造器来进行初始化。</p>
<p>在运行时刻，可以调用方法或者执行某些动作来确定初值，这为编程带来了极大的便利性。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>但要牢记：无法阻止自动初始化的进行，它将在构造器被调用之前发生。</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>因此假如使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  Test() &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i = <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Test t = <span class="keyword">new</span> Test();</span><br><span class="line">    System.out.println(t.i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么类<code>Test</code>的数据成员（字段）<code>i</code>会首先被置为<code>0</code>（<strong>默认值</strong>），然后<u>被&thinsp;构造器&thinsp;置为<code>7</code></u>。<br>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>
<p><u>对于所有&thinsp;<strong>基本类型</strong>&thinsp;和&thinsp;<strong>对象引用</strong>，包括&thinsp;在定义时&thinsp;直接指定初值的变量，这种情况都是成立的</u>。</p>
 
    </div></div>
    </div>

<h3 id="第5章-7-1-初始化顺序"><a href="#第5章-7-1-初始化顺序" class="headerlink" title="第5章-7-1 初始化顺序"></a><a href="#index_5-7-1">第5章-7-1 初始化顺序</a></h3><p>在[&thinsp;<font color="#FFC000"><strong>类的内部</strong></font>&thinsp;]，<u><font color="#92D050"><strong>变量定义的顺序</strong></font>&thinsp;决定了&thinsp;<font color="#92D050"><strong>初始化的顺序</strong></font></u>；并且，<u><font color="#4343FF"><strong>变量的初始化</strong></font>（默认值）&thinsp;会在&thinsp;<font color="#4343FF"><strong>任何方法</strong></font>（包括构造器）被调用之前</u>。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h3 id="第5章-7-2-静态数据的初始化"><a href="#第5章-7-2-静态数据的初始化" class="headerlink" title="第5章-7-2 静态数据的初始化"></a><a href="#index_5-7-2">第5章-7-2 静态数据的初始化</a></h3><p><u>无论创建多少个<strong>对象</strong>，<strong>静态数据</strong>&thinsp;都只占用一份存储区域</u>。</p>
<blockquote>
<p><u><code>static</code>关键字不能应用于&thinsp;<strong>局部变量</strong>，因此它只能作用于&thinsp;<strong>域</strong></u>。</p>
</blockquote>
<ul>
<li><p>如果一个&thinsp;<strong>域</strong>&thinsp;是&thinsp;<font color="#4343FF"><strong>静态的</strong></font><font color="#92D050"><strong>基本类型</strong></font><font color="#4343FF"><strong>域</strong></font>，且没有被&thinsp;初始化，那么它就会被自动赋予&thinsp;<strong>默认值</strong>（基本类型 → 对应类型的默认值，引用类型 → <code>null</code>）。</p>
</li>
<li><p>如果想在&thinsp;定义处&thinsp;进行初始化，采取的方法和&thinsp;非静态数据&thinsp;没什么不同。</p>
</li>
</ul>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>要想了解静态存储区域是何时初始化的，需要用到下面这个例子：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
<p>……<br>由输出可见，<strong>静态初始化</strong>&thinsp;只有在必要时刻才会进行。……</p>
<p><strong>初始化的顺序</strong>&thinsp;是先&thinsp;<strong>静态对象</strong>（如果它们尚未因排序在前的对象创建而被初始化），而后是&thinsp;<strong>非静态对象</strong>。……</p>
 
    </div></div>
    </div>

<h3 id="总结一下对象创建的过程（书中的总结不够好，详见习题）"><a href="#总结一下对象创建的过程（书中的总结不够好，详见习题）" class="headerlink" title="总结一下对象创建的过程（书中的总结不够好，详见习题）"></a>总结一下对象创建的过程（书中的总结不够好，详见习题）</h3><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>假设有个名为&thinsp;Dog&thinsp;的类：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ol>
<li><p><u>首次<strong>创建</strong>&thinsp;类型为<code>Dog</code>的&thinsp;<strong>对象</strong>&thinsp;时</u>，或者<u><code>Dog</code>类的&thinsp;，<font color="#4343FF"><strong>静态方法</strong></font>&thinsp;/&thinsp;<font color="#4343FF"><strong>静态域</strong></font>&thinsp;首次被<strong>访问</strong>时</u>，<strong>Java&thinsp;解释器</strong>&thinsp;将会查找类的路径，定位<code>Dog.class</code>文件。</p>
</li>
<li><p>载入<code>Dog.class</code>（后面章节会提及，这将&thinsp;创建一个对象），有关&thinsp;<u><font color="#CC0000"><strong>静态初始化</strong></font>&thinsp;的所有动作都会执行</u>。</p>
<ul>
<li>因此，<u><font color="#CC0000"><strong>静态初始化</strong></font>&thinsp;只在<code>Class</code><font color="#6AA84F"><strong>对象</strong></font>&thinsp;首次加载时&thinsp;进行一次</u>。</li>
</ul>
</li>
<li><p>当用<code>new Dog()</code>创建对象的时候：</p>
<ul>
<li>首先，将&thinsp;<u>在<font color="#CC0000"><strong>堆</strong></font>上</u>&thinsp;为<code>Dog</code>对象&thinsp;<strong>分配</strong>&thinsp;足够的存储空间。<br>🡇</li>
<li><u>这块存储空间会被清零</u>，这就自动地将<code>Dog</code><u>对象中的&thinsp;<strong>所有<font color="#6AA84F">基本类型</font>数据</strong>&thinsp;都设置成了&thinsp;<font color="#4343FF"><strong>默认值</strong></font></u>。<br>🡇</li>
<li>然后，<u>执行所有出现于&thinsp;<strong>字段定义处</strong>&thinsp;的&thinsp;<strong>初始化动作</strong></u>。<br>🡇</li>
<li>最后，<u>执行&thinsp;<font color="#6AA84F"><strong>构造器</strong></font></u>。正如第7章所看到的，这可能会涉及到很多动作，尤其是涉及到&thinsp;<font color="#CC0000"><strong>继承</strong></font>&thinsp;的时候。</li>
</ul>
</li>
</ol>
 
    </div></div>
    </div>

<h3 id="第5章-7-3-显式的静态初始化"><a href="#第5章-7-3-显式的静态初始化" class="headerlink" title="第5章-7-3 显式的静态初始化"></a><a href="#index_5-7-3">第5章-7-3 显式的静态初始化</a></h3><p>Java&thinsp;允许将多个&thinsp;<font color="#4343FF"><strong>静态初始化动作</strong></font>&thinsp;组织成一个特殊的“静态子句”（有时也叫做“<font color="#CC0000"><strong>静态块</strong></font>”）。</p>
<p>语法形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">7</span>;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管上面的代码看起来像个方法，但它实际上只是一段跟在<code>static</code>关键字后面的代码；与其他初始化动作一样，这段代码仅会执行一次。</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h3 id="第5章-7-4-非静态实例初始化"><a href="#第5章-7-4-非静态实例初始化" class="headerlink" title="第5章-7-4 非静态实例初始化"></a><a href="#index_5-7-4">第5章-7-4 非静态实例初始化</a></h3><p>Java&thinsp;中也有被称为&thinsp;<font color="#CC0000"><strong>实例初始化</strong></font>&thinsp;的类似语法，用来初始化每一个对象的&thinsp;<strong>非静态变量</strong>。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Mug(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Mug(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;f(&quot;</span> + marker + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Mug mug1;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> Mug mug2;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">    mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Test() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Test()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Test(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Test(int)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.prinln(<span class="string">&quot;Inside main()&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Test();</span><br><span class="line">    System.out.prinln(<span class="string">&quot;new Test() completed!&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> Test(<span class="number">1</span>);</span><br><span class="line">    System.out.prinln(<span class="string">&quot;new Test(1) completed!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Inside main</span><br><span class="line">Mug(<span class="number">1</span>)</span><br><span class="line">Mug(<span class="number">2</span>)</span><br><span class="line">mug1 &amp; mug2 initialized!</span><br><span class="line">Test()</span><br><span class="line"><span class="keyword">new</span> Test() completed!</span><br><span class="line">Mug(<span class="number">1</span>)</span><br><span class="line">Mug(<span class="number">2</span>)</span><br><span class="line">mug1 &amp; mug2 initialized!</span><br><span class="line">Test(<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">new</span> Test(<span class="number">1</span>) completed!</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div>
<p>⤷你可以看到&thinsp;<font color="#CC0000"><strong>实例初始化子句</strong></font>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">  mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;mug1 &amp; mug2 initialized!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⤷它看起来与静态初始化子句一样，只不过少了<code>static</code>关键字。这种语法对于支持“<font color="#CC0000"><strong>匿名内部类</strong></font>”（参见第10章）是必须的，但是它也使得<u>无论你调用哪个显式构造器，某些操作都会发生</u>。</p>
<p>从输出中可以看到，<u><font color="#6AA84F"><strong>实例初始化子句</strong></font>&thinsp;是在两个&thinsp;<strong>构造器</strong>&thinsp;之前执行的</u>。</p>
<h2 id="第5章-8-数组初始化"><a href="#第5章-8-数组初始化" class="headerlink" title="第5章-8 数组初始化"></a><a href="#index_5-8">第5章-8 数组初始化</a></h2><h3 id="数组→概念"><a href="#数组→概念" class="headerlink" title="数组→概念"></a>数组→概念</h3><p><font color="#6AA84F"><strong>数组</strong></font>&thinsp;是&thinsp;<u>用一个&thinsp;<strong>标识符名称</strong>&thinsp;封装到一起的</u>、<u><strong>相同类型</strong>的</u>&thinsp;[&thinsp;一个&thinsp;<strong><font color="#4343FF">对象</font>序列</strong>&thinsp;或&thinsp;<strong><font color="#4343FF">基本类型</font>数据序列</strong>&thinsp;]。</p>
<h3 id="数组→定义和使用"><a href="#数组→定义和使用" class="headerlink" title="数组→定义和使用"></a>数组→定义和使用</h3><p><font color="#6AA84F"><strong>数组</strong></font>&thinsp;是&thinsp;通过方括号下标操作符<code>[]</code>来&thinsp;定义和使用的。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>要定义一个数组……</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>要定义一个数组，只需在&thinsp;类型名&thinsp;后面加上一对方括号<code>[]</code>即可（或许更合理）：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br></pre></td></tr></table></figure>
<p>也可以将方括号<code>[]</code>置于标识符后面（符合C和C++程序员的习惯）：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a1[];</span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div>

<h3 id="数组→特点"><a href="#数组→特点" class="headerlink" title="数组→特点"></a>数组→特点</h3><ul>
<li><p>编译器不允许指定&thinsp;<font color="#4343FF"><strong>数组的大小</strong></font>。这是因为数组是一组&thinsp;<u>对象的引用</u>（Java&thinsp;中&thinsp;<u>对象引用本身</u>&thinsp;是不变的，但是&thinsp;<u>所引用的对象</u>&thinsp;是可变的），所以&thinsp;<font color="#FFC000">声明时</font>&thinsp;无法指定数组的成员数量，但是&thinsp;<font color="#FFC000">创建时</font>&thinsp;不受限制。</p>
</li>
<li><p>所有数组都有一个&thinsp;<font color="#4343FF"><strong>固有成员</strong></font><code>length</code>……</p>
</li>
</ul>
<h3 id="数组初始化的3种方式"><a href="#数组初始化的3种方式" class="headerlink" title="数组初始化的3种方式"></a>数组初始化的3种方式</h3><ol>
<li><p>（只能在&thinsp;<font color="#FFC000">创建数组的地方</font>&thinsp;使用）<strong>花括号</strong><code>&#123;&#125;</code>&ensp;+&ensp;<font color="#6AA84F"><strong>数组成员</strong></font>。<br>此时存储空间的分配（等价于使用<code>new</code>）将由编译器负责：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>new</code>&ensp;+&ensp;<font color="#6AA84F"><strong>类型说明</strong></font>&ensp;+&ensp;<font color="#6AA84F"><strong>成员数量说明</strong></font>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i 为【不小于0的 int 类型参数】</span></span><br><span class="line"><span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[i];</span><br></pre></td></tr></table></figure>
<ul>
<li><p>演示：</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>👆</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// int[] a1 = new int[-1]; // Error -- java.lang.NegativeArraySizeException</span></span><br><span class="line">  <span class="keyword">int</span>[] a1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  System.out.prinln(a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[I@7adf9f5f</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div></li>
<li><p>示例：</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>👆</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div></li>
<li><p>初始化进程说明&ensp;→&ensp;此时，即便使用<code>new</code>创建数组之后：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)]</span><br></pre></td></tr></table></figure>
<p>⤷&ensp;它还只是一个&thinsp;<font color="#6AA84F"><strong>引用数组</strong></font>，直到通过创建新的<code>Integer</code>对象（本例中通过&thinsp;自动包装机制&thinsp;创建），并<u>把&thinsp;<strong>对象</strong>&thinsp;赋值给&thinsp;<strong>引用</strong></u>，<font color="#6AA84F"><strong>初始化进程</strong></font>&thinsp;才算结束。⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] = rand.nextInt(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>⤷&ensp;如果忘记了创建对象，并且试图使用数组中的空引用，就会出现运行时异常。</p>
</li>
</ul>
</li>
<li><p><code>new</code>&ensp;+&ensp;<font color="#6AA84F"><strong>类型说明</strong></font>&ensp;+&ensp;<strong>花括号</strong><code>&#123;&#125;</code>&ensp;+&ensp;<font color="#6AA84F"><strong>数组成员</strong></font>：⤵</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>演示：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Integer[] a;</span><br><span class="line">  a = <span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Integer(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Integer[] b = <span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">new</span> Integer(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">// Autoboxing</span></span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  System.out.println(Arrays.toString(a));</span><br><span class="line">  System.out.println(Arrays.toString(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div></li>
</ol>
<h3 id="第5章-8-1-可变参数列表"><a href="#第5章-8-1-可变参数列表" class="headerlink" title="第5章-8-1 可变参数列表"></a><a href="#index_5-8-1">第5章-8-1 可变参数列表</a></h3><ul>
<li><p>“<code>new</code>&ensp;+&ensp;<font color="#6AA84F"><strong>类型说明</strong></font>&ensp;+&ensp;<strong>花括号</strong><code>&#123;&#125;</code>&ensp;+&ensp;<font color="#6AA84F"><strong>数组成员</strong></font>”形式的&thinsp;数组初始化方法，可以用于<code>Object</code>数组实现与&thinsp;C&thinsp;的&thinsp;<strong>可变参数列表</strong>&thinsp;一样的效果。⤵</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>⤷&ensp;示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : args) &#123;</span><br><span class="line">      System.out.println(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;</span><br><span class="line">      <span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.14</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>),</span><br><span class="line">    &#125;);</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">    printArray(<span class="keyword">new</span> Object[]&#123;<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⤷&ensp;输出：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">11.11</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">com.suite.A@7adf9f5f</span><br><span class="line">com.suite.A@85ede7b</span><br><span class="line">com.suite.A@5674cd4d</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div>
<p>在&thinsp;Java&thinsp;SE&thinsp;5&thinsp;之前，通常使用上例来实现；而从&thinsp;Java&thinsp;SE&thinsp;5&thinsp;开始，提供了对&thinsp;<font color="#6AA84F"><strong>可变参数</strong></font>&thinsp;的语法支持。有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上将会自动填充数组。⤵</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>⤷&ensp;示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object obj : args) &#123;</span><br><span class="line">      System.out.println(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    printArray(<span class="keyword">new</span> Integer(<span class="number">47</span>), <span class="keyword">new</span> Float(<span class="number">3.14</span>), <span class="keyword">new</span> Double(<span class="number">11.11</span>));</span><br><span class="line">    printArray(<span class="number">47</span>, <span class="number">3.14F</span>, <span class="number">11.11</span>);</span><br><span class="line">    printArray(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">    printArray(<span class="keyword">new</span> A(), <span class="keyword">new</span> A(), <span class="keyword">new</span> A());</span><br><span class="line">    printArray((Object[]) <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    <span class="comment">// 【Tips】Empty list is ok</span></span><br><span class="line">    printArray();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">11.11</span></span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">11.11</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">com.suite.A@7adf9f5f</span><br><span class="line">com.suite.A@85ede7b</span><br><span class="line">com.suite.A@5674cd4d</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div></li>
<li><p>在&thinsp;<font color="#6AA84F"><strong>可变参数列表</strong></font>&thinsp;中，可以使用&thinsp;<font color="#FFC000"><strong>任何类型的参数</strong></font>，包括&thinsp;基本类型（涉及到&thinsp;自动包装机制）。</p>
</li>
<li><p>如果&thinsp;<font color="#6AA84F"><strong>可变参数列表</strong></font>&thinsp;中&thinsp;没有任何参数（包括为空），则&thinsp;参数传递时&thinsp;转变为&thinsp;数据尺寸为0的&thinsp;<strong>指定类型数组</strong>。同样，<font color="#6AA84F"><strong>可变参数列表</strong></font>&thinsp;也能<u>直接接受&thinsp;<strong>对应类型的数组</strong></u>（此时编译期间将不会再做不必要的数据转换）。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>⤷&ensp;示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(args.getClass());</span><br><span class="line">    System.out.println(<span class="string">&quot; length &quot;</span> + args.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span>... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(args.getClass());</span><br><span class="line">    System.out.println(<span class="string">&quot; length &quot;</span> + args.length);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    f();</span><br><span class="line">    g(<span class="number">1</span>);</span><br><span class="line">    g();</span><br><span class="line">    System.out.println(<span class="string">&quot;int[]:&quot;</span> + <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>].getClass());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class [Ljava.lang.Character;</span><br><span class="line"> length <span class="number">1</span></span><br><span class="line">class [Ljava.lang.Character;</span><br><span class="line"> length <span class="number">0</span></span><br><span class="line">class [I</span><br><span class="line"> length <span class="number">1</span></span><br><span class="line">class [I</span><br><span class="line"> length <span class="number">0</span></span><br><span class="line">int[]:class [I</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div></li>
<li><p><font color="#6AA84F"><strong>可变参数列表</strong></font>&thinsp;不依赖于&thinsp;<font color="#4343FF"><strong>自动包装机制</strong></font>&ensp;🡄&ensp;实际上使用的是&thinsp;<strong>基本类型</strong><br>⤷&ensp;见示例最后一行→创建并打印出来的<code>int</code>数组（其中的<code>I</code>表示&thinsp;<strong>基本数据类型</strong>）。</p>
</li>
<li><p>然而，<font color="#6AA84F"><strong>可变参数列表</strong></font>&thinsp;与&thinsp;<font color="#4343FF"><strong>自动包装机制</strong></font>&thinsp;可以和谐共处。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>⤷&ensp;示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : args) &#123;</span><br><span class="line">      System.out.println(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="keyword">new</span> Integer(<span class="number">1</span>), <span class="keyword">new</span> Integer(<span class="number">2</span>));</span><br><span class="line">    f(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">    f(<span class="number">10</span>, <span class="keyword">new</span> Integer(<span class="number">11</span>), <span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>注意：你可以在&thinsp;<u>单一类型的<strong>参数列表</strong></u>&thinsp;中&thinsp;<u>将类型混合在一起</u>，而&thinsp;<strong>自动包装机制</strong>&thinsp;将有选择地将<code>int</code>参数提升为<code>Integer</code>。</p>
 
    </div></div>
    </div></li>
<li><p><font color="#6AA84F"><strong>可变参数列表</strong></font>&thinsp;使得&thinsp;<font color="#4343FF"><strong>重载</strong></font>过程&thinsp;变得复杂了，尽管乍一看似乎足够安全。</p>
<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>⤷&ensp;示例：</span></div>
    <div class="xContent"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Character... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Character c : args) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Integer... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer c : args) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Long... args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    f(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    f(<span class="number">1</span>);</span><br><span class="line">    f(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    f(<span class="number">0</span>);</span><br><span class="line">    f(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//! f(); // Won&#x27;t compile -- ambiguous</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">first a b c</span><br><span class="line">second <span class="number">1</span></span><br><span class="line">second <span class="number">2</span> <span class="number">1</span></span><br><span class="line">second <span class="number">0</span></span><br><span class="line">third</span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>⤷&ensp;在每一种情况中，编译器都会使用&thinsp;<font color="#4343FF"><strong>自动包装机制</strong></font>&thinsp;来匹配&thinsp;<font color="#6AA84F"><strong>重载方法</strong></font>。<br>⤷&ensp;但是在上例中，不传递参数，调用<code>f()</code>时，编译器就无法确定该调用哪个方法（编译不通过）。</p>
 
    </div></div>
    </div></li>
<li><p>可以考虑添加&thinsp;<font color="#6AA84F"><strong>非可变参数</strong></font>&thinsp;来解决&thinsp;<font color="#4343FF"><strong>重载方法</strong></font>之间&thinsp;<font color="#FFC000"><strong>可变参数列表混淆</strong></font>&thinsp;的问题。</p>
<blockquote>
<p>【设计原则】</p>
<ul>
<li>如果是&thinsp;<u>有必要在&thinsp;<font color="#4343FF"><strong>重载方法</strong></font>&thinsp;中使用&thinsp;<font color="#6AA84F"><strong>可变参数列表</strong></font></u>，请保证&thinsp;<u><font color="#FFC000"><strong>至多</strong></font>在<font color="#4343FF"><strong>重载方法</strong></font>的一个版本中</u>&thinsp;使用&thinsp;<font color="#6AA84F"><strong>可变参数列表</strong></font>，或者不使用它。</li>
<li>某些情况下，可以考虑使用&thinsp;恰当类型的<strong>数组</strong>&thinsp;来替代&thinsp;<font color="#6AA84F"><strong>可变参数列表</strong></font>。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="第5章-9-枚举类型"><a href="#第5章-9-枚举类型" class="headerlink" title="第5章-9 枚举类型"></a><a href="#index_5-9">第5章-9 枚举类型</a></h2><p>在&thinsp;Java&thinsp;SE&thinsp;5&thinsp;中添加了一个看似很小的新特性&ensp;——&ensp;<code>enum</code>关键字，它使得我们需要群组并使用&thinsp;<font color="#6AA84F"><strong>枚举类型</strong></font><strong>集</strong>&thinsp;时，可以很方便地处理。</p>
<blockquote>
<p>C&thinsp;/&thinsp;C++&thinsp;都有&thinsp;<font color="#6AA84F"><strong>枚举类型</strong></font>，现在&thinsp;Java&thinsp;也拥有&thinsp;<strong>枚举类型</strong>&thinsp;且比它们的要完备得多。</p>
</blockquote>
<h3 id="额外参考资料"><a href="#额外参考资料" class="headerlink" title="额外参考资料"></a>额外参考资料</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473188087424">枚举类 - 廖雪峰的官方网站</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/46dbd930f6a2">Java 中的枚举 (enum) - 简书</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/52180865">Java 枚举(enum) 详解7种常见的用法_请叫我大师兄-CSDN博客_枚举</a></p>
</li>
</ul>
<h3 id="第5章-9-1-枚举类（enum）——基本概念"><a href="#第5章-9-1-枚举类（enum）——基本概念" class="headerlink" title="第5章-9-1 枚举类（enum）——基本概念"></a><a href="#index_5-9-1">第5章-9-1 枚举类（enum）——基本概念</a></h3><ol>
<li><p><font color="#CC0000"><strong>枚举类</strong></font>：一种&thinsp;<strong>特殊的类</strong>，其&thinsp;<font color="#4343FF"><strong>实例对象</strong></font>&thinsp;是&thinsp;<font color="#FCC000"><strong>有限且固定的</strong></font>。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>枚举类（enum）的特点</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ol>
<li><p><font color="#6AA84F"><strong>枚举类</strong></font>&thinsp;和普通的类（<code>class</code>）一样，有自己的&thinsp;<strong>成员变量</strong>、<strong>成员方法</strong>、<strong>构造器</strong>（因为&thinsp;设计时&thinsp;限定使用<code>private</code>访问修饰符，故无法&thinsp;从外部&thinsp;调用&thinsp;枚举类的构造器，<u>只能&thinsp;<font color="#FCC000">在构造枚举值时</font>&thinsp;调用&thinsp;<strong>对应枚举类的构造器</strong></u>）。</p>
</li>
<li><p>与普通类（<code>class</code>）一样，一个&thinsp;Java&thinsp;源文件中最多只能有一个<code>public</code>类型的&thinsp;枚举类，且&thinsp;该&thinsp;Java&thinsp;源文件的名称&thinsp;必须与&thinsp;该枚举类的名称&thinsp;相同。</p>
</li>
<li><p><font color="#6AA84F"><strong>枚举类</strong></font>（<code>enum</code>）默认继承了<code>java.lang.Enum</code>类，并实现了 <code>java.lang.Seriablizable</code>和<code>java.lang.Comparable</code>两个接口。</p>
</li>
<li><p>⤷&ensp;<font color="#6AA84F"><strong>枚举类</strong></font>&thinsp;是<font color="#FCC000">非抽象的</font>，且<u><font color="#FCC000">不能再派生出子类</font></u>。</p>
<blockquote>
<p>尽管&thinsp;<strong>枚举类</strong>&thinsp;不能被继承，但是可以有&thinsp;<font color="#4343FF"><strong>抽象方法</strong></font>&ensp;🡆&ensp;<u><font color="#FCC000"><strong>枚举类的抽象方法</strong></font></u>&thinsp;<del>必须</del><u>必需被其每一个&thinsp;<font color="#6AA84F"><strong>枚举值</strong></font>&thinsp;实现</u>。</p>
</blockquote>
</li>
<li><p>所有的&thinsp;<font color="#6AA84F"><strong>枚举值</strong></font>&thinsp;都是&thinsp;限定<code>public static final</code>修饰的。</p>
</li>
</ol>
 
    </div></div>
    </div></li>
<li><p>在&thinsp;Java&thinsp;中，使用<code>enum</code>关键字来定义&thinsp;<font color="#6AA84F"><strong>枚举类</strong></font>；其地位与<code>class</code>和<code>interface</code>相同。</p>
</li>
<li><p><font color="#6AA84F"><strong>枚举类</strong></font>的&thinsp;<strong>所有实例</strong>，<u>必须在&thinsp;<font color="#FCC000"><strong>枚举类的第一行</strong></font>&thinsp;显式地列出</u>；否则这个&thinsp;<font color="#6AA84F"><strong>枚举类</strong></font>&thinsp;将&thinsp;<u>不能生成实例</u>。<br>⤷&ensp;同时，<u>编译器会自动地为&thinsp;<font color="#6AA84F"><strong>枚举值</strong></font>&thinsp;添加<code>public static final</code>修饰</u>，无需程序员显式添加。</p>
</li>
</ol>
<h3 id="第5章-9-2-枚举类的使用"><a href="#第5章-9-2-枚举类的使用" class="headerlink" title="第5章-9-2 枚举类的使用"></a><a href="#index_5-9-2">第5章-9-2 枚举类的使用</a></h3><p>……</p>
<ul>
<li>参看项目&thinsp;[&thinsp;<a target="_blank" rel="noopener" href="https://github.com/SuiteLHY/DingDing">SuiteLHY/DingDing - githun.com</a>&thinsp;]&thinsp;代码</li>
</ul>
<h2 id="第5章-10-总结"><a href="#第5章-10-总结" class="headerlink" title="第5章-10 总结"></a><a href="#index_5-10">第5章-10 总结</a></h2><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>类（class）的&thinsp;初始化顺序：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ol>
<li><font color="#FFC000"><strong>父类</strong></font>的&thinsp;<font color="#FF6699"><strong>静态</strong></font><font color="#6AA84F"><strong>成员变量</strong></font>&thinsp;和&thinsp;<font color="#FF6699"><strong>静态</strong></font><font color="#6AA84F"><strong>代码块</strong></font>（按&thinsp;声明先后顺序&thinsp;执行）；<br>🡇</li>
<li><font color="#FFC000"><strong>子类</strong></font>的&thinsp;<font color="#FF6699"><strong>静态</strong></font><font color="#6AA84F"><strong>成员变量</strong></font>&thinsp;和&thinsp;<font color="#FF6699"><strong>静态</strong></font><font color="#6AA84F"><strong>代码块</strong></font>（按&thinsp;声明先后顺序&thinsp;执行）；<br>🡇</li>
<li><ul>
<li><font color="#FFC000"><strong>父类</strong></font>的&thinsp;<font color="#FF6699"><strong>非静态</strong></font><font color="#6AA84F"><strong>成员变量</strong></font>&thinsp;和&thinsp;<font color="#FF6699"><strong>非静态</strong></font><font color="#6AA84F"><strong>代码块</strong></font>（按&thinsp;声明先后顺序&thinsp;执行）；<br>🡇</li>
<li><font color="#FFC000"><strong>父类</strong></font>的&thinsp;<font color="#6AA84F"><strong>构造方法</strong></font>；<br>🡇</li>
</ul>
</li>
<li><ul>
<li><font color="#FFC000"><strong>子类</strong></font>的&thinsp;<font color="#FF6699"><strong>非静态</strong></font><font color="#6AA84F"><strong>成员变量</strong></font>&thinsp;和&thinsp;<font color="#FF6699"><strong>非静态</strong></font><font color="#6AA84F"><strong>代码块</strong></font>（按&thinsp;声明先后顺序&thinsp;执行）；<br>🡇</li>
<li><font color="#FFC000"><strong>子类</strong></font>的&thinsp;<font color="#6AA84F"><strong>构造方法</strong></font>。</li>
</ul>
</li>
</ol>
 
    </div></div>
    </div>

<h1 id="第6章-访问权限控制"><a href="#第6章-访问权限控制" class="headerlink" title="第6章 访问权限控制"></a><a href="#index_6">第6章 访问权限控制</a></h1><p>访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。<br>……</p>
<p>为了解决这一问题，Java&thinsp;提供了&thinsp;<font color="#CC0000"><strong>访问权限修饰词</strong></font>，以供类库开发人员向客户端程序员指明哪些是可用的，哪些是不可用的。</p>
<p>访问权限的控制等级，从最大权限到最小权限依次为：<font color="#FCC000"><strong>public</strong></font>&ensp;🡆&ensp;<font color="#FCC000"><strong>protected</strong></font>&ensp;🡆&ensp;<font color="#FCC000">[&thinsp;包访问权限&thinsp;]（没有关键词）</font>&ensp;🡆&ensp;<font color="#FCC000"><strong>private</strong></font>。</p>
<p>……<br>对于这一点，Java&thinsp;用关键字<code>package</code>加以控制；而&thinsp;访问权限修饰词&thinsp;会因为&thinsp;类<code>class</code>是否在同一个包下&thinsp;而受到影响。</p>
<p>……</p>
<h2 id="第6章-1-包：库单元"><a href="#第6章-1-包：库单元" class="headerlink" title="第6章-1 包：库单元"></a><a href="#index_6-1">第6章-1 包：库单元</a></h2><p><strong>包</strong><code>package</code>内包含有一组&thinsp;[&thinsp;<strong>类</strong><code>class</code>&thinsp;/&thinsp;<strong>接口</strong><code>interface</code>&thinsp;/&thinsp;<strong>枚举</strong><code>enum</code>&thinsp;]，它们&thinsp;在单一的名字空间下&thinsp;被组织在了一起。<br>……</p>
<h3 id="第6章-1-1-代码组织"><a href="#第6章-1-1-代码组织" class="headerlink" title="第6章-1-1 代码组织"></a><a href="#index_6-1-1">第6章-1-1 代码组织</a></h3><blockquote>
<p>当编译一个<code>.java</code>文件时，在<code>.java</code>文件中的每个类都会有一个输出文件；该输出文件的名称与<code>.java</code>文件中的每个类的名称相同，且后缀名为<code>.class</code>。因此，在编译少量的<code>.java</code>文件之后，会得到大量的<code>.class</code>文件。</p>
<p>如果用编译型语言编写过程序，就会清楚：在传统的编译型语言中，编译器产生一个中间文件（通常是一个<code>obj</code>文件），然后再与通过链接器（用于创建一个可执行文件）或类库产生器（<code>librarian</code>，用以创建一个类库）产生的其他同类文件捆绑在一起。</p>
<p>然而&thinsp;Java&thinsp;的可运行程序，是一组可以打包并压缩为一个&thinsp;Java&thinsp;文档文件（JAR，使用&thinsp;Java&thinsp;的&thinsp;jar&thinsp;文档生成器）的<code>.class</code>文件。<br>⤷&ensp;<font color="#6AA84F"><strong>Java&thinsp;解释器</strong></font>&thinsp;负责这些文件的&thinsp;<strong>查找</strong>、<strong>装载</strong>&thinsp;和&thinsp;<strong>解释</strong>。</p>
</blockquote>
<p><font color="#6AA84F"><strong>类库</strong></font>&thinsp;实际上是一组类文件<code>.class</code>。其中每个文件都有一个<code>public</code>类，以及&thinsp;任意数量的&thinsp;<strong>非</strong><code>public</code><strong>类</strong>；因此每个文件都有一个构件。如果希望这些构件（每一个都有它们自己独立的<code>.java</code>和<code>.class</code>文件）从属于同一个群组，可以使用关键字<code>package</code>。</p>
<blockquote>
<p>如果使用<code>package</code>语句，它必须是&thinsp;文件中&thinsp;除注释以外的&thinsp;<font color="#FCC000"><strong>第一行程序代码</strong></font>。<br>在&thinsp;<strong>文件起始处</strong>&thinsp;写：⤵</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> access<span class="comment">/* 包的名称 */</span>;</span><br></pre></td></tr></table></figure>
<p>⤷&ensp;（请注意，Java&thinsp;包的命名规则是&thinsp;全部使用<strong>小写字母</strong>，包括中间的字母也是如此）</p>
<p>注意：关键字<code>import</code>与通配符<code>*</code>搭配，不能定位到命名空间下的包（不能保证没有冲突）。</p>
</blockquote>
<h3 id="第6章-1-2-创建独一无二的包名"><a href="#第6章-1-2-创建独一无二的包名" class="headerlink" title="第6章-1-2 创建独一无二的包名"></a><a href="#index_6-1-2">第6章-1-2 创建独一无二的包名</a></h3><blockquote>
<p>既然一个包&thinsp;从未真正地将&thinsp;被打包的东西&thinsp;包装成&thinsp;单一的文件，并且一个包可以由许多<code>.class</code>文件构成；那么仅仅是这样，就可能出现名称完全相同的<code>.class</code>文件混淆在一起。</p>
</blockquote>
<p>⤷&ensp;为了避免这种情况，Java&thinsp;将每个包的所有<code>.class</code>文件都置于独一无二的目录下。<br>……</p>
<h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>……</p>
<p>注意：<code>import</code>关键字&thinsp;和&thinsp;通配符<code>*</code>，不能定位指定命名空间下的包（<code>package</code>），因为没有分配资源去进行&thinsp;<strong>唯一性的校验</strong>，无法避免&thinsp;包名冲突。</p>
<h3 id="第6章-1-3-定制工具库"><a href="#第6章-1-3-定制工具库" class="headerlink" title="第6章-1-3 定制工具库"></a><a href="#index_6-1-3">第6章-1-3 定制工具库</a></h3><p>……</p>
<h3 id="第6章-1-4-用import改变行为"><a href="#第6章-1-4-用import改变行为" class="headerlink" title="第6章-1-4 用import改变行为"></a><a href="#index_6-1-4">第6章-1-4 用import改变行为</a></h3><p>……</p>
<h3 id="第6章-1-5-对使用包的忠告"><a href="#第6章-1-5-对使用包的忠告" class="headerlink" title="第6章-1-5 对使用包的忠告"></a><a href="#index_6-1-5">第6章-1-5 对使用包的忠告</a></h3><p>务必记住，无论何时创建&thinsp;<strong>包</strong>（<code>package</code>），都已经在给定&thinsp;<strong>包的名称</strong>&thinsp;的时候隐式地指定了目录结构。</p>
<h2 id="第6章-2-Java访问权限修饰词"><a href="#第6章-2-Java访问权限修饰词" class="headerlink" title="第6章-2 Java访问权限修饰词"></a><a href="#index_6-2">第6章-2 Java访问权限修饰词</a></h2><p>……</p>
<h2 id="第6章-3-接口和实现"><a href="#第6章-3-接口和实现" class="headerlink" title="第6章-3 接口和实现"></a><a href="#index_6-3">第6章-3 接口和实现</a></h2><blockquote>
<p><strong>访问权限的控制</strong>&thinsp;常被称为是&thinsp;<strong>具体实现的隐藏</strong>。</p>
</blockquote>
<p><font color="#CC0000"><strong>封装</strong></font>：把&thinsp;<font color="#6AA84F"><strong>数据</strong></font>&thinsp;和&thinsp;<font color="#6AA84F"><strong>方法</strong></font>&thinsp;包装进&thinsp;<strong>类</strong>（<code>class</code>）&thinsp;中，<font color="#FCC000">隐藏&thinsp;类</font>（<code>class</code>）<font color="#FCC000">的具体实现</font>。其结果是&thinsp;生成一个&thinsp;带有<strong>特征</strong>和<strong>行为</strong>的&thinsp;<strong>数据类型</strong>。</p>
<h3 id="使用封装的原因（好处）"><a href="#使用封装的原因（好处）" class="headerlink" title="使用封装的原因（好处）"></a>使用封装的原因（好处）</h3><p>在结构中建立内部机制，将公开的接口和具体实现分离。<br>⤴&ensp;<font color="#FCC000"><strong>隐藏实现细节，提供公共的访问方式</strong></font>。⤵</p>
<blockquote>
<ol>
<li><p>提高代码的<font color="#6AA84F"><strong>可维护性</strong></font>。</p>
</li>
<li><p>提高代码的<font color="#6AA84F"><strong>可重用性</strong></font>。</p>
</li>
<li><p>提高数据的<font color="#6AA84F"><strong>安全性</strong></font>。</p>
</li>
</ol>
</blockquote>
<h2 id="第6章-4-类的访问权限"><a href="#第6章-4-类的访问权限" class="headerlink" title="第6章-4 类的访问权限"></a><a href="#index_6-4">第6章-4 类的访问权限</a></h2><p>在&thinsp;Java&thinsp;中，<font color="#6AA84F"><strong>访问权限修饰词</strong></font>&thinsp;也可以用于&thinsp;确定库中的哪些类对于该库的使用者是可用的。</p>
<blockquote>
<p>如果希望某个类可以为客户端程序员所用，就可以通过把关键字<code>public</code>作用于整个类的定义来实现。<br>这样做甚至可以控制客户端程序员是否能创建一个该类的对象。</p>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>实现形式：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<ul>
<li><font color="#6AA84F"><strong>访问权限修饰词</strong></font>&thinsp;还有一些额外的限制：<blockquote>
<ol>
<li><p>每个编译单元（文件）都只能有一个<code>public</code>类。<br>⤷&ensp;这表示，每个编译单元&thinsp;都有一个&thinsp;唯一的公共接口，通过<code>public</code>实现。</p>
</li>
<li><p><code>public</code>类的名称必须完全与含有该编译单元的文件名一致（包括大小写）。</p>
</li>
<li><p>虽然不是很常用，但编译单元内完全不带<code>public</code>类也是可以的。<br>⤷&ensp;此时文件的命名不受限制。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="第6章-5-总结"><a href="#第6章-5-总结" class="headerlink" title="第6章-5 总结"></a><a href="#index_6-5">第6章-5 总结</a></h2><p>……</p>
<h1 id="第7章-复用类"><a href="#第7章-复用类" class="headerlink" title="第7章 复用类"></a><a href="#index_7">第7章 复用类</a></h1><blockquote>
<p><font color="#6AA84F"><strong>复用代码</strong></font>&thinsp;是&thinsp;Java&thinsp;众多引人注目的功能之一。但要想成为极具革命性的语言，仅仅能够复制代码并对之加以改变是不够的，它必须能够做更多的事情。</p>
</blockquote>
<p>在&thinsp;Java&thinsp;中，所有问题的解决都是围绕着&thinsp;类（<code>class</code>）&thinsp;展开的。可以通过创建新类来复用代码。此方法的窍门在于使用&thinsp;类&thinsp;而不破坏现有程序代码。</p>
<blockquote>
<ul>
<li><p>第1种实现方法非常直观：只需在新的类中创建现有类的对象。该方法只是复用了现有程序代码的功能，而非它的形式。由于新的类是由现有类的对象所组成，所以这种方法称为&thinsp;<font color="#6AA84F"><strong>组合</strong></font>。</p>
</li>
<li><p>第2种方法则更细致一些，它<u>按照现有类的类型来创建新类</u>，无需改变现有类的形式，采用现有类的形式，并在其基础上添加新的代码，这种方法被称为&thinsp;<font color="#6AA84F"><strong>继承</strong></font>。编译器完成其中绝大部分的工作。<font color="#6AA84F"><strong>继承</strong></font>&thinsp;是面向对象的基础之一。</p>
</li>
</ul>
</blockquote>
<h2 id="第7章-1-组合语法"><a href="#第7章-1-组合语法" class="headerlink" title="第7章-1 组合语法"></a><a href="#index_7-1">第7章-1 组合语法</a></h2><p>使用组合技术，只需要将对象引用置于新的类中即可。对于&thinsp;基本类型数据，可以直接定义；而对于&thinsp;非基本类型的对象，必须将其&thinsp;引用&thinsp;置于新的类中。</p>
<p>编译器并不会为每一个引用都创建默认对象，为的是避免不必要的负担（现在Java之父后悔了！声称：当初是因为实现简单才这样设计的；后来的使用中造成了至少10亿美元的损失）。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>如果想要初始化引用，可以在下列位置中进行：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ol>
<li>定义对象的地方。这意味着它们总是能够在被构造器调用之前被初始化。</li>
<li>类的构造器中。</li>
<li>在使用这些对象的代码之前，这种方式被称为惰性初始化。<br>&ensp;在声明的引用不必每次都生成对象的情况下，可以避免不必要的负担。</li>
<li>使用实例初始化。</li>
</ol>
 
    </div></div>
    </div>

<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h2 id="第7章-2-继承语法"><a href="#第7章-2-继承语法" class="headerlink" title="第7章-2 继承语法"></a><a href="#index_7-2">第7章-2 继承语法</a></h2><p>继承是所有&thinsp;OOP&thinsp;语言不可缺少的组成部分。</p>
<p>当创建一个类时，总是在&thinsp;继承；除非明确地指出要从其他类中继承，否则就是在隐式地从&thinsp;Java&thinsp;的标准根类<code>Object</code>进行继承。</p>
<p>继承的语法：……关键字<code>extends</code></p>
<h3 id="第7章-2-1-初始化基类"><a href="#第7章-2-1-初始化基类" class="headerlink" title="第7章-2-1 初始化基类"></a><a href="#index_7-2-1">第7章-2-1 初始化基类</a></h3><p><font color="#6AA84F"><strong>继承</strong></font>&thinsp;涉及到&thinsp;<font color="#6AA84F"><strong>基类</strong></font>（<strong>被继承的类</strong>，又称&thinsp;<font color="#6AA84F"><strong>父类</strong></font>、<font color="#6AA84F"><strong>超类</strong></font>）和&thinsp;<font color="#6AA84F"><strong>派生类</strong></font>（<strong>继承的类</strong>，又称&thinsp;<font color="#6AA84F"><strong>子类</strong></font>、<font color="#6AA84F"><strong>导出类</strong></font>）2个类。</p>
<blockquote>
<p>从外部看，派生类的对象&thinsp;就像是一个&thinsp;与基类具有相同接口的新类，或许还会有一些额外的&thinsp;<font color="#4343FF"><strong>方法</strong></font>&thinsp;和&thinsp;<font color="#4343FF"><strong>域</strong></font>。<br>但&thinsp;继承&thinsp;并不只是单纯地复制基类的接口。</p>
</blockquote>
<h4 id="Java会自动在派生类的构造器中插入对基类构造器的调用。"><a href="#Java会自动在派生类的构造器中插入对基类构造器的调用。" class="headerlink" title="Java会自动在派生类的构造器中插入对基类构造器的调用。"></a>Java会自动在<font color="#FCC000">派生类的构造器</font>中插入<font color="#FCC000">对基类构造器的调用</font>。</h4><blockquote>
<p><strong>当通过继承创建了一个派生类的对象时，该对象包含了一个基类（超类）的子对象</strong>。<br>⤷&ensp;其中，对基类的子对象的正确初始化也是至关重要的，而且有且仅有一种方法来保证这一点：<u>在&thinsp;<strong>派生类构造器</strong>&thinsp;中调用&thinsp;<strong>基类构造器</strong>&thinsp;来执行初始化，且&thinsp;<font color="#FCC000"><strong>必须&thinsp;在派生类构造器中&thinsp;最开始执行</strong></font></u>。</p>
</blockquote>
<blockquote>
<p>在设计上，基类的构造器&thinsp;具有&thinsp;执行基类初始化所需要的&thinsp;所有知识和能力，包括&thinsp;超类对象的&thinsp;构造器调用所必需的能力。</p>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h4 id="带参数的构造器"><a href="#带参数的构造器" class="headerlink" title="带参数的构造器"></a>带参数的构造器</h4><blockquote>
<p>上例中各个类均含有默认的构造器，即不带参数的构造器。</p>
<p>如果没有&thinsp;默认的&thinsp;基类构造器，或者想要&thinsp;调用一个&thinsp;带参数的&thinsp;基类构造器，就必须&thinsp;使用关键字<code>super</code>&thinsp;显式地编写&thinsp;调用基类构造器的语句，同时配以适当的&thinsp;参数列表。</p>
<p>需要格外注意的是：<u>在&thinsp;<strong>子类构造器</strong>&thinsp;中，对&thinsp;<strong>超类构造器</strong>&thinsp;的（显式）调用动作&thinsp;<font color="#FCC000">必须在最开始定义</font></u>。</p>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h3 id="【拓展】第7章-2-2-重写"><a href="#【拓展】第7章-2-2-重写" class="headerlink" title="【拓展】第7章-2-2 重写"></a><a href="#index_7-2-2">【拓展】第7章-2-2 重写</a></h3><blockquote>
<p>参考资料：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-override-overload.html">【runoob.com】Java 重写(Override)与重载(Overload)</a></p>
</blockquote>
<p><font color="#CC0000"><strong>重写</strong></font><strong>（</strong><font color="#CC0000"><strong>Override</strong></font><strong>）</strong>&thinsp;是&thinsp;子类对&thinsp;[&thinsp;父类中&thinsp;允许子类访问的方法&thinsp;]&thinsp;的实现过程&thinsp;进行重新编写（<font color="#FCC000"><strong>方法名</strong></font>、<font color="#FCC000"><strong>返回值</strong></font>、<font color="#FCC000"><strong>形参列表</strong></font>&thinsp;都保持一致，<font color="#FCC000"><strong>访问权限</strong></font>&thinsp;和&thinsp;<font color="#FCC000"><strong>抛出异常</strong></font>&thinsp;符合重写规则）。</p>
<p>在面向对象原则里，<strong>重写</strong>（<strong>Override</strong>）意味着可以重写任何现有的方法。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span><font color="#6AA84F">重写</font>（<font color="#6AA84F">Override</font>）的好处</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ul>
<li>子类可以根据自己的需要，定义特定于自己的行为（即子类能够根据需要实现父类的方法）。</li>
</ul>
 
    </div></div>
    </div>

<h4 id="重写（Override）规则"><a href="#重写（Override）规则" class="headerlink" title="重写（Override）规则"></a>重写（Override）规则</h4><ol>
<li><p><font color="#6AA84F"><strong>参数列表</strong></font>&thinsp;必须&thinsp;<u>与&thinsp;<strong>被重写的方法</strong>&thinsp;<font color="#FCC000"><strong>完全相同</strong></font></u>（<font color="#FCC000"><strong>参数个数</strong></font>、<font color="#FCC000"><strong>参数类型</strong></font>&thinsp;及其&thinsp;<font color="#FCC000"><strong>排列方式</strong></font>）。</p>
</li>
<li><p><font color="#6AA84F"><strong>访问权限</strong></font>&thinsp;对比&thinsp;父类中被重写的方法&thinsp;更高&thinsp;或&thinsp;相等。<br>⤷&ensp;例如：如果一个&thinsp;父类的方法&thinsp;被声明为<code>public</code>，那么&thinsp;子类中对应的重写方法&thinsp;就不能声明为<code>protected</code>。</p>
</li>
<li><p>父类中的方法&thinsp;只能&thinsp;被它的子类&thinsp;重写。</p>
</li>
<li><p><u>声明为<code>final</code>的方法</u>&thinsp;不能被重写。</p>
</li>
<li><p><u>声明为<code>static</code>的方法</u>&thinsp;不能被重写，但是能够&thinsp;被再次声明。</p>
<blockquote>
<ul>
<li><code>static</code>方法&thinsp;仅与&thinsp;<font color="#6AA84F"><strong>类</strong></font>（<code>class</code>）&thinsp;绑定，而不与&thinsp;<strong>类的具体对象</strong>&thinsp;绑定；</li>
<li><font color="#6AA84F"><strong>继承</strong></font>&thinsp;是描述&thinsp;对象之间的关系&thinsp;的概念。</li>
</ul>
<p>⤷&ensp;所以&thinsp;<code>static</code>方法&thinsp;与&thinsp;<font color="#6AA84F"><strong>重写</strong></font>（<font color="#6AA84F"><strong>Override</strong></font>）的概念&thinsp;搭不上边。</p>
</blockquote>
</li>
<li><p><font color="#4343FF"><strong>构造方法</strong></font>&thinsp;不能被重写。</p>
</li>
<li><p>如果不能&thinsp;<font color="#6AA84F"><strong>继承</strong></font>&thinsp;一个方法，则不能&thinsp;<font color="#6AA84F"><strong>重写</strong></font>&thinsp;这个方法。</p>
</li>
<li><p>如果&thinsp;子类和父类&thinsp;在<font color="#FCC000">同一个包</font>中，那么&thinsp;子类&thinsp;可以重写&thinsp;[&thinsp;父类中&thinsp;<u><font color="#FCC000">除了声明为<code>private</code>或<code>final</code>的</font></u>&thinsp;<strong>其他所有方法</strong>&thinsp;]。</p>
</li>
<li><p>如果&thinsp;子类和父类&thinsp;在<font color="#FCC000">不同的包</font>中，那么&thinsp;子类&thinsp;只能够重写&thinsp;[&thinsp;父类中&thinsp;<u><font color="#FCC000">声明为<code>public</code>或<code>protected</code>的</font></u>、<u><font color="#FCC000">非<code>final</code>修饰的</font></u>&thinsp;<strong>所有方法</strong>&thinsp;]。</p>
</li>
<li><p>重写的方法&thinsp;<u>能够抛出</u>&thinsp;<strong>任何</strong><font color="#6AA84F"><strong>非强制异常</strong></font>，无论&thinsp;被重写的方法&thinsp;是否抛出异常；<br>⤷&ensp;<u>不能抛出</u>&thinsp;<strong>新的</strong><font color="#6AA84F"><strong>强制性异常</strong></font>，或者&thinsp;[&thinsp;比&thinsp;被重写的方法&thinsp;<strong>声明得更广泛的</strong>&thinsp;<font color="#6AA84F"><strong>强制性异常</strong></font>&thinsp;]。</p>
</li>
</ol>
<h4 id="Super关键字的使用"><a href="#Super关键字的使用" class="headerlink" title="Super关键字的使用"></a>Super关键字的使用</h4><blockquote>
<p>当需要&thinsp;在子类中&thinsp;调用&thinsp;父类的被重写方法&thinsp;时，要使用<code>super</code>关键字（类似<code>this</code>关键字；代替&thinsp;父类指针）。</p>
</blockquote>
<h4 id="重写（Override）与重载（Overload）之间的区别"><a href="#重写（Override）与重载（Overload）之间的区别" class="headerlink" title="重写（Override）与重载（Overload）之间的区别"></a>重写（Override）与重载（Overload）之间的区别</h4><table class="wikitable" style="margin-top:18px;margin-left:0;margin-right:0;">
  <tbody align="center">
    <tr>
      <th width="18%">区别点</th>
      <th width="22%">重载（Overload）</th>
      <th>重写（Override）</th>
    </tr>
    <tr>
      <td><font color="#9900FF" style="font-weight:bold;">参数列表</font></td>
      <td>必须修改</td>
      <td>必须一致</td>
    </tr>
    <tr>
      <td><font color="#9900FF" style="font-weight:bold;">返回类型</font></td>
      <td>可以修改</td>
      <td>必须一致</td>
    </tr>
    <tr>
      <td><font color="#9900FF" style="font-weight:bold;">访问权限</font></td>
      <td>可以修改</td>
      <td>可以&thinsp;<font color="#FCC000" style="font-weight:bold;">保持一致</font>&thinsp;或&thinsp;<font color="#FCC000" style="font-weight:bold;">降低限制</font>，不能做更严格的限制（<font color="#6AA84F">访问权限</font>&thinsp;不能提高）</td>
    </tr>
    <tr>
      <td><font color="#9900FF" style="font-weight:bold;">抛出异常</font></td>
      <td>可以修改</td>
      <td>可以&thinsp;<font color="#FCC000" style="font-weight:bold;">减少</font>&thinsp;或&thinsp;<font color="#FCC000" style="font-weight:bold;">删除</font>，不能抛出&thinsp;新的&thinsp;或者&thinsp;范围更广泛的&thinsp;<font color="#6AA84F">强制性异常</font></td>
    </tr>
  </tbody>
</table>

<h4 id="重写（Override）与重载（Overload）之间的联系"><a href="#重写（Override）与重载（Overload）之间的联系" class="headerlink" title="重写（Override）与重载（Overload）之间的联系"></a>重写（Override）与重载（Overload）之间的联系</h4><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>方法的&thinsp;<font color="#6AA84F" style="font-weight:bold;">重写</font>（<font color="#6AA84F" style="font-weight:bold;">Override</font>）和&thinsp;<font color="#6AA84F" style="font-weight:bold;">重载</font>（<font color="#6AA84F" style="font-weight:bold;">Overload</font>）&thinsp;是&thinsp;Java&thinsp;多态性&thinsp;的不同表现</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ul>
<li><p><font color="#6AA84F" style="font-weight:bold;">重写</font>（<font color="#6AA84F" style="font-weight:bold;">Override</font>）&thinsp;是&thinsp;父类与子类之间&thinsp;多态性的一种表现；</p>
</li>
<li><p><font color="#6AA84F" style="font-weight:bold;">重载</font>（<font color="#6AA84F" style="font-weight:bold;">Overload</font>）&thinsp;可以理解成多态的具体表现形式。</p>
</li>
</ul>
 
    </div></div>
    </div>

<h2 id="第7章-3-代理"><a href="#第7章-3-代理" class="headerlink" title="第7章-3 代理"></a><a href="#index_7-3">第7章-3 代理</a></h2><h2 id="第7章-4-结合使用组合和继承"><a href="#第7章-4-结合使用组合和继承" class="headerlink" title="第7章-4 结合使用组合和继承"></a><a href="#index_7-4">第7章-4 结合使用组合和继承</a></h2><p>同时使用组合和继承是很常见的事。……</p>
<h3 id="第7章-4-1-确保正确清理"><a href="#第7章-4-1-确保正确清理" class="headerlink" title="第7章-4-1 确保正确清理"></a><a href="#index_7-4-1">第7章-4-1 确保正确清理</a></h3><p>Java&thinsp;中没有&thinsp;C++&thinsp;中&thinsp;<strong>析构函数</strong>&thinsp;的概念。</p>
<blockquote>
<p><strong>析构函数</strong>&thinsp;是一种&thinsp;在对象被销毁时&thinsp;可以被自动调用的函数。</p>
</blockquote>
<p>⤷&ensp;其原因可能是在&thinsp;Java&thinsp;的设计中，<u><strong>销毁对象的操作</strong>&thinsp;由&thinsp;<font color="#6AA84F"><strong>垃圾回收器</strong></font>&thinsp;进行控制执行</u>。</p>
<p>⤷&ensp;通常这样做是好事，但有时&thinsp;<strong>类</strong>（<code>class</code>）&thinsp;可能要&thinsp;在生命周期内&thinsp;执行一些必需的&thinsp;清理活动。<br>……</p>
<h3 id="第7章-4-2-名称屏蔽"><a href="#第7章-4-2-名称屏蔽" class="headerlink" title="第7章-4-2 名称屏蔽"></a><a href="#index_7-4-2">第7章-4-2 名称屏蔽</a></h3><p>如果&thinsp;Java&thinsp;的基类&thinsp;拥有某个&thinsp;已被多次<font color="#6AA84F"><strong>重载</strong>（<font color="#6AA84F"><strong>Overload</strong></font>）</font>的方法名称，那么&thinsp;在派生类中&thinsp;重新定义该方法名称时，<span class="hint--info hint--rounded hint--top" data-hint="这一点与&thinsp;C++&thinsp;不同" ontouchstart>并不会&thinsp;屏蔽&thinsp;其&thinsp;在基类中的&thinsp;任何版本</span>。<br>⤷&ensp;因此，无论在该层还是在它的基类中进行定义，<font color="#6AA84F"><strong>重载</strong></font>（<font color="#6AA84F"><strong>Overload</strong></font>）机制都可以正常工作。</p>
<blockquote>
<p>……（C++&thinsp;中设计&thinsp;<font color="#6AA84F"><strong>重写</strong></font>（<font color="#6AA84F"><strong>Override</strong></font>）时&thinsp;屏蔽&thinsp;<strong>基类的</strong><font color="#6AA84F"><strong>重载机制</strong></font>&thinsp;的原因之一&ensp;——&ensp;防止程序员犯错误）</p>
</blockquote>
<p>Java&thinsp;SE&thinsp;5&thinsp;新增加了<code>@Override</code>注解，它并不是关键字，但是<span class="hint--info hint--rounded hint--top" data-hint="作为一种规范" ontouchstart>可以被当做关键字使用</span>。</p>
<blockquote>
<p><code>@Override</code>注解的作用：在编译时进行&thinsp;<font color="#6AA84F"><strong>重写</strong></font>（<font color="#6AA84F"><strong>Override</strong></font>）检验的&thinsp;<strong>编译检查</strong><br>⤷&ensp;防止意外地&thinsp;<font color="#6AA84F"><strong>重载</strong></font>（<font color="#6AA84F"><strong>Override</strong></font>）。</p>
</blockquote>
<h2 id="第7章-5-在组合与继承之间选择"><a href="#第7章-5-在组合与继承之间选择" class="headerlink" title="第7章-5 在组合与继承之间选择"></a><a href="#index_7-5">第7章-5 在组合与继承之间选择</a></h2><p><font color="#6AA84F"><strong>组合</strong></font>（<font color="#6AA84F"><strong>Composition</strong></font>）&thinsp;和&thinsp;<font color="#6AA84F"><strong>继承</strong></font>（<code>extends</code>）&thinsp;都允许&thinsp;在新的类中&thinsp;放置&thinsp;子对象。<br><font color="#6AA84F"><strong>组合</strong></font>（<font color="#6AA84F"><strong>Composition</strong></font>）&thinsp;是&thinsp;<font color="#FCC000"><strong>显式地</strong></font>&thinsp;执行；<font color="#6AA84F"><strong>继承</strong></font>（<code>extends</code>）&thinsp;是&thinsp;<font color="#FCC000"><strong>隐式地</strong></font>&thinsp;执行。</p>
<p>要想使用好&thinsp;组合&thinsp;和&thinsp;继承，我们需要明确：二者之间的区别何在？怎样在二者之间做出选择？</p>
<h3 id="组合和继承的区别"><a href="#组合和继承的区别" class="headerlink" title="组合和继承的区别"></a>组合和继承的区别</h3><blockquote>
<ol>
<li><p>在底层实现层面上，<font color="#6AA84F"><strong>继承</strong></font>（<code>extends</code>）&thinsp;实际上是&thinsp;在&thinsp;<font color="#6AA84F"><strong>组合</strong></font>（<font color="#6AA84F"><strong>Composition</strong></font>）的基础上&thinsp;封装实现的抽象逻辑。</p>
</li>
<li><p>在抽象逻辑层面上：</p>
<ul>
<li><font color="#6AA84F"><strong>组合</strong></font>（<font color="#6AA84F"><strong>Composition</strong></font>）&thinsp;是“has-a”（有一个）关系的表达；</li>
<li><font color="#6AA84F"><strong>继承</strong></font>（<code>extends</code>）&thinsp;是“is-a”（是一个）关系的表达。</li>
</ul>
</li>
<li><p>在&thinsp;Java&thinsp;中，<font color="#6AA84F"><strong>继承</strong></font>（<code>extends</code>）&thinsp;支持&thinsp;从派生类向基类进行&thinsp;<font color="#4343FF"><strong>向上转型</strong></font>。</p>
</li>
</ol>
</blockquote>
<h3 id="在组合和继承之间的选择"><a href="#在组合和继承之间的选择" class="headerlink" title="在组合和继承之间的选择"></a>在组合和继承之间的选择</h3><blockquote>
<ol>
<li><p><font color="#6AA84F"><strong>组合</strong></font>（<font color="#6AA84F"><strong>Composition</strong></font>）&thinsp;通常用于&thinsp;在新的类中&thinsp;<font color="#FCC000"><strong>使用</strong></font>&thinsp;现有类的<font color="#FCC000"><strong>功能</strong></font>&ensp;🡄&ensp;而非现有类的接口。</p>
</li>
<li><p><font color="#6AA84F"><strong>继承</strong></font>（<code>extends</code>）&thinsp;往往用于&thinsp;在新的类中&thinsp;<font color="#FCC000"><strong>实现</strong></font>&thinsp;现有类的<font color="#FCC000"><strong>接口</strong></font>。</p>
</li>
</ol>
</blockquote>
<h2 id="第7章-6-protected关键字"><a href="#第7章-6-protected关键字" class="headerlink" title="第7章-6 protected关键字"></a><a href="#index_7-6">第7章-6 protected关键字</a></h2><blockquote>
<p>理解了&thinsp;继承，关键字<code>protected</code>才具有意义。</p>
</blockquote>
<p><code>protected</code>关键字的作用：限制&thinsp;对&thinsp;<strong>类</strong>（<code>class</code>）<strong>的成员</strong>&thinsp;的访问，仅允许&thinsp;[&thinsp;<strong>该类的</strong><font color="#6AA84F"><strong>派生类</strong></font>&thinsp;和&thinsp;<font color="#FCC000"><strong>同一个包下</strong></font><strong>的</strong>&thinsp;]&thinsp;任何类&thinsp;访问。</p>
<h2 id="第7章-7-向上转型"><a href="#第7章-7-向上转型" class="headerlink" title="第7章-7 向上转型"></a><a href="#index_7-7">第7章-7 向上转型</a></h2><blockquote>
<p>“为新的类提供方法”并不是&thinsp;<font color="#6AA84F"><strong>继承</strong></font>&thinsp;技术中最重要的方面，其最重要的方面是&thinsp;表现<u>新的类和基类之间的所属关系</u>，这种关系可以概括为“新的类是现有类的一种类型”。</p>
</blockquote>
<h3 id="第7章-7-1-为什么称为向上转型"><a href="#第7章-7-1-为什么称为向上转型" class="headerlink" title="第7章-7-1 为什么称为向上转型"></a><a href="#index_7-7-1">第7章-7-1 为什么称为向上转型</a></h3><blockquote>
<p>该术语的使用有其历史原因，并且是以传统的&thinsp;<font color="#CC0000"><strong>类继承图</strong></font>&thinsp;的绘制方法为基础：将根置于页面的顶端，然后逐渐向下。</p>
</blockquote>
<p>由&thinsp;<font color="#6AA84F"><strong>派生类</strong></font>&thinsp;生成&thinsp;<font color="#6AA84F"><strong>基类</strong></font>，在&thinsp;<font color="#CC0000"><strong>继承图</strong></font>&thinsp;上是向上移动的，因此称为&thinsp;<font color="#6AA84F"><strong>向上转型</strong></font>。</p>
<h3 id="第7章-7-2-再论组合与继承"><a href="#第7章-7-2-再论组合与继承" class="headerlink" title="第7章-7-2 再论组合与继承"></a><a href="#index_7-7-2">第7章-7-2 再论组合与继承</a></h3><blockquote>
<p>在&thinsp;OOP&thinsp;中，生成和使用程序代码最有可能采用的方法是&thinsp;<font color="#6AA84F"><strong>组合</strong></font>  &ensp;🡆&ensp;直接将数据和方法包装进一个类中，并使用该类的对象。</p>
</blockquote>
<p>判断是否应该使用&thinsp;<font color="#6AA84F"><strong>继承</strong></font>，最清晰的标准是&thinsp;是否需要&thinsp;从派生类向基类进行&thinsp;<font color="#6AA84F"><strong>向上转型</strong></font>。</p>
<h2 id="第7章-8-final关键字"><a href="#第7章-8-final关键字" class="headerlink" title="第7章-8 final关键字"></a><a href="#index_7-8">第7章-8 final关键字</a></h2><p>根据&thinsp;上下文环境，Java&thinsp;的关键字<code>final</code>的含义存在细微的差别，通常它指的是“这是无法改变的”。</p>
<blockquote>
<p>⤷&ensp;不想改变可能出于2种理由：<font color="#9900FF"><strong>设计</strong></font>&thinsp;或&thinsp;<font color="#9900FF"><strong>效率</strong></font>（Java&thinsp;SE&thinsp;5&thinsp;之后不需要考虑，交由&thinsp;JVM&thinsp;来优化）。</p>
<p>⤷&ensp;由于这2个原因相差很远，因此关键字<code>final</code>有可能被误用。</p>
</blockquote>
<p>下面讨论可能使用到<code>final</code>的3种情况：<font color="#4343FF"><strong>数据</strong></font>、<font color="#4343FF"><strong>方法</strong></font>、<font color="#4343FF"><strong>类</strong></font>。</p>
<h3 id="第7章-8-1-final数据"><a href="#第7章-8-1-final数据" class="headerlink" title="第7章-8-1 final数据"></a><a href="#index_7-8-1">第7章-8-1 final数据</a></h3><p>许多编程语言都有某种方法，来向编译器告知一块数据是&thinsp;恒定不变的。</p>
<ul>
<li><p>对于&thinsp;<font color="#9900FF"><strong>数据的恒定不变</strong></font>，有2种情况：</p>
<ol>
<li>一个&thinsp;永不改变的&thinsp;<font color="#6AA84F"><strong>编译时常量</strong></font>：以<code>final</code>关键字修饰，且&thinsp;值&thinsp;为&thinsp;<font color="#4343FF"><strong>基本数据类型</strong></font><strong>的数据</strong>（总之就是&thinsp;编译期&thinsp;能够确定值的对象）。<ul>
<li>对于&thinsp;<font color="#6AA84F"><strong>编译常量</strong></font>&thinsp;这种情况，编译器可以将该&thinsp;常量值&thinsp;代入任何可能用到它的计算式中。即&thinsp;在编译时&thinsp;执行计算式，减轻运行时负担。</li>
<li>在&thinsp;Java&thinsp;中，这类&thinsp;常量&thinsp;必须是&thinsp;<font color="#4343FF"><strong>基本数据类型</strong></font>，并且以<code>final</code>关键字修饰。</li>
</ul>
</li>
<li>一个&thinsp;<font color="#6AA84F"><strong>运行时常量</strong></font>&ensp;——&ensp;<strong>在运行时</strong>&thinsp;被初始化的值，且不希望它被改变。<ul>
<li>在&thinsp;Java&thinsp;中，<u>当<code>final</code>关键字修饰&thinsp;对象引用&thinsp;时</u>，该&thinsp;对象引用&thinsp;会恒定不变（一旦该引用被初始化指向一个对象，就不会再被更改为其他对象）；然而，<u><font color="#FCC000"><strong>该引用所指向的对象，其自身是可以被修改的</strong></font></u>。</li>
</ul>
</li>
</ol>
</li>
<li><p>Java&thinsp;并未提供&thinsp;使任何对象恒定不变&thinsp;的途径（可以自己编写&thinsp;类&thinsp;以实现&thinsp;使对象恒定不变的效果）。</p>
</li>
<li><p>一个既是<code>static</code>又是<code>final</code>的域，只占据一段不能改变的存储空间（……）。</p>
  <div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>下面的示例示范了<code>final</code>域的情况。<br>注意，根据惯例，既是<code>static</code>又是<code>final</code>的域（……）将用&thinsp;<strong>大写字母</strong>&thinsp;表示，并使用下划线<code>_</code>分隔各个单词。</p>
<p>……</p>
 
    </div></div>
    </div></li>
</ul>
<h4 id="空白final"><a href="#空白final" class="headerlink" title="空白final"></a>空白final</h4><p>Java&thinsp;允许生成“空白<code>final</code>”，所谓空白<code>final</code>是指：被声明为<code>final</code>，但又未给定初值的域。<u>无论什么情况，编译器都确保空白<code>final</code>在使用前被初始化</u>。</p>
<p>空白<code>final</code>在<code>final</code>关键字的使用中提供了更大的灵活性&ensp;——&ensp;一个类中的<code>final</code>域可以根据对象而有所不同，却还能保持其恒定不变的特性。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h4 id="final参数"><a href="#final参数" class="headerlink" title="final参数"></a>final参数</h4><p>Java&thinsp;允许&thinsp;在参数列表中&thinsp;以声明的方式<u>将&thinsp;参数&thinsp;指明为<code>final</code></u>。这意味着你无法在方法中更改参数引用&ensp;——&ensp;<u>在方法中&thinsp;可以读参数，但不能修改参数</u>。</p>
<p>这一特性主要用来向&thinsp;<font color="#6AA84F"><strong>匿名内部类</strong></font>&thinsp;传递数据。</p>
<h3 id="第7章-8-2-final方法"><a href="#第7章-8-2-final方法" class="headerlink" title="第7章-8-2 final方法"></a><a href="#index_7-8-2">第7章-8-2 final方法</a></h3><p>使用<code>final</code>修饰方法的原因有两个：</p>
<ol>
<li><p>把方法锁定，<span class="hint--info hint--rounded hint--top" data-hint="派生类中可以访问，但不能重写该方法" ontouchstart>以防任何继承类修改它的含义</span>。<br> ⤷&ensp;这是出于设计的考虑：想要确保该方法在继承中保持其行为不变，并且不会被覆盖。</p>
<blockquote>
<p>不能重写的前提是派生类能够访问到基类中的方法。<br>⤷&ensp;注意：如果一个方法同时被<code>final</code>和<code>private</code>修饰&ensp;——&ensp;派生类没有指定方法的访问权限，<code>final</code>对方法的禁止重写的限制将会失效；派生类中可以定义与基类几乎一致（符合重写规则）的方法，作为派生类定义的新方法。</p>
</blockquote>
</li>
<li><ul>
<li><p>在过去，建议使用<code>final</code>方法的第2个原因是&thinsp;<strong>效率</strong>；</p>
<blockquote>
<p>在&thinsp;Java&thinsp;的早期实现中，如果将一个方法指明为<code>final</code>，则编译器将针对该方法的所有调用都转为&thinsp;内嵌调用。……<br>在被<code>final</code>修饰的方法不大的情况下，这样做能减少方法调用的开销；否则，程序的代码就会膨胀（……），内嵌直接带来的性能提高会因为在方法内花费过多的时间量而被缩减，实际上达不到性能提高的效果。</p>
</blockquote>
</li>
<li><p>⤷&ensp;在最近的版本中（Java&thinsp;SE&thinsp;5&thinsp;以后），虚拟机（特别是&thinsp;hotspot&thinsp;技术）可以探测到这些情况，并优化去掉这些效率反而降低的&thinsp;内嵌调用，因此不再需要使用<code>final</code>方法来优化了。</p>
<blockquote>
<p>同时，为了效率而使用<code>final</code>方法的做法逐渐地受到劝阻&ensp;——&ensp;（Java&thinsp;SE&thinsp;5&thinsp;以后的环境下）应该让编译器和&thinsp;JVM&thinsp;去处理效率的问题，</p>
</blockquote>
</li>
<li><p>⤷&ensp;<u>只有在想要<font color="#FCC000">明确地禁止覆盖</font>时，才将方法设置为<code>final</code></u>。</p>
</li>
</ul>
</li>
</ol>
<h4 id="final和private关键字"><a href="#final和private关键字" class="headerlink" title="final和private关键字"></a>final和private关键字</h4><p>概述：<code>final</code>&ensp;+&ensp;<code>private</code>&ensp;=&ensp;<font color="#9900FF"><strong>无法覆盖</strong></font>&ensp;+&ensp;<font color="#9900FF"><strong>无法调用</strong></font>&ensp;=&ensp;<font color="#9900FF"><strong>无法调用</strong></font></p>
<blockquote>
<p>对于&thinsp;基类中的&thinsp;<strong>无法覆盖</strong>的方法，子类中&thinsp;可以定义&thinsp;[&thinsp;与这些基类方法&thinsp;在形式上符合<font color="#FCC000"><strong>重写规则</strong></font>（<font color="#6AA84F"><strong>方法名</strong></font>、<font color="#6AA84F"><strong>参数列表</strong></font>、<font color="#6AA84F"><strong>返回值</strong></font>、<font color="#6AA84F"><strong>访问权限</strong></font>、<font color="#6AA84F"><strong>抛出异常</strong></font>）的&thinsp;]&thinsp;方法，但是这些子类方法只是在子类中新定义的方法，与父类无关。</p>
</blockquote>
<h3 id="第7章-8-3-final类"><a href="#第7章-8-3-final类" class="headerlink" title="第7章-8-3 final类"></a><a href="#index_7-8-3">第7章-8-3 final类</a></h3><p>当&thinsp;类（<code>class</code>）&thinsp;被修饰为<code>final</code>时，该类无法被&thinsp;<font color="#6AA84F"><strong>继承</strong></font>。</p>
<blockquote>
<ul>
<li><p>设计目的：</p>
<ol>
<li><p>该类不需要做任何改动；</p>
</li>
<li><p>出于安全性的考虑，不希望该类有子类。</p>
</li>
</ol>
</li>
</ul>
</blockquote>
<ul>
<li><code>final</code>类禁止继承，因此<code>final</code>类中的&thinsp;<font color="#4343FF"><strong>方法</strong></font>&thinsp;都&thinsp;<strong>隐式地</strong>&thinsp;指定为<code>final</code>。</li>
</ul>
<h3 id="第7章-8-4-有关final的忠告"><a href="#第7章-8-4-有关final的忠告" class="headerlink" title="第7章-8-4 有关final的忠告"></a><a href="#index_7-8-4">第7章-8-4 有关final的忠告</a></h3><p>在设计类时，将方法指定为<code>final</code>会禁止方法被继承，这<span class="hint--info hint--rounded hint--top" data-hint="这往往是困难的，特别是对于通用类来说" ontouchstart>需要对&thinsp;<font color="#FCC000" style="font-weight:bold;">该类如何被复用</font>&thinsp;有明确的预见和定义</span>。</p>
<p>……</p>
<h2 id="第7章-9-初始化类及类的加载"><a href="#第7章-9-初始化类及类的加载" class="headerlink" title="第7章-9 初始化类及类的加载"></a><a href="#index_7-9">第7章-9 初始化类及类的加载</a></h2><blockquote>
<p>在许多传统语言中，程序是作为启动过程的一部分立刻被加载的，然后是初始化，紧接着程序开始运行。</p>
<p>这些语言的&thinsp;<strong>初始化过程</strong>&thinsp;必须小心地控制，以确保定义为<code>static</code>的东西，其&thinsp;<strong>初始化顺序</strong>&thinsp;不会出现问题。<br>⤷&ensp;例如&thinsp;C++&thinsp;中，如果某个<code>static</code>期望另一个<code>static</code>&thinsp;在被初始化之前&thinsp;就能有效地使用它，那么就会出现问题。</p>
</blockquote>
<p>Java&thinsp;采用了一种不同的加载方式避免了该问题。……</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span><font color="#6AA84F">类</font>（<code>class</code>）的代码在初次使用时才加载</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>一般来说，“<strong>类的代码在初次使用时才加载</strong>”，这通常指的是&thinsp;加载&thinsp;发生在&thinsp;类（<code>class</code>）的第一个对象创建之时，但是<u>当访问<code>static</code>域或<code>static</code>方法时，也会发生加载</u>。</p>
 
    </div></div>
    </div>

<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span><code>static</code>&thinsp;的初次使用之处&ensp;也是其&thinsp;初始化发生之处</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>所有的<code>static</code>对象和<code>static</code>代码段，都会&thinsp;在加载时，依据&thinsp;程序中的顺序（即&thinsp;书写顺序）依次初始化。</p>
<p>当然，定义为<code>static</code>的东西只会被初始化一次。</p>
 
    </div></div>
    </div>

<p>……</p>
<h3 id="第7章-9-1-继承与初始化"><a href="#第7章-9-1-继承与初始化" class="headerlink" title="第7章-9-1 继承与初始化"></a><a href="#index_7-9-1">第7章-9-1 继承与初始化</a></h3><p>了解包括继承在内的初始化全过程，对所发生的一切有个全局把控，是很有益的。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h2 id="第7章-10-总结"><a href="#第7章-10-总结" class="headerlink" title="第7章-10 总结"></a><a href="#index_7-10">第7章-10 总结</a></h2><p><font color="#6AA84F"><strong>继承</strong></font>&thinsp;和&thinsp;<font color="#6AA84F"><strong>组合</strong></font>&thinsp;都能&thinsp;从现有类型&thinsp;生产新的类型。<br>⤷&ensp;<font color="#6AA84F"><strong>组合</strong></font>&thinsp;一般是&thinsp;将现有类型作为新类型底层实现的一部分&thinsp;来加以复用；而&thinsp;<font color="#6AA84F"><strong>继承</strong></font>&thinsp;复用的是接口。</p>
<p>在使用&thinsp;<font color="#6AA84F"><strong>继承</strong></font>&thinsp;时，<u>由于&thinsp;派生类具有基类的接口，因此它可以&thinsp;<font color="#FCC000"><strong>向上转型</strong></font>&thinsp;至&thinsp;基类</u>。这对&thinsp;<strong>多态</strong>&thinsp;来讲至关重要。</p>
<p>……</p>
<h1 id="第8章-多态"><a href="#第8章-多态" class="headerlink" title="第8章 多态"></a><a href="#index_8">第8章 多态</a></h1><p>面向对象的程序设计语言（<strong>OOP</strong>）的基本特性：<font color="#6AA84F"><strong>封装</strong></font>（数据抽象）、<font color="#6AA84F"><strong>继承</strong></font>、<font color="#6AA84F"><strong>多态</strong></font>。</p>
<ul>
<li><p><font color="#CC0000"><strong>封装</strong></font>：通过合并特征和行为&thinsp;创建新的数据类型。</p>
<blockquote>
<p>“实现隐藏”</p>
</blockquote>
</li>
<li><p><font color="#CC0000"><strong>继承</strong></font>：……</p>
<blockquote>
<p>继承&thinsp;允许&thinsp;将对象（<code>Object</code>）视为&thinsp;[&thinsp;它本身的类型&thinsp;或者&thinsp;其基类型&thinsp;]&thinsp;来处理。</p>
</blockquote>
</li>
<li><p><font color="#CC0000"><strong>多态</strong></font>（也称作&thinsp;动态绑定、后期绑定&thinsp;或&thinsp;运行时绑定）：……</p>
<blockquote>
<p>多态的作用是&thinsp;<u>消除类型之间的耦合关系</u>。</p>
</blockquote>
</li>
</ul>
<h2 id="第8章-1-再论向上转型"><a href="#第8章-1-再论向上转型" class="headerlink" title="第8章-1 再论向上转型"></a><a href="#index_8-1">第8章-1 再论向上转型</a></h2><p>对象&thinsp;既可以&thinsp;作为它本身的类型使用，也可以&thinsp;作为基类型使用。而这种&thinsp;[&thinsp;<strong>把</strong>&thinsp;<font color="#FCC000"><strong>对象的引用</strong></font>&thinsp;<strong>视为</strong>&thinsp;<font color="#FCC000"><strong>对其基类型的引用</strong></font>&thinsp;]&thinsp;的做法，<span class="hint--info hint--rounded hint--top" data-hint="因为在&thinsp;继承树&thinsp;的画法中，基类&thinsp;是放置在上方的" ontouchstart>被称作&thinsp;<font color="#6AA84F" style="font-weight:bold;">向上转型</font></span>。</p>
<p>但是，这样做也有一个问题，具体看下面这个例子：</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<h3 id="第8章-1-1-忘记对象类型"><a href="#第8章-1-1-忘记对象类型" class="headerlink" title="第8章-1-1 忘记对象类型"></a><a href="#index_8-1-1">第8章-1-1 忘记对象类型</a></h3><p>⤷&ensp;上例中的<code>Music.java</code>看起来似乎有些奇怪。为什么所有人都故意忘记对象的类型呢？在进行向上转型时，就会产生这种情况；并且如果让<code>tune()</code>方法接受一个<code>Wind</code>引用作为自己的参数，似乎会更为直观。<br>⤷&ensp;但这样引发的一个重要问题是：如果那样做，就需要为系统内<code>Instrument</code>的每种类型都编写一个新的<code>tune()</code>方法。</p>
<p>……</p>
<blockquote>
<p>这样做行得通，但有一个主要的缺点：必须为每个新的Instrument类编写特定类型的方法。这意味着在开始时就需要更多的编程，……</p>
<p>此外，如果我们忘记重载某个方法，编译器不会返回任何错误信息，这样对于整个类型的处理过程就会变得难以操纵。</p>
<p>也许我们可以写一个简单地方法，它仅接收基类作为参数，而不接收派生类。<br>⤷&ensp;这是多态所允许的，但这往往不符合大多数的业务设计场景。</p>
</blockquote>
<h2 id="第8章-2-转机"><a href="#第8章-2-转机" class="headerlink" title="第8章-2 转机"></a><a href="#index_8-2">第8章-2 转机</a></h2><p>⤷&ensp;运行上例所设计的程序后，……</p>
<p>那么在这种情况下，编译器如何知道这个<code>Instrument</code>指向的是<code>Wind</code>对象呢？实际上，编译器仅凭这些无法确定，需要使用&thinsp;<strong>绑定</strong>&thinsp;来解决。</p>
<h3 id="第8章-2-1-方法调用绑定"><a href="#第8章-2-1-方法调用绑定" class="headerlink" title="第8章-2-1 方法调用绑定"></a><a href="#index_8-2-1">第8章-2-1 方法调用绑定</a></h3><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span><font color="#6AA84F" style="font-weight:bold;">绑定</font>：将&thinsp;一个<font color="#4343FF" style="font-weight:bold;">方法的调用</font>&thinsp;同&thinsp;一个<font color="#4343FF" style="font-weight:bold;">方法主体</font>&thinsp;关联起来。</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ul>
<li><p><font color="#6AA84F"><strong>前期绑定</strong></font>：在程序执行前&thinsp;进行绑定。</p>
<blockquote>
<p>前期绑定&thinsp;是面向过程语言的默认绑定方式。<br>⤷&ensp;例如，C&thinsp;语言只有&thinsp;前期绑定&thinsp;这一种方法调用。</p>
</blockquote>
</li>
<li><p><font color="#6AA84F"><strong>后期绑定</strong></font>（也叫&thinsp;<font color="#6AA84F"><strong>动态绑定</strong></font>、<font color="#6AA84F"><strong>运行时绑定</strong></font>）：<font color="#FCC000">在程序运行时</font>，根据&thinsp;<strong>对象的类型</strong>&thinsp;进行绑定。</p>
<blockquote>
<p>……<br>后期绑定&thinsp;随语言不同而有所不同，但是试想一下就知道，不管怎样都必须在对象中放置某种“类型信息”。</p>
<p>在&thinsp;Java&thinsp;中，<span class="hint--info hint--rounded hint--top" data-hint="<code>private</code>方法&thinsp;属于&thinsp;<code>final</code>方法" ontouchstart><font color="#FCC000">除了<code>static</code>和<code>final</code>限定的方法</font>&thinsp;之外，<font style="font-weight:bold;">其他所有的方法</font></span>&thinsp;<u>都是&thinsp;<font color="#6AA84F"><strong>后期绑定</strong></font></u>。</p>
</blockquote>
</li>
</ul>
 
    </div></div>
    </div>

<h3 id="第8章-2-2-产生正确的行为"><a href="#第8章-2-2-产生正确的行为" class="headerlink" title="第8章-2-2 产生正确的行为"></a><a href="#index_8-2-2">第8章-2-2 产生正确的行为</a></h3><p>在确认Java中所有方法都是通过动态绑定实现多态这个事实后，我们就可以编写只与基类打交道的程序代码了，这些代码对所有的派生类都可以正常运行；或者换一种说法，发送消息给某个对象，让该对象去判断应该执行什么动作。</p>
<ul>
<li><p>在面向对象程序设计中，有一个经典的例子就是“几何形状”（shape）。<br>  ……</p>
  <div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>向上转型可以像下面这条语句这么简单：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape s = <span class="keyword">new</span> Ciecle();</span><br></pre></td></tr></table></figure>

<p>这条语句创建了一个<code>Circle</code>对象，并把得到的引用立即赋值给<code>Shape</code>。因为通过&thinsp;<strong>继承</strong>，<code>Circle</code>就是一种<code>Shape</code>，所以编译器认可这条语句，不会产生错误信息。</p>
<p>假如要调用<code>s.draw()</code>方法（在<code>Circle</code>中已被覆盖），由于&thinsp;<strong>后期绑定</strong>（<strong>多态</strong>），最终正确调用了<code>Circle.draw()</code>方法。</p>
 
    </div></div>
    </div></li>
</ul>
<h3 id="第8章-2-3-可拓展性"><a href="#第8章-2-3-可拓展性" class="headerlink" title="第8章-2-3 可拓展性"></a><a href="#index_8-2-3">第8章-2-3 可拓展性</a></h3><p>由于多态机制，我们可以从通用的基类继承出新的数据类型，这样就可以添加新功能；同时那些操作基类接口的方法不需要改动就能够应用于新类。</p>
<h3 id="第8章-2-4-缺陷：“覆盖”私有方法"><a href="#第8章-2-4-缺陷：“覆盖”私有方法" class="headerlink" title="第8章-2-4 缺陷：“覆盖”私有方法"></a><a href="#index_8-2-4">第8章-2-4 缺陷：“覆盖”私有方法</a></h3><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<p>由于<code>private</code>方法被自动认为是<code>final</code>方法，而且对派生类是屏蔽的，所以&thinsp;派生类中定义&thinsp;与&thinsp;基类中符合重写规则形式的方法，算不上&thinsp;<font color="#6AA84F"><strong>重写</strong></font>，只能算是派生类中新定义的方法；同时<u>派生类中的方法&thinsp;也不能&thinsp;对基类中的<code>private</code>方法进行&thinsp;<font color="#6AA84F"><strong>重载</strong></font></u>。</p>
<p><u>此时编译器不会报错，但是程序也不会按照所期望的（覆盖基类的方法）来执行</u>。确切地说，<u>在派生类中，对于基类的<code>private</code>方法，最好采用不同的方法名</u>。</p>
<h3 id="第8章-2-5-缺陷：域与静态方法"><a href="#第8章-2-5-缺陷：域与静态方法" class="headerlink" title="第8章-2-5 缺陷：域与静态方法"></a><a href="#index_8-2-5">第8章-2-5 缺陷：域与静态方法</a></h3><p>在&thinsp;Java&thinsp;中，只有&thinsp;普通的方法调用（非<code>static</code>&ensp;|&ensp;<code>final</code>的方法调用）可以是&thinsp;多态的。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>如果你直接访问某个域，这个访问就将在编译期进行解析。</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
 
    </div></div>
    </div>

<p>……</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>静态方法的行为不具有多态性。</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>因为&thinsp;<font color="#6AA84F"><strong>静态方法</strong></font>&thinsp;是与&thinsp;<font color="#6AA84F"><strong>类</strong></font>，而非与&thinsp;<font color="#6AA84F"><strong>单个的对象</strong></font>&thinsp;相关联的。</p>
<p>……</p>
 
    </div></div>
    </div>

<h2 id="第8章-3-构造器和多态"><a href="#第8章-3-构造器和多态" class="headerlink" title="第8章-3 构造器和多态"></a><a href="#index_8-3">第8章-3 构造器和多态</a></h2><p>通常，<font color="#6AA84F"><strong>构造器</strong></font>&thinsp;不同于&thinsp;其他种类的方法，涉及到&thinsp;<font color="#6AA84F"><strong>多态</strong></font>&thinsp;时也是如此。</p>
<blockquote>
<p><font color="#6AA84F"><strong>构造器</strong></font>&thinsp;不具有&thinsp;<font color="#6AA84F"><strong>多态性</strong></font>（它们是&thinsp;<font color="#FCC000"><strong>隐式声明的<code>static</code>方法</strong></font>），但还是很有必要理解&thinsp;构造器怎么通过&thinsp;多态&thinsp;在复杂的层次结构中&thinsp;运作，这将有利于&thinsp;避免一些不必要的困扰。</p>
</blockquote>
<h3 id="第8章-3-1-构造器的调用顺序"><a href="#第8章-3-1-构造器的调用顺序" class="headerlink" title="第8章-3-1 构造器的调用顺序"></a><a href="#index_8-3-1">第8章-3-1 构造器的调用顺序</a></h3><blockquote>
<p>构造器的调用顺序已经在第5章简要说明和第7章再次提及，但那些都是在多态引入之前讨论的。</p>
<p><strong>基类的构造器</strong>&thinsp;总是&thinsp;<u>在导出类的构造过程中</u>&thinsp;被调用，并且&thinsp;按照继承层次&thinsp;逐渐向上链接，使得&thinsp;每个基类的构造器&thinsp;都能得到调用。</p>
</blockquote>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：（展示&thinsp;<font color="#6AA84F" style="font-weight:bold;">组合</font>、<font color="#6AA84F" style="font-weight:bold;">继承</font>、<font color="#6AA84F" style="font-weight:bold;">多态</font>&thinsp;在构建顺序上&thinsp;的作用）</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  Meal() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Meal()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> </span>&#123;</span><br><span class="line">  Bread() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Bread()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cheese</span> </span>&#123;</span><br><span class="line">  Cheese() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Cheese()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lettuce</span> </span>&#123;</span><br><span class="line">  Lettuce() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Lettuce()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lunch</span> <span class="keyword">extends</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  Lunch() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Lunch()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PortableLunch</span> <span class="keyword">extends</span> <span class="title">Lunch</span> </span>&#123;</span><br><span class="line">  PortableLunch() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;PortableLunch()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">PortableLunch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Test() &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Test()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Cheese c = <span class="keyword">new</span> Cheese();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Lettuce l = <span class="keyword">new</span> Lettuce();</span><br><span class="line"></span><br><span class="line">  <span class="function">puvlic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Test();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Meal()</span><br><span class="line">Lunch()</span><br><span class="line">PortableLunch()</span><br><span class="line">Bread()</span><br><span class="line">Cheese()</span><br><span class="line">Lettuce()</span><br><span class="line">Test()</span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div>

<p>⤷&ensp;由上例可见，构造器调用顺序：</p>
<ol>
<li>调用&thinsp;<font color="#FFC000"><strong>基类</strong></font>的<font color="#6AA84F"><strong>构造器</strong></font>。<br>🡇</li>
<li><u>按照声明顺序</u>&thinsp;调用&thinsp;<font color="#4343FF"><strong>成员</strong></font>的<font color="#FF6699"><strong>初始化方法</strong></font>。<br>🡇</li>
<li>调用&thinsp;<font color="#FFC000"><strong>导出类</strong></font>的<font color="#6AA84F"><strong>构造器</strong></font>。</li>
</ol>
<h3 id="第8章-3-2-继承与清理"><a href="#第8章-3-2-继承与清理" class="headerlink" title="第8章-3-2 继承与清理"></a><a href="#index_8-3-2">第8章-3-2 继承与清理</a></h3><p>通过&thinsp;<strong>组合</strong>&thinsp;和&thinsp;<strong>继承</strong>&thinsp;的方法&thinsp;来创建新类时，一般不用担心对象的情况问题（子对象留给&thinsp;垃圾回收器（GC）&thinsp;进行处理）。</p>
<blockquote>
<p>如果确实需要做&thinsp;自定义的清理动作，需要注意&thinsp;<strong>对象销毁的顺序</strong>&thinsp;和&thinsp;其&thinsp;<strong>初始化的顺序</strong>&thinsp;<u><font color="#FFC000">相反</font></u>。<br>……</p>
</blockquote>
<h3 id="第8章-3-3-构造器内部的多态方法的行为"><a href="#第8章-3-3-构造器内部的多态方法的行为" class="headerlink" title="第8章-3-3 构造器内部的多态方法的行为"></a><a href="#index_8-3-3">第8章-3-3 构造器内部的多态方法的行为</a></h3><blockquote>
<p>构造器调用的层次结构&thinsp;带来了一个有趣的两难问题：<br>🡆&ensp;如果在&thinsp;<font color="#FCC000"><strong>构造器的内部</strong></font>，调用&thinsp;<font color="#FCC000"><strong>当前构造对象的</strong></font>&thinsp;<font color="#6AA84F"><strong>动态绑定方法</strong></font>，该如何处理？</p>
</blockquote>
<p>在&thinsp;<span class="hint--info hint--rounded hint--top" data-hint="（非 [ static 或 final ] 方法）" ontouchstart><font color="#FFC000" style="font-weight:bold;">一般方法</font></span><font color="#FFC000"><strong>的内部</strong></font>，<font color="#6AA84F"><strong>动态绑定的方法</strong></font>&thinsp;是&thinsp;在运行时&thinsp;才决定的；<br>⤷&ensp;所以，此时使用的是&thinsp;[&thinsp;对象存储空间&thinsp;<span class="hint--info hint--rounded hint--top" data-hint="（对应类型的缺省值）" ontouchstart><font color="#FF6699" style="font-weight:bold;">在初始化时的</font>&thinsp;<font color="#6AA84F" style="font-weight:bold;">默认值</font></span>&thinsp;]。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <p>……</p>
<p>⤷&ensp;因此，编写构造器时&thinsp;有一条&thinsp;有效的准则：“用尽可能简单地方法&thinsp;使对象进入正常状态；尽量避免&thinsp;调用其他方法”。</p>
 
    </div></div>
    </div>

<p>⤷&ensp;<span class="hint--info hint--rounded hint--top" data-hint="注意：基类的<code>private</code>方法 无法被导出类调用。
另外，<code>static</code>域和<code>static</code>方法 无法保证 此时已经初始化完毕。" ontouchstart><font color="#FFC000" style="font-weight:bold;">在构造器中</font>&thinsp;唯一能够安全调用的方法&thinsp;是&thinsp;<font color="#FFC000" style="font-weight:bold;">基类中的<code>final</code>方法</font></span>。</p>
<h2 id="第8章-4-协变返回类型"><a href="#第8章-4-协变返回类型" class="headerlink" title="第8章-4 协变返回类型"></a><a href="#index_8-4">第8章-4 协变返回类型</a></h2><blockquote>
<p>Java&thinsp;SE&thinsp;5&thinsp;中添加了&thinsp;<font color="#6AA84F"><strong>协变返回类型</strong></font>。</p>
</blockquote>
<p><font color="#CC0000"><strong>协变返回类型</strong></font>：在导出类中的、<font color="#FCC000">被覆盖的</font>&thinsp;<strong>方法</strong>，可以返回&thinsp;<font color="#6AA84F">基类</font>方法<font color="#6AA84F">返回类型</font>的&thinsp;某种<font color="#FCC000">导出类型</font>。<br>⤷&ensp;简单来说，<font color="#CC0000"><strong>协变返回类型</strong></font>&thinsp;允许&thinsp;返回&thinsp;<font color="#FCC000">更具体的</font><font color="#6AA84F">返回类型</font>。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Grain&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Wheat&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Mill m = <span class="keyword">new</span> Mill();</span><br><span class="line">    Grain g = m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line"></span><br><span class="line">    m = <span class="keyword">new</span> WheatMill();</span><br><span class="line">    g = m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Grain</span><br><span class="line">Wheat</span><br></pre></td></tr></table></figure>
<p>Java&thinsp;SE&thinsp;5&thinsp;以前的版本&thinsp;强制&thinsp;<code>process()</code>的覆盖版本&thinsp;必须返回<code>Grain</code>类型，而不能&thinsp;返回&thinsp;<code>Grain</code>类型的派生类型<code>Wheat</code>；<br>⤷&ensp;从&thinsp;Java&thinsp;SE&thinsp;5&thinsp;开始，协变返回类型&thinsp;允许返回&thinsp;更具体的<code>Wheat</code>类型。</p>
 
    </div></div>
    </div>

<h2 id="第8章-5-用继承进行设计"><a href="#第8章-5-用继承进行设计" class="headerlink" title="第8章-5 用继承进行设计"></a><a href="#index_8-5">第8章-5 用继承进行设计</a></h2><p>……</p>
<h3 id="第8章-5-1-纯继承与拓展"><a href="#第8章-5-1-纯继承与拓展" class="headerlink" title="第8章-5-1 纯继承与拓展"></a><a href="#index_8-5-1">第8章-5-1 纯继承与拓展</a></h3><p>采用“纯粹”的方式&thinsp;来创建继承层次结构&thinsp;似乎是&thinsp;最好的方式。<br>……</p>
<h3 id="第8章-5-2-向下转型与运行时类型识别"><a href="#第8章-5-2-向下转型与运行时类型识别" class="headerlink" title="第8章-5-2 向下转型与运行时类型识别"></a><a href="#index_8-5-2">第8章-5-2 向下转型与运行时类型识别</a></h3><p>由于<span class="hint--info hint--rounded hint--top" data-hint="（在继承层次中向上移动）" ontouchstart><font color="#6AA84F" style="font-weight:bold;">向上转型</font></span>会丢失&thinsp;<strong>具体类型信息</strong>，……</p>
<blockquote>
<p>⤷&ensp;要解决这个问题，必须&thinsp;有某个方法&thinsp;来确保&thinsp;向下转型的正确性，……</p>
</blockquote>
<p>在某些程序语言（例如&thinsp;C++）中，我们必须&thinsp;执行特殊的操作&thinsp;来获得&thinsp;安全的向下转型；<br>⤷&ensp;但是在&thinsp;Java&thinsp;中，所有转型&thinsp;都会得到检查。</p>
<blockquote>
<p>……</p>
</blockquote>
<h4 id="运行时类型识别（RTTI）"><a href="#运行时类型识别（RTTI）" class="headerlink" title="运行时类型识别（RTTI）"></a>运行时类型识别（RTTI）</h4><p><font color="#CC0000"><strong>运行时类型识别</strong></font>（<font color="#CC0000"><strong>RTTI</strong></font>）：<u><font color="#FCC000">在运行期间</font>&thinsp;对&thinsp;<font color="#6AA84F"><strong>类型</strong></font>&thinsp;进行检查</u>，如果&thinsp;<strong>类型转换的返回结果</strong>&thinsp;不是&thinsp;程序定义时<strong>所期望的类型</strong>，就会抛出一个<code>ClassCastException</code>（<font color="#4343FF"><strong>类转换异常</strong></font>）。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Userful</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MoreUserful</span> <span class="title">extendsUserful</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">u</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">puvlic <span class="class"><span class="keyword">class</span> <span class="title">RTTI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Userful[] x = &#123;</span><br><span class="line">      <span class="keyword">new</span> Userful(),</span><br><span class="line">      <span class="keyword">new</span> MoreUserful(),</span><br><span class="line">    &#125;;</span><br><span class="line">    x[<span class="number">0</span>].f();</span><br><span class="line">    x[<span class="number">1</span>].g();</span><br><span class="line">    <span class="comment">// ((MoreUserful) x[0]).u(); //![Runnable Exception] Exception thrown &quot;java.lang.ClassCastException: com.suite.Userful cannot be cast to com.suite.MoreUserful&quot;</span></span><br><span class="line">    <span class="comment">// x[1].u(); //![ERROR] 编译不通过：找不到对应的方法</span></span><br><span class="line">    ((MoreUserful) x[<span class="number">1</span>]).u();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div>

<h2 id="第8章-6-总结"><a href="#第8章-6-总结" class="headerlink" title="第8章-6 总结"></a><a href="#index_8-6">第8章-6 总结</a></h2><p>多态意味着“不同的形式”。……</p>
<blockquote>
<p>……</p>
</blockquote>
<h1 id="第9章-接口"><a href="#第9章-接口" class="headerlink" title="第9章 接口"></a><a href="#index_9">第9章 接口</a></h1><p><font color="#6AA84F"><strong>接口</strong></font>（<font color="#6AA84F"><strong>Interface</strong></font>）&thinsp;和&thinsp;<font color="#6AA84F"><strong>内部类</strong></font>（<font color="#6AA84F"><strong>Inner class</strong></font>）&thinsp;为我们提供了一种&thinsp;<font color="#FCC000">将接口与实现分离</font>的&thinsp;更加结构化的方法。</p>
<blockquote>
<p>⤷&ensp;这种机制在编程语言中并不通用。例如，C++&thinsp;对这些概念只有间接的支持。<br>⤷&ensp;而在&thinsp;Java&thinsp;中，有&thinsp;关键字&thinsp;对其进行支持。</p>
</blockquote>
<p>首先，我们将学习&thinsp;<font color="#6AA84F"><strong>抽象类</strong></font>。</p>
<blockquote>
<p><font color="#6AA84F"><strong>抽象类</strong></font>是&thinsp;<strong>普通的类</strong>&thinsp;与&thinsp;<strong>接口</strong>&thinsp;之间的一种中庸之道。</p>
<p>这某些场景下，抽象类&thinsp;可能比&thinsp;接口&thinsp;更合适。</p>
</blockquote>
<h3 id="关于接口"><a href="#关于接口" class="headerlink" title="关于接口"></a>关于接口</h3><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>接口知识点</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ol>
<li><p><font color="#6AA84F"><strong>接口</strong></font>（<font color="#6AA84F"><strong>Interface</strong></font>）默认是<code>abstract</code>的。</p>
</li>
<li><p><font color="#FFC000">接口中定义的</font>&thinsp;<font color="#6AA84F"><strong>变量</strong></font>，默认是<code>public abstract final</code>类型的。<br>⤷&ensp;所以，接口中定义的变量必须在定义时初始化，在实现类中也不能被重新定义或者修改其值。</p>
</li>
<li><p><font color="#FFC000">接口中定义的</font>&thinsp;<font color="#6AA84F"><strong>方法</strong></font>，默认是<code>public abstract</code>类型的。</p>
</li>
</ol>
 
    </div></div>
    </div>

<h2 id="第9章-1-抽象类和抽象方法"><a href="#第9章-1-抽象类和抽象方法" class="headerlink" title="第9章-1 抽象类和抽象方法"></a><a href="#index_9-1">第9章-1 抽象类和抽象方法</a></h2><blockquote>
<p>在第8章的“乐器”例子中，基类<code>Instrument</code>中的&thinsp;方法&thinsp;往往是“哑”（dummy）方法；<code>Instrument</code>类的设计目的是&thinsp;为它的所有导出&thinsp;创建一个通用接口，使得&thinsp;不同的子类可以用不同的方式&thinsp;实现这些通用接口。若要调用这些“哑”（dummy）方法，就会出现错误。</p>
<p>此例中的<code>Instrument</code>类被称为&thinsp;<font color="#6AA84F"><strong>抽象基类</strong></font>，又称&thinsp;<font color="#6AA84F"><strong>抽象类</strong></font>。</p>
</blockquote>
<blockquote>
<p>因为&thinsp;抽象类本身&thinsp;只是定义了&thinsp;接口（<code>interface</code>），没有对&thinsp;接口（<code>interface</code>）&thinsp;进行&thinsp;具体地实现，所以&thinsp;创建抽象类的对象&thinsp;是不必要且必须被禁止的。</p>
</blockquote>
<p>为了&thinsp;<font color="#6AA84F"><strong>抽象类</strong></font>&thinsp;概念的实现，Java&thinsp;提供了&thinsp;<font color="#6AA84F"><strong>抽象方法</strong></font>：一种&thinsp;由<code>abstract</code>关键字修饰，且&thinsp;<font color="#FFC000">只有声明</font>、<font color="#FFC000">没有方法体的</font>&thinsp;<strong>特殊方法</strong>。</p>
<blockquote>
<p>注意：构造器&thinsp;不能被<code>abstract</code>修饰，即&thinsp;构造器不能被抽象。</p>
</blockquote>
<h3 id="抽象类具体定义"><a href="#抽象类具体定义" class="headerlink" title="抽象类具体定义"></a>抽象类具体定义</h3><ol>
<li><p>一种被<code>abstract</code>关键字修饰的&thinsp;类，其中&thinsp;可以定义&thinsp;抽象方法（也可以没有）；且&thinsp;定义了抽象方法的类&thinsp;必须被<code>abstract</code>修饰，即&thinsp;只有&thinsp;抽象类&thinsp;才可以定义&thinsp;抽象方法。</p>
</li>
<li><p>抽象类&thinsp;不能被实例化，但是&thinsp;可以定义构造器（不能被<code>abstract</code>修饰，即不能被抽象）。</p>
<blockquote>
<p>由于&thinsp;抽象类里会存在一些&thinsp;属性，那么&thinsp;抽象类&thinsp;一定会有&thinsp;构造方法，其存在目的是&thinsp;为了属性能够正确地初始化。</p>
</blockquote>
</li>
<li><p>抽象类，全称&thinsp;抽象基类，是&thinsp;在继承关系的基础上&thinsp;实现的；要想使用抽象类，只能通过&thinsp;其&thinsp;非抽象的派生类&thinsp;实现其全部抽象方法。</p>
<blockquote>
<p>具体来说，抽象类的子类&thinsp;可以是抽象类，此时&thinsp;这些抽象的子类&thinsp;不需要实现&thinsp;父类的全部抽象方法；而如果&thinsp;非抽象类&thinsp;继承了&thinsp;抽象类，则&thinsp;其&thinsp;必须实现&thinsp;该抽象类中的全部抽象方法。<br>因为&thinsp;抽象类&thinsp;只能通过&thinsp;继承关系&thinsp;来使用，所以&thinsp;抽象类&thinsp;不能被<code>final</code>关键字修饰（<code>final</code>类无法被继承）。</p>
</blockquote>
</li>
<li><p>外部抽象类&thinsp;不允许使用<code>static</code>修饰，而&thinsp;内部抽象类&thinsp;可以使用<code>static</code>修饰；因为&thinsp;外部类&thinsp;是不能被<code>static</code>修饰为&thinsp;静态的，只有&thinsp;内部类&thinsp;可以被<code>static</code>修饰（此时作为&thinsp;成员，可以被<code>static</code>修饰）。<br>使用<code>static</code>修饰的&thinsp;内部类，可以不需要&thinsp;实例化其所在的外部类&thinsp;就可以&thinsp;作为静态成员使用，使用形式“外部类.内部类”。</p>
 <div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>内部抽象类使用示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>.<span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Class C: Hello World!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向上转型</span></span><br><span class="line">    A.B ab = <span class="keyword">new</span> C();</span><br><span class="line">    ab.print();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class C: Hello World!</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div></li>
</ol>
<h3 id="抽象类的使用"><a href="#抽象类的使用" class="headerlink" title="抽象类的使用"></a>抽象类的使用</h3><p>有时候，在抽象类中&thinsp;只需要一个特定的系统子类操作，所以可以忽略掉&thinsp;外部子类；这样的设计&thinsp;在系统类库中&thinsp;会比较常见，目的是&thinsp;对用户&thinsp;隐藏&thinsp;不需要知道的子类。</p>
<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>场景示例：</span></div>
    <div class="xContent pre-open"><div class="inner">
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象类A的对象，完全不知道A的子类B的存在</span></span><br><span class="line">    A a = A.getInstance();</span><br><span class="line">    a.print();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
 
    </div></div>
    </div>

<h3 id="抽象方法具体定义"><a href="#抽象方法具体定义" class="headerlink" title="抽象方法具体定义"></a>抽象方法具体定义</h3><ol>
<li><p>抽象方法&thinsp;必须被<code>abstract</code>关键字修饰，且&thinsp;没有方法体（Java&thinsp;8&thinsp;开始&thinsp;可以有方法体）。</p>
</li>
<li><p>构造器&thinsp;和&thinsp;<code>static</code>方法&thinsp;不能被<code>abstract</code>修饰，即&thinsp;它们&thinsp;不能被抽象。</p>
</li>
<li><p>抽象方法&thinsp;在其所在抽象类的非抽象子类中，必须被实现。</p>
</li>
</ol>
<h2 id="第9章-2-接口"><a href="#第9章-2-接口" class="headerlink" title="第9章-2 接口"></a><a href="#index_9-2">第9章-2 接口</a></h2><h2 id="第9章-3-完全解耦"><a href="#第9章-3-完全解耦" class="headerlink" title="第9章-3 完全解耦"></a><a href="#index_9-3">第9章-3 完全解耦</a></h2><h2 id="第9章-4-Java中的多重继承"><a href="#第9章-4-Java中的多重继承" class="headerlink" title="第9章-4 Java中的多重继承"></a><a href="#index_9-4">第9章-4 Java中的多重继承</a></h2><h2 id="第9章-5-通过继承来拓展接口"><a href="#第9章-5-通过继承来拓展接口" class="headerlink" title="第9章-5 通过继承来拓展接口"></a><a href="#index_9-5">第9章-5 通过继承来拓展接口</a></h2><h2 id="第9章-6-适配接口"><a href="#第9章-6-适配接口" class="headerlink" title="第9章-6 适配接口"></a><a href="#index_9-6">第9章-6 适配接口</a></h2><h2 id="第9章-7-接口中的域"><a href="#第9章-7-接口中的域" class="headerlink" title="第9章-7 接口中的域"></a><a href="#index_9-7">第9章-7 接口中的域</a></h2><h2 id="第9章-8-嵌套接口"><a href="#第9章-8-嵌套接口" class="headerlink" title="第9章-8 嵌套接口"></a><a href="#index_9-8">第9章-8 嵌套接口</a></h2><h2 id="第9章-9-接口与工厂"><a href="#第9章-9-接口与工厂" class="headerlink" title="第9章-9 接口与工厂"></a><a href="#index_9-9">第9章-9 接口与工厂</a></h2><h2 id="第9章-10-总结"><a href="#第9章-10-总结" class="headerlink" title="第9章-10 总结"></a><a href="#index_9-10">第9章-10 总结</a></h2><h1 id="第10章-内部类"><a href="#第10章-内部类" class="headerlink" title="第10章 内部类"></a><a href="#index_10">第10章 内部类</a></h1><h2 id="第10章-1-创建内部类"><a href="#第10章-1-创建内部类" class="headerlink" title="第10章-1 创建内部类"></a><a href="#index_10-1">第10章-1 创建内部类</a></h2><h2 id="第10章-2-链接到外部类"><a href="#第10章-2-链接到外部类" class="headerlink" title="第10章-2 链接到外部类"></a><a href="#index_10-2">第10章-2 链接到外部类</a></h2><h2 id="第10章-3-使用-this与-new"><a href="#第10章-3-使用-this与-new" class="headerlink" title="第10章-3 使用.this与.new"></a><a href="#index_10-3">第10章-3 使用.this与.new</a></h2><h2 id="第10章-4-内部类与向上转型"><a href="#第10章-4-内部类与向上转型" class="headerlink" title="第10章-4 内部类与向上转型"></a><a href="#index_10-4">第10章-4 内部类与向上转型</a></h2><h2 id="第10章-5-在方法和作用域内的内部类"><a href="#第10章-5-在方法和作用域内的内部类" class="headerlink" title="第10章-5 在方法和作用域内的内部类"></a><a href="#index_10-5">第10章-5 在方法和作用域内的内部类</a></h2><h2 id="第10章-6-匿名内部类"><a href="#第10章-6-匿名内部类" class="headerlink" title="第10章-6 匿名内部类"></a><a href="#index_10-6">第10章-6 匿名内部类</a></h2><h2 id="第10章-7-嵌套类"><a href="#第10章-7-嵌套类" class="headerlink" title="第10章-7 嵌套类"></a><a href="#index_10-7">第10章-7 嵌套类</a></h2><h2 id="第10章-8-为什么需要内部类"><a href="#第10章-8-为什么需要内部类" class="headerlink" title="第10章-8 为什么需要内部类"></a><a href="#index_10-8">第10章-8 为什么需要内部类</a></h2><h2 id="第10章-9-内部类的继承"><a href="#第10章-9-内部类的继承" class="headerlink" title="第10章-9 内部类的继承"></a><a href="#index_10-9">第10章-9 内部类的继承</a></h2><h2 id="第10章-10-内部类可以被覆盖吗"><a href="#第10章-10-内部类可以被覆盖吗" class="headerlink" title="第10章-10 内部类可以被覆盖吗"></a><a href="#index_10-10">第10章-10 内部类可以被覆盖吗</a></h2><h2 id="第10章-11-局部内部类"><a href="#第10章-11-局部内部类" class="headerlink" title="第10章-11 局部内部类"></a><a href="#index_10-11">第10章-11 局部内部类</a></h2><h2 id="第10章-12-内部类标识符"><a href="#第10章-12-内部类标识符" class="headerlink" title="第10章-12 内部类标识符"></a><a href="#index_10-12">第10章-12 内部类标识符</a></h2><h2 id="第10章-13-总结"><a href="#第10章-13-总结" class="headerlink" title="第10章-13 总结"></a><a href="#index_10-13">第10章-13 总结</a></h2><h1 id="第11章-持有对象"><a href="#第11章-持有对象" class="headerlink" title="第11章 持有对象"></a><a href="#index_11">第11章 持有对象</a></h1><h2 id="第11章-1-泛型和类型安全的容器"><a href="#第11章-1-泛型和类型安全的容器" class="headerlink" title="第11章-1 泛型和类型安全的容器"></a><a href="#index_11-1">第11章-1 泛型和类型安全的容器</a></h2><h2 id="第11章-2-基本概念"><a href="#第11章-2-基本概念" class="headerlink" title="第11章-2 基本概念"></a><a href="#index_11-2">第11章-2 基本概念</a></h2><h2 id="第11章-3-添加一组元素"><a href="#第11章-3-添加一组元素" class="headerlink" title="第11章-3 添加一组元素"></a><a href="#index_11-3">第11章-3 添加一组元素</a></h2><h2 id="第11章-4-容器的打印"><a href="#第11章-4-容器的打印" class="headerlink" title="第11章-4 容器的打印"></a><a href="#index_11-4">第11章-4 容器的打印</a></h2><h2 id="第11章-5-List（原理-amp-简介）"><a href="#第11章-5-List（原理-amp-简介）" class="headerlink" title="第11章-5 List（原理 &amp; 简介）"></a><a href="#index_11-5">第11章-5 List（原理 &amp; 简介）</a></h2><h2 id="第11章-6-迭代器"><a href="#第11章-6-迭代器" class="headerlink" title="第11章-6 迭代器"></a><a href="#index_11-6">第11章-6 迭代器</a></h2><h2 id="第11章-7-LinkedList"><a href="#第11章-7-LinkedList" class="headerlink" title="第11章-7 LinkedList"></a><a href="#index_11-7">第11章-7 LinkedList</a></h2><h2 id="第11章-8-Stack"><a href="#第11章-8-Stack" class="headerlink" title="第11章-8 Stack"></a><a href="#index_11-8">第11章-8 Stack</a></h2><h2 id="第11章-9-Set"><a href="#第11章-9-Set" class="headerlink" title="第11章-9 Set"></a><a href="#index_11-9">第11章-9 Set</a></h2><h2 id="第11章-10-Map"><a href="#第11章-10-Map" class="headerlink" title="第11章-10 Map"></a><a href="#index_11-10">第11章-10 Map</a></h2><h2 id="第11章-11-Queue"><a href="#第11章-11-Queue" class="headerlink" title="第11章-11 Queue"></a><a href="#index_11-11">第11章-11 Queue</a></h2><h2 id="第11章-12-Collection和Iterator"><a href="#第11章-12-Collection和Iterator" class="headerlink" title="第11章-12 Collection和Iterator"></a><a href="#index_11-12">第11章-12 Collection和Iterator</a></h2><h2 id="第11章-13-Foreach与迭代器"><a href="#第11章-13-Foreach与迭代器" class="headerlink" title="第11章-13 Foreach与迭代器"></a><a href="#index_11-13">第11章-13 Foreach与迭代器</a></h2><h3 id="第11章-13-1-适配器方法惯用法→示例源码说明"><a href="#第11章-13-1-适配器方法惯用法→示例源码说明" class="headerlink" title="第11章-13-1 适配器方法惯用法→示例源码说明"></a><a href="#index_11-13-1">第11章-13-1 适配器方法惯用法→示例源码说明</a></h3><h2 id="第11章-14-总结"><a href="#第11章-14-总结" class="headerlink" title="第11章-14 总结"></a><a href="#index_11-14">第11章-14 总结</a></h2><h1 id="第12章-通过异常处理错误"><a href="#第12章-通过异常处理错误" class="headerlink" title="第12章 通过异常处理错误"></a><a href="#index_12">第12章 通过异常处理错误</a></h1><h2 id="第12章-1-概念"><a href="#第12章-1-概念" class="headerlink" title="第12章-1 概念"></a><a href="#index_12-1">第12章-1 概念</a></h2><h2 id="第12章-2-基本异常"><a href="#第12章-2-基本异常" class="headerlink" title="第12章-2 基本异常"></a><a href="#index_12-2">第12章-2 基本异常</a></h2><h3 id="第12章-2-1-捕获异常参数"><a href="#第12章-2-1-捕获异常参数" class="headerlink" title="第12章-2-1 捕获异常参数"></a><a href="#index_12-2-1">第12章-2-1 捕获异常参数</a></h3><h2 id="第12章-3-捕获异常"><a href="#第12章-3-捕获异常" class="headerlink" title="第12章-3 捕获异常"></a><a href="#index_12-3">第12章-3 捕获异常</a></h2><h3 id="第12章-3-1-try块"><a href="#第12章-3-1-try块" class="headerlink" title="第12章-3-1 try块"></a><a href="#index_12-3-1">第12章-3-1 try块</a></h3><h3 id="第12章-3-2-异常处理程序"><a href="#第12章-3-2-异常处理程序" class="headerlink" title="第12章-3-2 异常处理程序"></a><a href="#index_12-3-2">第12章-3-2 异常处理程序</a></h3><h2 id="第12章-4-创建自定义异常"><a href="#第12章-4-创建自定义异常" class="headerlink" title="第12章-4 创建自定义异常"></a><a href="#index_12-4">第12章-4 创建自定义异常</a></h2><h3 id="第12章-4-1-异常与记录日志"><a href="#第12章-4-1-异常与记录日志" class="headerlink" title="第12章-4-1 异常与记录日志"></a><a href="#index_12-4-1">第12章-4-1 异常与记录日志</a></h3><h2 id="第12章-5-异常说明"><a href="#第12章-5-异常说明" class="headerlink" title="第12章-5 异常说明"></a><a href="#index_12-5">第12章-5 异常说明</a></h2><h2 id="第12章-6-捕获所有异常"><a href="#第12章-6-捕获所有异常" class="headerlink" title="第12章-6 捕获所有异常"></a><a href="#index_12-6">第12章-6 捕获所有异常</a></h2><h3 id="第12章-6-1-栈轨迹"><a href="#第12章-6-1-栈轨迹" class="headerlink" title="第12章-6-1 栈轨迹"></a><a href="#index_12-6-1">第12章-6-1 栈轨迹</a></h3><h3 id="第12章-6-2-重新抛出异常"><a href="#第12章-6-2-重新抛出异常" class="headerlink" title="第12章-6-2 重新抛出异常"></a><a href="#index_12-6-2">第12章-6-2 重新抛出异常</a></h3><h3 id="第12章-6-3-异常链"><a href="#第12章-6-3-异常链" class="headerlink" title="第12章-6-3 异常链"></a><a href="#index_12-6-3">第12章-6-3 异常链</a></h3><h2 id="第12章-7-Java标准异常"><a href="#第12章-7-Java标准异常" class="headerlink" title="第12章-7 Java标准异常"></a><a href="#index_12-7">第12章-7 Java标准异常</a></h2><h3 id="第12章-7-1-特例：RuntimeException"><a href="#第12章-7-1-特例：RuntimeException" class="headerlink" title="第12章-7-1 特例：RuntimeException"></a><a href="#index_12-7-1">第12章-7-1 特例：RuntimeException</a></h3><h2 id="第12章-8-使用finally进行清理"><a href="#第12章-8-使用finally进行清理" class="headerlink" title="第12章-8 使用finally进行清理"></a><a href="#index_12-8">第12章-8 使用finally进行清理</a></h2><h3 id="第12章-8-1-finally用来做什么"><a href="#第12章-8-1-finally用来做什么" class="headerlink" title="第12章-8-1 finally用来做什么"></a><a href="#index_12-8-1">第12章-8-1 finally用来做什么</a></h3><h3 id="第12章-8-2-在return中使用finally"><a href="#第12章-8-2-在return中使用finally" class="headerlink" title="第12章-8-2 在return中使用finally"></a><a href="#index_12-8-2">第12章-8-2 在return中使用finally</a></h3><h3 id="第12章-8-3-缺憾：异常缺失"><a href="#第12章-8-3-缺憾：异常缺失" class="headerlink" title="第12章-8-3 缺憾：异常缺失"></a><a href="#index_12-8-3">第12章-8-3 缺憾：异常缺失</a></h3><h2 id="第12章-9-异常的限制"><a href="#第12章-9-异常的限制" class="headerlink" title="第12章-9 异常的限制"></a><a href="#index_12-9">第12章-9 异常的限制</a></h2><h2 id="第12章-10-构造器"><a href="#第12章-10-构造器" class="headerlink" title="第12章-10 构造器"></a><a href="#index_12-10">第12章-10 构造器</a></h2><h2 id="第12章-11-异常匹配"><a href="#第12章-11-异常匹配" class="headerlink" title="第12章-11 异常匹配"></a><a href="#index_12-11">第12章-11 异常匹配</a></h2><h2 id="第12章-12-其他可选方式"><a href="#第12章-12-其他可选方式" class="headerlink" title="第12章-12 其他可选方式"></a><a href="#index_12-12">第12章-12 其他可选方式</a></h2><h3 id="第12章-12-1-历史"><a href="#第12章-12-1-历史" class="headerlink" title="第12章-12-1 历史"></a><a href="#index_12-12-1">第12章-12-1 历史</a></h3><h3 id="第12章-12-2-观点"><a href="#第12章-12-2-观点" class="headerlink" title="第12章-12-2 观点"></a><a href="#index_12-12-2">第12章-12-2 观点</a></h3><h3 id="第12章-12-3-把异常传递给控制台"><a href="#第12章-12-3-把异常传递给控制台" class="headerlink" title="第12章-12-3 把异常传递给控制台"></a><a href="#index_12-12-3">第12章-12-3 把异常传递给控制台</a></h3><h3 id="第12章-12-4-把“被检查的异常”转换为“不检查的异常”"><a href="#第12章-12-4-把“被检查的异常”转换为“不检查的异常”" class="headerlink" title="第12章-12-4 把“被检查的异常”转换为“不检查的异常”"></a><a href="#index_12-12-4">第12章-12-4 把“被检查的异常”转换为“不检查的异常”</a></h3><h2 id="第12章-13-异常使用指南"><a href="#第12章-13-异常使用指南" class="headerlink" title="第12章-13 异常使用指南"></a><a href="#index_12-13">第12章-13 异常使用指南</a></h2><h2 id="第12章-14-总结"><a href="#第12章-14-总结" class="headerlink" title="第12章-14 总结"></a><a href="#index_12-14">第12章-14 总结</a></h2><h1 id="第13章-字符串"><a href="#第13章-字符串" class="headerlink" title="第13章 字符串"></a><a href="#index_13">第13章 字符串</a></h1><h2 id="第13章-1-不可变String"><a href="#第13章-1-不可变String" class="headerlink" title="第13章-1 不可变String"></a><a href="#index_13-1">第13章-1 不可变String</a></h2><h2 id="第13章-2-重载“-”与StringBuilder"><a href="#第13章-2-重载“-”与StringBuilder" class="headerlink" title="第13章-2 重载“+”与StringBuilder"></a><a href="#index_13-2">第13章-2 重载“+”与StringBuilder</a></h2><h2 id="第13章-3-无意识的递归"><a href="#第13章-3-无意识的递归" class="headerlink" title="第13章-3 无意识的递归"></a><a href="#index_13-3">第13章-3 无意识的递归</a></h2><h2 id="第13章-4-String上的操作"><a href="#第13章-4-String上的操作" class="headerlink" title="第13章-4 String上的操作"></a><a href="#index_13-4">第13章-4 String上的操作</a></h2><h2 id="第13章-5-格式化输出"><a href="#第13章-5-格式化输出" class="headerlink" title="第13章-5 格式化输出"></a><a href="#index_13-5">第13章-5 格式化输出</a></h2><h3 id="第13章-5-4-格式化说明符"><a href="#第13章-5-4-格式化说明符" class="headerlink" title="第13章-5-4 格式化说明符"></a><a href="#index_13-5-4">第13章-5-4 格式化说明符</a></h3><h2 id="第13章-6-正则表达式"><a href="#第13章-6-正则表达式" class="headerlink" title="第13章-6 正则表达式"></a><a href="#index_13-6">第13章-6 正则表达式</a></h2><h2 id="第13章-7-扫描输入"><a href="#第13章-7-扫描输入" class="headerlink" title="第13章-7 扫描输入"></a><a href="#index_13-7">第13章-7 扫描输入</a></h2><h2 id="第13章-8-StringTokenizer（已废弃）"><a href="#第13章-8-StringTokenizer（已废弃）" class="headerlink" title="第13章-8 StringTokenizer（已废弃）"></a><a href="#index_13-8">第13章-8 StringTokenizer（已废弃）</a></h2><h2 id="第13章-9-总结"><a href="#第13章-9-总结" class="headerlink" title="第13章-9 总结"></a><a href="#index_13-9">第13章-9 总结</a></h2><h1 id="第14章-类型信息（RTTI）"><a href="#第14章-类型信息（RTTI）" class="headerlink" title="第14章 类型信息（RTTI）"></a><a href="#index_14">第14章 类型信息（RTTI）</a></h1><h2 id="第14章-1-为什么需要RTTI"><a href="#第14章-1-为什么需要RTTI" class="headerlink" title="第14章-1 为什么需要RTTI"></a><a href="#index_14-1">第14章-1 为什么需要RTTI</a></h2><h2 id="第14章-2-Class对象"><a href="#第14章-2-Class对象" class="headerlink" title="第14章-2 Class对象"></a><a href="#index_14-2">第14章-2 Class对象</a></h2><h3 id="第14章-2-1-类字面量"><a href="#第14章-2-1-类字面量" class="headerlink" title="第14章-2-1 类字面量"></a><a href="#index_14-2-1">第14章-2-1 类字面量</a></h3><h3 id="第14章-2-2-泛化的Class引用"><a href="#第14章-2-2-泛化的Class引用" class="headerlink" title="第14章-2-2 泛化的Class引用"></a><a href="#index_14-2-2">第14章-2-2 泛化的Class引用</a></h3><h3 id="第14章-2-3-类的转换（原：新的转型语法）"><a href="#第14章-2-3-类的转换（原：新的转型语法）" class="headerlink" title="第14章-2-3 类的转换（原：新的转型语法）"></a><a href="#index_14-2-3">第14章-2-3 类的转换（原：新的转型语法）</a></h3><h2 id="第14章-3-类型转换前先做检查"><a href="#第14章-3-类型转换前先做检查" class="headerlink" title="第14章-3 类型转换前先做检查"></a><a href="#index_14-3">第14章-3 类型转换前先做检查</a></h2><h2 id="第14章-4-注册工厂"><a href="#第14章-4-注册工厂" class="headerlink" title="第14章-4 注册工厂"></a><a href="#index_14-4">第14章-4 注册工厂</a></h2><h2 id="第14章-5-instanceof与Class的等价性"><a href="#第14章-5-instanceof与Class的等价性" class="headerlink" title="第14章-5 instanceof与Class的等价性"></a><a href="#index_14-5">第14章-5 instanceof与Class的等价性</a></h2><h2 id="第14章-6-反射：运行时的类信息"><a href="#第14章-6-反射：运行时的类信息" class="headerlink" title="第14章-6 反射：运行时的类信息"></a><a href="#index_14-6">第14章-6 反射：运行时的类信息</a></h2><h3 id="第14章-6-1-类方法提取器"><a href="#第14章-6-1-类方法提取器" class="headerlink" title="第14章-6-1 类方法提取器"></a><a href="#index_14-6-1">第14章-6-1 类方法提取器</a></h3><h2 id="第14章-7-动态代理"><a href="#第14章-7-动态代理" class="headerlink" title="第14章-7 动态代理"></a><a href="#index_14-7">第14章-7 动态代理</a></h2><h2 id="第14章-8-空对象"><a href="#第14章-8-空对象" class="headerlink" title="第14章-8 空对象"></a><a href="#index_14-8">第14章-8 空对象</a></h2><h3 id="第14章-8-1-模拟对象与桩"><a href="#第14章-8-1-模拟对象与桩" class="headerlink" title="第14章-8-1 模拟对象与桩"></a><a href="#index_14-8-1">第14章-8-1 模拟对象与桩</a></h3><h2 id="第14章-9-接口与类型信息"><a href="#第14章-9-接口与类型信息" class="headerlink" title="第14章-9 接口与类型信息"></a><a href="#index_14-9">第14章-9 接口与类型信息</a></h2><h2 id="第14章-10-总结"><a href="#第14章-10-总结" class="headerlink" title="第14章-10 总结"></a><a href="#index_14-10">第14章-10 总结</a></h2><h1 id="第15章-泛型"><a href="#第15章-泛型" class="headerlink" title="第15章 泛型"></a><a href="#index_15">第15章 泛型</a></h1><h2 id="第15章-1-与C-比较"><a href="#第15章-1-与C-比较" class="headerlink" title="第15章-1 与C++比较"></a><a href="#index_15-1">第15章-1 与C++比较</a></h2><h2 id="第15章-2-简单泛型"><a href="#第15章-2-简单泛型" class="headerlink" title="第15章-2 简单泛型"></a><a href="#index_15-2">第15章-2 简单泛型</a></h2><h3 id="第15章-2-1-一个元祖类库"><a href="#第15章-2-1-一个元祖类库" class="headerlink" title="第15章-2-1 一个元祖类库"></a><a href="#index_15-2-1">第15章-2-1 一个元祖类库</a></h3><h3 id="第15章-2-2-一个堆栈类"><a href="#第15章-2-2-一个堆栈类" class="headerlink" title="第15章-2-2 一个堆栈类"></a><a href="#index_15-2-2">第15章-2-2 一个堆栈类</a></h3><h3 id="第15章-2-3-RandomList"><a href="#第15章-2-3-RandomList" class="headerlink" title="第15章-2-3 RandomList"></a><a href="#index_15-2-3">第15章-2-3 RandomList</a></h3><h2 id="第15章-3-泛型接口"><a href="#第15章-3-泛型接口" class="headerlink" title="第15章-3 泛型接口"></a><a href="#index_15-3">第15章-3 泛型接口</a></h2><h2 id="第15章-4-泛型方法"><a href="#第15章-4-泛型方法" class="headerlink" title="第15章-4 泛型方法"></a><a href="#index_15-4">第15章-4 泛型方法</a></h2><h3 id="第15章-4-1-杠杆利用类型参数判断"><a href="#第15章-4-1-杠杆利用类型参数判断" class="headerlink" title="第15章-4-1 杠杆利用类型参数判断"></a><a href="#index_15-4-1">第15章-4-1 杠杆利用类型参数判断</a></h3><h3 id="第15章-4-2-可变参数与泛型方法"><a href="#第15章-4-2-可变参数与泛型方法" class="headerlink" title="第15章-4-2 可变参数与泛型方法"></a><a href="#index_15-4-2">第15章-4-2 可变参数与泛型方法</a></h3><h3 id="第15章-4-3-用于Generator的泛型方法"><a href="#第15章-4-3-用于Generator的泛型方法" class="headerlink" title="第15章-4-3 用于Generator的泛型方法"></a><a href="#index_15-4-3">第15章-4-3 用于Generator的泛型方法</a></h3><h3 id="第15章-4-4-一个通用的Generator"><a href="#第15章-4-4-一个通用的Generator" class="headerlink" title="第15章-4-4 一个通用的Generator"></a><a href="#index_15-4-4">第15章-4-4 一个通用的Generator</a></h3><h3 id="第15章-4-5-简化元祖的使用"><a href="#第15章-4-5-简化元祖的使用" class="headerlink" title="第15章-4-5 简化元祖的使用"></a><a href="#index_15-4-5">第15章-4-5 简化元祖的使用</a></h3><h3 id="第15章-4-6-一个Set实用工具"><a href="#第15章-4-6-一个Set实用工具" class="headerlink" title="第15章-4-6 一个Set实用工具"></a><a href="#index_15-4-6">第15章-4-6 一个Set实用工具</a></h3><h2 id="第15章-5-匿名内部类"><a href="#第15章-5-匿名内部类" class="headerlink" title="第15章-5 匿名内部类"></a><a href="#index_15-5">第15章-5 匿名内部类</a></h2><h2 id="第15章-6-构建复杂模型"><a href="#第15章-6-构建复杂模型" class="headerlink" title="第15章-6 构建复杂模型"></a><a href="#index_15-6">第15章-6 构建复杂模型</a></h2><h2 id="第15章-7-擦除的神秘之处"><a href="#第15章-7-擦除的神秘之处" class="headerlink" title="第15章-7 擦除的神秘之处"></a><a href="#index_15-7">第15章-7 擦除的神秘之处</a></h2><h3 id="第15章-7-1-C-的方式"><a href="#第15章-7-1-C-的方式" class="headerlink" title="第15章-7-1 C++的方式"></a><a href="#index_15-7-1">第15章-7-1 C++的方式</a></h3><h3 id="第15章-7-2-迁移兼容性"><a href="#第15章-7-2-迁移兼容性" class="headerlink" title="第15章-7-2 迁移兼容性"></a><a href="#index_15-7-2">第15章-7-2 迁移兼容性</a></h3><h3 id="第15章-7-3-擦除的问题"><a href="#第15章-7-3-擦除的问题" class="headerlink" title="第15章-7-3 擦除的问题"></a><a href="#index_15-7-3">第15章-7-3 擦除的问题</a></h3><h3 id="第15章-7-4-边界处的动作"><a href="#第15章-7-4-边界处的动作" class="headerlink" title="第15章-7-4 边界处的动作"></a><a href="#index_15-7-4">第15章-7-4 边界处的动作</a></h3><h2 id="第15章-8-擦除的补偿"><a href="#第15章-8-擦除的补偿" class="headerlink" title="第15章-8 擦除的补偿"></a><a href="#index_15-">第15章-8 擦除的补偿</a></h2><h3 id="第15章-8-1-创建类型实例"><a href="#第15章-8-1-创建类型实例" class="headerlink" title="第15章-8-1 创建类型实例"></a><a href="#index_15-8-1">第15章-8-1 创建类型实例</a></h3><h3 id="第15章-8-2-泛型数组"><a href="#第15章-8-2-泛型数组" class="headerlink" title="第15章-8-2 泛型数组"></a><a href="#index_15-8-2">第15章-8-2 泛型数组</a></h3><h2 id="第15章-9-边界"><a href="#第15章-9-边界" class="headerlink" title="第15章-9 边界"></a><a href="#index_15-9">第15章-9 边界</a></h2><h2 id="第15章-10-通配符"><a href="#第15章-10-通配符" class="headerlink" title="第15章-10 通配符"></a><a href="#index_15-10">第15章-10 通配符</a></h2><h3 id="第15章-10-1-编译器有多聪明"><a href="#第15章-10-1-编译器有多聪明" class="headerlink" title="第15章-10-1 编译器有多聪明"></a><a href="#index_15-10-1">第15章-10-1 编译器有多聪明</a></h3><h3 id="第15章-10-2-逆变"><a href="#第15章-10-2-逆变" class="headerlink" title="第15章-10-2 逆变"></a><a href="#index_15-10-2">第15章-10-2 逆变</a></h3><h3 id="第15章-10-3-无界通配符"><a href="#第15章-10-3-无界通配符" class="headerlink" title="第15章-10-3 无界通配符"></a><a href="#index_15-10-3">第15章-10-3 无界通配符</a></h3><h3 id="第15章-10-4-捕获转换（通配符捕获）"><a href="#第15章-10-4-捕获转换（通配符捕获）" class="headerlink" title="第15章-10-4 捕获转换（通配符捕获）"></a><a href="#index_15-10-4">第15章-10-4 捕获转换（通配符捕获）</a></h3><h2 id="第15章-11-问题"><a href="#第15章-11-问题" class="headerlink" title="第15章-11 问题"></a><a href="#index_15-11">第15章-11 问题</a></h2><h3 id="第15章-11-1-任何基本类型都不能作为类型"><a href="#第15章-11-1-任何基本类型都不能作为类型" class="headerlink" title="第15章-11-1 任何基本类型都不能作为类型"></a><a href="#index_15-11-1">第15章-11-1 任何基本类型都不能作为类型</a></h3><h3 id="第15章-11-2-实现参数化接口"><a href="#第15章-11-2-实现参数化接口" class="headerlink" title="第15章-11-2 实现参数化接口"></a><a href="#index_15-11-2">第15章-11-2 实现参数化接口</a></h3><h3 id="第15章-11-3-转型和警告"><a href="#第15章-11-3-转型和警告" class="headerlink" title="第15章-11-3 转型和警告"></a><a href="#index_15-11-3">第15章-11-3 转型和警告</a></h3><h3 id="第15章-11-4-重载"><a href="#第15章-11-4-重载" class="headerlink" title="第15章-11-4 重载"></a><a href="#index_15-11-4">第15章-11-4 重载</a></h3><h3 id="第15章-11-5-基类劫持了接口"><a href="#第15章-11-5-基类劫持了接口" class="headerlink" title="第15章-11-5 基类劫持了接口"></a><a href="#index_15-11-5">第15章-11-5 基类劫持了接口</a></h3><h2 id="第15章-12-自限定的类型"><a href="#第15章-12-自限定的类型" class="headerlink" title="第15章-12 自限定的类型"></a><a href="#index_15-12">第15章-12 自限定的类型</a></h2><h3 id="第15章-12-1-古怪的循环泛型"><a href="#第15章-12-1-古怪的循环泛型" class="headerlink" title="第15章-12-1 古怪的循环泛型"></a><a href="#index_15-12-1">第15章-12-1 古怪的循环泛型</a></h3><h3 id="第15章-12-2-自限定"><a href="#第15章-12-2-自限定" class="headerlink" title="第15章-12-2 自限定"></a><a href="#index_15-12-2">第15章-12-2 自限定</a></h3><h3 id="第15章-12-3-参数协变"><a href="#第15章-12-3-参数协变" class="headerlink" title="第15章-12-3 参数协变"></a><a href="#index_15-12-3">第15章-12-3 参数协变</a></h3><h2 id="第15章-13-动态类型安全"><a href="#第15章-13-动态类型安全" class="headerlink" title="第15章-13 动态类型安全"></a><a href="#index_15-13">第15章-13 动态类型安全</a></h2><h2 id="第15章-14-异常"><a href="#第15章-14-异常" class="headerlink" title="第15章-14 异常"></a><a href="#index_15-14">第15章-14 异常</a></h2><h2 id="第15章-15-混型"><a href="#第15章-15-混型" class="headerlink" title="第15章-15 混型"></a><a href="#index_15-15">第15章-15 混型</a></h2><h3 id="第15章-15-1-C-中的混型"><a href="#第15章-15-1-C-中的混型" class="headerlink" title="第15章-15-1 C++中的混型"></a><a href="#index_15-15-1">第15章-15-1 C++中的混型</a></h3><h3 id="第15章-15-2-与接口混合"><a href="#第15章-15-2-与接口混合" class="headerlink" title="第15章-15-2 与接口混合"></a><a href="#index_15-15-2">第15章-15-2 与接口混合</a></h3><h3 id="第15章-15-3-使用装饰器模式"><a href="#第15章-15-3-使用装饰器模式" class="headerlink" title="第15章-15-3 使用装饰器模式"></a><a href="#index_15-15-3">第15章-15-3 使用装饰器模式</a></h3><h3 id="第15章-15-4-与动态代理混合"><a href="#第15章-15-4-与动态代理混合" class="headerlink" title="第15章-15-4 与动态代理混合"></a><a href="#index_15-15-4">第15章-15-4 与动态代理混合</a></h3><h2 id="第15章-16-潜在类型机制"><a href="#第15章-16-潜在类型机制" class="headerlink" title="第15章-16 潜在类型机制"></a><a href="#index_15-16">第15章-16 潜在类型机制</a></h2><h2 id="第15章-17-对缺乏潜在类型机制的补偿"><a href="#第15章-17-对缺乏潜在类型机制的补偿" class="headerlink" title="第15章-17 对缺乏潜在类型机制的补偿"></a><a href="#index_15-17">第15章-17 对缺乏潜在类型机制的补偿</a></h2><h3 id="第15章-17-1-反射"><a href="#第15章-17-1-反射" class="headerlink" title="第15章-17-1 反射"></a><a href="#index_15-17-1">第15章-17-1 反射</a></h3><h3 id="第15章-17-2-将一个方法应用于序列"><a href="#第15章-17-2-将一个方法应用于序列" class="headerlink" title="第15章-17-2 将一个方法应用于序列"></a><a href="#index_15-17-2">第15章-17-2 将一个方法应用于序列</a></h3><h3 id="第15章-17-3-当你并为碰巧拥有正确的接口时"><a href="#第15章-17-3-当你并为碰巧拥有正确的接口时" class="headerlink" title="第15章-17-3 当你并为碰巧拥有正确的接口时"></a><a href="#index_15-17-3">第15章-17-3 当你并为碰巧拥有正确的接口时</a></h3><h3 id="第15章-17-4-用适配器仿真潜在类型机制"><a href="#第15章-17-4-用适配器仿真潜在类型机制" class="headerlink" title="第15章-17-4 用适配器仿真潜在类型机制"></a><a href="#index_15-17-4">第15章-17-4 用适配器仿真潜在类型机制</a></h3><h2 id="第15章-18-将函数对象用作策略"><a href="#第15章-18-将函数对象用作策略" class="headerlink" title="第15章-18 将函数对象用作策略"></a><a href="#index_15-18">第15章-18 将函数对象用作策略</a></h2><h2 id="第15章-19-总结：转型真的如此之糟吗？"><a href="#第15章-19-总结：转型真的如此之糟吗？" class="headerlink" title="第15章-19 总结：转型真的如此之糟吗？"></a><a href="#index_15-19">第15章-19 总结：转型真的如此之糟吗？</a></h2><h3 id="第15章-19-1-进阶读物"><a href="#第15章-19-1-进阶读物" class="headerlink" title="第15章-19-1 进阶读物"></a><a href="#index_15-19-1">第15章-19-1 进阶读物</a></h3><h1 id="第16章-数组"><a href="#第16章-数组" class="headerlink" title="第16章 数组"></a><a href="#index_16">第16章 数组</a></h1><h2 id="第16章-1-数组为什么特殊"><a href="#第16章-1-数组为什么特殊" class="headerlink" title="第16章-1 数组为什么特殊"></a><a href="#index_16-1">第16章-1 数组为什么特殊</a></h2><h2 id="第16章-2-数组是第一级对象"><a href="#第16章-2-数组是第一级对象" class="headerlink" title="第16章-2 数组是第一级对象"></a><a href="#index_16-2">第16章-2 数组是第一级对象</a></h2><h2 id="第16章-3-返回一个数组"><a href="#第16章-3-返回一个数组" class="headerlink" title="第16章-3 返回一个数组"></a><a href="#index_16-3">第16章-3 返回一个数组</a></h2><h2 id="第16章-4-多维数组"><a href="#第16章-4-多维数组" class="headerlink" title="第16章-4 多维数组"></a><a href="#index_16-4">第16章-4 多维数组</a></h2><h2 id="第16章-5-数组与泛型"><a href="#第16章-5-数组与泛型" class="headerlink" title="第16章-5 数组与泛型"></a><a href="#index_16-5">第16章-5 数组与泛型</a></h2><h2 id="第16章-6-创建测试数据"><a href="#第16章-6-创建测试数据" class="headerlink" title="第16章-6 创建测试数据"></a><a href="#index_16-6">第16章-6 创建测试数据</a></h2><h3 id="第16章-6-1-Arrays-fill"><a href="#第16章-6-1-Arrays-fill" class="headerlink" title="第16章-6-1 Arrays.fill()"></a><a href="#index_16-6-1">第16章-6-1 Arrays.fill()</a></h3><h3 id="第16章-6-2-数据生成器"><a href="#第16章-6-2-数据生成器" class="headerlink" title="第16章-6-2 数据生成器"></a><a href="#index_16-6-2">第16章-6-2 数据生成器</a></h3><h3 id="第16章-6-3-从Generator中创建数组"><a href="#第16章-6-3-从Generator中创建数组" class="headerlink" title="第16章-6-3 从Generator中创建数组"></a><a href="#index_16-6-3">第16章-6-3 从Generator中创建数组</a></h3><h2 id="第16章-7-Arrays实用功能"><a href="#第16章-7-Arrays实用功能" class="headerlink" title="第16章-7 Arrays实用功能"></a><a href="#index_16-7">第16章-7 Arrays实用功能</a></h2><h3 id="第16章-7-1-复制数组"><a href="#第16章-7-1-复制数组" class="headerlink" title="第16章-7-1 复制数组"></a><a href="#index_16-7-1">第16章-7-1 复制数组</a></h3><h3 id="第16章-7-2-数组的比较"><a href="#第16章-7-2-数组的比较" class="headerlink" title="第16章-7-2 数组的比较"></a><a href="#index_16-7-2">第16章-7-2 数组的比较</a></h3><h3 id="第16章-7-3-数组元素的比较"><a href="#第16章-7-3-数组元素的比较" class="headerlink" title="第16章-7-3 数组元素的比较"></a><a href="#index_16-7-3">第16章-7-3 数组元素的比较</a></h3><h3 id="第16章-7-4-数组排序"><a href="#第16章-7-4-数组排序" class="headerlink" title="第16章-7-4 数组排序"></a><a href="#index_16-7-4">第16章-7-4 数组排序</a></h3><h3 id="第16章-7-5-在已排序的数组中查找"><a href="#第16章-7-5-在已排序的数组中查找" class="headerlink" title="第16章-7-5 在已排序的数组中查找"></a><a href="#index_16-7-5">第16章-7-5 在已排序的数组中查找</a></h3><h2 id="第16章-8-总结"><a href="#第16章-8-总结" class="headerlink" title="第16章-8 总结"></a><a href="#index_16-8">第16章-8 总结</a></h2><h1 id="第17章-容器深入研究"><a href="#第17章-容器深入研究" class="headerlink" title="第17章 容器深入研究"></a><a href="#index_17">第17章 容器深入研究</a></h1><h2 id="第17章-1-完整容器分类法"><a href="#第17章-1-完整容器分类法" class="headerlink" title="第17章-1 完整容器分类法"></a><a href="#index_17-1">第17章-1 完整容器分类法</a></h2><h2 id="第17章-2-填充容器"><a href="#第17章-2-填充容器" class="headerlink" title="第17章-2 填充容器"></a><a href="#index_17-2">第17章-2 填充容器</a></h2><h3 id="第17章-2-1-一种Generator解决方案"><a href="#第17章-2-1-一种Generator解决方案" class="headerlink" title="第17章-2-1 一种Generator解决方案"></a><a href="#index_17-2-1">第17章-2-1 一种Generator解决方案</a></h3><h3 id="第17章-2-2-Map生成器"><a href="#第17章-2-2-Map生成器" class="headerlink" title="第17章-2-2 Map生成器"></a><a href="#index_17-2-2">第17章-2-2 Map生成器</a></h3><h3 id="第17章-2-3-使用Abstract类"><a href="#第17章-2-3-使用Abstract类" class="headerlink" title="第17章-2-3 使用Abstract类"></a><a href="#index_17-2-3">第17章-2-3 使用Abstract类</a></h3><h2 id="第17章-3-Collection的功能方法"><a href="#第17章-3-Collection的功能方法" class="headerlink" title="第17章-3 Collection的功能方法"></a><a href="#index_17-3">第17章-3 Collection的功能方法</a></h2><h2 id="第17章-4-可选操作"><a href="#第17章-4-可选操作" class="headerlink" title="第17章-4 可选操作"></a><a href="#index_17-4">第17章-4 可选操作</a></h2><h3 id="第17章-4-1-未获支持的操作"><a href="#第17章-4-1-未获支持的操作" class="headerlink" title="第17章-4-1 未获支持的操作"></a><a href="#index_17-4-1">第17章-4-1 未获支持的操作</a></h3><h2 id="第17章-5-List的功能方法"><a href="#第17章-5-List的功能方法" class="headerlink" title="第17章-5 List的功能方法"></a><a href="#index_17-5">第17章-5 List的功能方法</a></h2><h2 id="第17章-6-Set和存储排序"><a href="#第17章-6-Set和存储排序" class="headerlink" title="第17章-6 Set和存储排序"></a><a href="#index_17-6">第17章-6 Set和存储排序</a></h2><h3 id="第17章-6-1-SortedSet"><a href="#第17章-6-1-SortedSet" class="headerlink" title="第17章-6-1 SortedSet"></a><a href="#index_17-6-1">第17章-6-1 SortedSet</a></h3><h2 id="第17章-7-队列"><a href="#第17章-7-队列" class="headerlink" title="第17章-7 队列"></a><a href="#index_17-7">第17章-7 队列</a></h2><h3 id="第17章-7-1-优先级队列"><a href="#第17章-7-1-优先级队列" class="headerlink" title="第17章-7-1 优先级队列"></a><a href="#index_17-7-1">第17章-7-1 优先级队列</a></h3><h3 id="第17章-7-2-双向队列"><a href="#第17章-7-2-双向队列" class="headerlink" title="第17章-7-2 双向队列"></a><a href="#index_17-7-2">第17章-7-2 双向队列</a></h3><h2 id="第17章-8-理解Map"><a href="#第17章-8-理解Map" class="headerlink" title="第17章-8 理解Map"></a><a href="#index_17-8">第17章-8 理解Map</a></h2><h3 id="第17章-8-1-性能"><a href="#第17章-8-1-性能" class="headerlink" title="第17章-8-1 性能"></a><a href="#index_17-8-1">第17章-8-1 性能</a></h3><h3 id="第17章-8-2-SortedMap"><a href="#第17章-8-2-SortedMap" class="headerlink" title="第17章-8-2 SortedMap"></a><a href="#index_17-8-2">第17章-8-2 SortedMap</a></h3><h3 id="第17章-8-3-LinkedHashMap"><a href="#第17章-8-3-LinkedHashMap" class="headerlink" title="第17章-8-3 LinkedHashMap"></a><a href="#index_17-8-3">第17章-8-3 LinkedHashMap</a></h3><h2 id="第17章-9-散列与散列码"><a href="#第17章-9-散列与散列码" class="headerlink" title="第17章-9 散列与散列码"></a><a href="#index_17-9">第17章-9 散列与散列码</a></h2><h3 id="第17章-9-1-理解hashCode"><a href="#第17章-9-1-理解hashCode" class="headerlink" title="第17章-9-1 理解hashCode()"></a><a href="#index_17-9-1">第17章-9-1 理解hashCode()</a></h3><h3 id="第17章-9-2-为速度而散列"><a href="#第17章-9-2-为速度而散列" class="headerlink" title="第17章-9-2 为速度而散列"></a><a href="#index_17-9-2">第17章-9-2 为速度而散列</a></h3><h3 id="第17章-9-3-覆盖hashCode"><a href="#第17章-9-3-覆盖hashCode" class="headerlink" title="第17章-9-3 覆盖hashCode()"></a><a href="#index_17-9-3">第17章-9-3 覆盖hashCode()</a></h3><h2 id="第17章-10-选择接口的不同实现"><a href="#第17章-10-选择接口的不同实现" class="headerlink" title="第17章-10 选择接口的不同实现"></a><a href="#index_17-10">第17章-10 选择接口的不同实现</a></h2><h3 id="第17章-10-1-性能测试框架"><a href="#第17章-10-1-性能测试框架" class="headerlink" title="第17章-10-1 性能测试框架"></a><a href="#index_17-10-1">第17章-10-1 性能测试框架</a></h3><h3 id="第17章-10-2-对List的选择"><a href="#第17章-10-2-对List的选择" class="headerlink" title="第17章-10-2 对List的选择"></a><a href="#index_17-10-2">第17章-10-2 对List的选择</a></h3><h3 id="第17章-10-3-微基准测试的危险"><a href="#第17章-10-3-微基准测试的危险" class="headerlink" title="第17章-10-3 微基准测试的危险"></a><a href="#index_17-10-3">第17章-10-3 微基准测试的危险</a></h3><h3 id="第17章-10-4-对Set的选择"><a href="#第17章-10-4-对Set的选择" class="headerlink" title="第17章-10-4 对Set的选择"></a><a href="#index_17-10-4">第17章-10-4 对Set的选择</a></h3><h3 id="第17章-10-5-对Map的选择"><a href="#第17章-10-5-对Map的选择" class="headerlink" title="第17章-10-5 对Map的选择"></a><a href="#index_17-10-5">第17章-10-5 对Map的选择</a></h3><h2 id="第17章-11-实用方法"><a href="#第17章-11-实用方法" class="headerlink" title="第17章-11 实用方法"></a><a href="#index_17-11">第17章-11 实用方法</a></h2><h3 id="第17章-11-1-List的排序和查询"><a href="#第17章-11-1-List的排序和查询" class="headerlink" title="第17章-11.1 List的排序和查询"></a><a href="#index_17-11-1">第17章-11.1 List的排序和查询</a></h3><h3 id="第17章-11-2-设定Collection或Map为不可修改"><a href="#第17章-11-2-设定Collection或Map为不可修改" class="headerlink" title="第17章-11.2 设定Collection或Map为不可修改"></a><a href="#index_17-11-2">第17章-11.2 设定Collection或Map为不可修改</a></h3><h3 id="第17章-11-3-Collection或Map的同步控制"><a href="#第17章-11-3-Collection或Map的同步控制" class="headerlink" title="第17章-11.3 Collection或Map的同步控制"></a><a href="#index_17-11-3">第17章-11.3 Collection或Map的同步控制</a></h3><h2 id="第17章-12-持有引用"><a href="#第17章-12-持有引用" class="headerlink" title="第17章-12 持有引用"></a><a href="#index_17-12">第17章-12 持有引用</a></h2><h3 id="第17章-12-1-WeakHashMap"><a href="#第17章-12-1-WeakHashMap" class="headerlink" title="第17章-12.1 WeakHashMap"></a><a href="#index_17-12-1">第17章-12.1 WeakHashMap</a></h3><h2 id="第17章-13-Java-1-0-1-1的容器"><a href="#第17章-13-Java-1-0-1-1的容器" class="headerlink" title="第17章-13 Java 1.0-1.1的容器"></a><a href="#index_17-13">第17章-13 Java 1.0-1.1的容器</a></h2><h3 id="第17章-13-1-Vector和Enumeration"><a href="#第17章-13-1-Vector和Enumeration" class="headerlink" title="第17章-13.1 Vector和Enumeration"></a><a href="#index_17-13-1">第17章-13.1 Vector和Enumeration</a></h3><h3 id="第17章-13-2-Hashtable"><a href="#第17章-13-2-Hashtable" class="headerlink" title="第17章-13.2 Hashtable"></a><a href="#index_17-13-2">第17章-13.2 Hashtable</a></h3><h3 id="第17章-13-3-Stack"><a href="#第17章-13-3-Stack" class="headerlink" title="第17章-13.3 Stack"></a><a href="#index_17-13-3">第17章-13.3 Stack</a></h3><h3 id="第17章-13-4-BitSet"><a href="#第17章-13-4-BitSet" class="headerlink" title="第17章-13.4 BitSet"></a><a href="#index_17-4-13-4">第17章-13.4 BitSet</a></h3><h2 id="第17章-14-总结"><a href="#第17章-14-总结" class="headerlink" title="第17章-14 总结"></a><a href="#index_17-14">第17章-14 总结</a></h2><h1 id="第18章-Java-IO系统"><a href="#第18章-Java-IO系统" class="headerlink" title="第18章 Java IO系统"></a><a href="#index_18">第18章 Java IO系统</a></h1><h2 id="第18章-1-File类"><a href="#第18章-1-File类" class="headerlink" title="第18章-1 File类"></a><a href="#index_18-1">第18章-1 File类</a></h2><h3 id="第18章-1-1-目录列表器"><a href="#第18章-1-1-目录列表器" class="headerlink" title="第18章-1-1 目录列表器"></a><a href="#index_18-1-1">第18章-1-1 目录列表器</a></h3><h3 id="第18章-1-2-目录实用工具"><a href="#第18章-1-2-目录实用工具" class="headerlink" title="第18章-1-2 目录实用工具"></a><a href="#index_18-1-2">第18章-1-2 目录实用工具</a></h3><h3 id="第18章-1-3-目录的检查及创建"><a href="#第18章-1-3-目录的检查及创建" class="headerlink" title="第18章-1-3 目录的检查及创建"></a><a href="#index_18-1-3">第18章-1-3 目录的检查及创建</a></h3><h2 id="第18章-2-输入（Input）和输出（Output）"><a href="#第18章-2-输入（Input）和输出（Output）" class="headerlink" title="第18章-2 输入（Input）和输出（Output）"></a><a href="#index_18-2">第18章-2 输入（Input）和输出（Output）</a></h2><h3 id="第18章-2-1-InputStream类型"><a href="#第18章-2-1-InputStream类型" class="headerlink" title="第18章-2-1 InputStream类型"></a><a href="#index_18-2-1">第18章-2-1 InputStream类型</a></h3><h3 id="第18章-2-2-OutputStream类型"><a href="#第18章-2-2-OutputStream类型" class="headerlink" title="第18章-2-2 OutputStream类型"></a><a href="#index_18-2-2">第18章-2-2 OutputStream类型</a></h3><h2 id="第18章-3-添加属性和有用的接口"><a href="#第18章-3-添加属性和有用的接口" class="headerlink" title="第18章-3 添加属性和有用的接口"></a><a href="#index_18-3">第18章-3 添加属性和有用的接口</a></h2><h3 id="第18章-3-1-通过FilterInputStream从InputStream读取数据"><a href="#第18章-3-1-通过FilterInputStream从InputStream读取数据" class="headerlink" title="第18章-3-1 通过FilterInputStream从InputStream读取数据"></a><a href="#index_18-3-1">第18章-3-1 通过FilterInputStream从InputStream读取数据</a></h3><h3 id="第18章-3-2-通过FilterOutputStream从OutputStream写入"><a href="#第18章-3-2-通过FilterOutputStream从OutputStream写入" class="headerlink" title="第18章-3-2 通过FilterOutputStream从OutputStream写入"></a><a href="#index_18-3-2">第18章-3-2 通过FilterOutputStream从OutputStream写入</a></h3><h2 id="第18章-4-Reader和Writer"><a href="#第18章-4-Reader和Writer" class="headerlink" title="第18章-4 Reader和Writer"></a><a href="#index_18-4">第18章-4 Reader和Writer</a></h2><h3 id="第18章-4-1-数据的来源和去处（字节流和字符流类库的关联）"><a href="#第18章-4-1-数据的来源和去处（字节流和字符流类库的关联）" class="headerlink" title="第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）"></a><a href="#index_18-4-1">第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）</a></h3><h3 id="第18章-4-2-更改流的行为"><a href="#第18章-4-2-更改流的行为" class="headerlink" title="第18章-4-2 更改流的行为"></a><a href="#index_18-4-2">第18章-4-2 更改流的行为</a></h3><h3 id="第18章-4-3-未发生变化的类"><a href="#第18章-4-3-未发生变化的类" class="headerlink" title="第18章-4-3 未发生变化的类"></a><a href="#index_18-4-3">第18章-4-3 未发生变化的类</a></h3><h2 id="第18章-5-自我独立的类：RandomAccessFile"><a href="#第18章-5-自我独立的类：RandomAccessFile" class="headerlink" title="第18章-5 自我独立的类：RandomAccessFile"></a><a href="#index_18-5">第18章-5 自我独立的类：RandomAccessFile</a></h2><h2 id="第18章-6-IO流的典型使用方式"><a href="#第18章-6-IO流的典型使用方式" class="headerlink" title="第18章-6 IO流的典型使用方式"></a><a href="#index_18-6">第18章-6 IO流的典型使用方式</a></h2><h3 id="第18章-6-1-缓冲输入文件"><a href="#第18章-6-1-缓冲输入文件" class="headerlink" title="第18章-6-1 缓冲输入文件"></a><a href="#index_18-6-1">第18章-6-1 缓冲输入文件</a></h3><h3 id="第18章-6-2-从内存输入"><a href="#第18章-6-2-从内存输入" class="headerlink" title="第18章-6-2 从内存输入"></a><a href="#index_18-6-2">第18章-6-2 从内存输入</a></h3><h3 id="第18章-6-3-格式化的内存输入"><a href="#第18章-6-3-格式化的内存输入" class="headerlink" title="第18章-6-3 格式化的内存输入"></a><a href="#index_18-6-3">第18章-6-3 格式化的内存输入</a></h3><h3 id="第18章-6-4-基本的文件输出"><a href="#第18章-6-4-基本的文件输出" class="headerlink" title="第18章-6-4 基本的文件输出"></a><a href="#index_18-6-4">第18章-6-4 基本的文件输出</a></h3><h3 id="第18章-6-5-存储和恢复数据"><a href="#第18章-6-5-存储和恢复数据" class="headerlink" title="第18章-6-5 存储和恢复数据"></a><a href="#index_18-6-5">第18章-6-5 存储和恢复数据</a></h3><h3 id="第18章-6-6-随机读写访问文件"><a href="#第18章-6-6-随机读写访问文件" class="headerlink" title="第18章-6-6 随机读写访问文件"></a><a href="#index_18-6-6">第18章-6-6 随机读写访问文件</a></h3><h3 id="第18章-6-7-管道流"><a href="#第18章-6-7-管道流" class="headerlink" title="第18章-6-7 管道流"></a><a href="#index_18-6-7">第18章-6-7 管道流</a></h3><h2 id="第18章-7-文件读写的实用工具"><a href="#第18章-7-文件读写的实用工具" class="headerlink" title="第18章-7 文件读写的实用工具"></a><a href="#index_18-7">第18章-7 文件读写的实用工具</a></h2><h3 id="第18章-7-1-读取二进制文件"><a href="#第18章-7-1-读取二进制文件" class="headerlink" title="第18章-7-1 读取二进制文件"></a><a href="#index_18-7-1">第18章-7-1 读取二进制文件</a></h3><h2 id="第18章-8-标准IO"><a href="#第18章-8-标准IO" class="headerlink" title="第18章-8 标准IO"></a><a href="#index_18-8">第18章-8 标准IO</a></h2><h3 id="第18章-8-1-从标准输入中读取"><a href="#第18章-8-1-从标准输入中读取" class="headerlink" title="第18章-8-1 从标准输入中读取"></a><a href="#index_18-8-1">第18章-8-1 从标准输入中读取</a></h3><h3 id="第18章-8-2-将System-out转换成PrintWriter"><a href="#第18章-8-2-将System-out转换成PrintWriter" class="headerlink" title="第18章-8-2 将System.out转换成PrintWriter"></a><a href="#index_18-8-2">第18章-8-2 将System.out转换成PrintWriter</a></h3><h3 id="第18章-8-3-标准IO重定向"><a href="#第18章-8-3-标准IO重定向" class="headerlink" title="第18章-8-3 标准IO重定向"></a><a href="#index_18-8-3">第18章-8-3 标准IO重定向</a></h3><h2 id="第18章-9-进程控制"><a href="#第18章-9-进程控制" class="headerlink" title="第18章-9 进程控制"></a><a href="#index_18-9">第18章-9 进程控制</a></h2><h2 id="第18章-10-新IO"><a href="#第18章-10-新IO" class="headerlink" title="第18章-10 新IO"></a><a href="#index_18-10">第18章-10 新IO</a></h2><h3 id="第18章-10-1-转换数据"><a href="#第18章-10-1-转换数据" class="headerlink" title="第18章-10-1 转换数据"></a><a href="#index_18-10-1">第18章-10-1 转换数据</a></h3><h3 id="第18章-10-2-获取基本类型"><a href="#第18章-10-2-获取基本类型" class="headerlink" title="第18章-10-2 获取基本类型"></a><a href="#index_18-10-2">第18章-10-2 获取基本类型</a></h3><h3 id="第18章-10-3-视图缓冲器"><a href="#第18章-10-3-视图缓冲器" class="headerlink" title="第18章-10-3 视图缓冲器"></a><a href="#index_18-10-3">第18章-10-3 视图缓冲器</a></h3><h3 id="第18章-10-4-用缓冲器操纵数据"><a href="#第18章-10-4-用缓冲器操纵数据" class="headerlink" title="第18章-10-4 用缓冲器操纵数据"></a><a href="#index_18-10-4">第18章-10-4 用缓冲器操纵数据</a></h3><h3 id="第18章-10-5-缓冲器的细节"><a href="#第18章-10-5-缓冲器的细节" class="headerlink" title="第18章-10-5 缓冲器的细节"></a><a href="#index_18-10-5">第18章-10-5 缓冲器的细节</a></h3><h3 id="第18章-10-6-内存映射文件"><a href="#第18章-10-6-内存映射文件" class="headerlink" title="第18章-10-6 内存映射文件"></a><a href="#index_18-10-6">第18章-10-6 内存映射文件</a></h3><h3 id="第18章-10-7-文件加锁"><a href="#第18章-10-7-文件加锁" class="headerlink" title="第18章-10-7 文件加锁"></a><a href="#index_18-10-7">第18章-10-7 文件加锁</a></h3><h2 id="第18章-11-压缩"><a href="#第18章-11-压缩" class="headerlink" title="第18章-11 压缩"></a><a href="#index_18-11">第18章-11 压缩</a></h2><h3 id="第18章-11-1-用GZIP进行简单压缩"><a href="#第18章-11-1-用GZIP进行简单压缩" class="headerlink" title="第18章-11-1 用GZIP进行简单压缩"></a><a href="#index_18-11-1">第18章-11-1 用GZIP进行简单压缩</a></h3><h3 id="第18章-11-2-用Zip进行多文件保存"><a href="#第18章-11-2-用Zip进行多文件保存" class="headerlink" title="第18章-11-2 用Zip进行多文件保存"></a><a href="#index_18-11-2">第18章-11-2 用Zip进行多文件保存</a></h3><h3 id="第18章-11-3-Java档案文件"><a href="#第18章-11-3-Java档案文件" class="headerlink" title="第18章-11-3 Java档案文件"></a><a href="#index_18-11-3">第18章-11-3 Java档案文件</a></h3><h2 id="第18章-12-对象序列化"><a href="#第18章-12-对象序列化" class="headerlink" title="第18章-12 对象序列化"></a><a href="#index_18-12">第18章-12 对象序列化</a></h2><h3 id="第18章-12-1-寻找类"><a href="#第18章-12-1-寻找类" class="headerlink" title="第18章-12-1 寻找类"></a><a href="#index_18-12-1">第18章-12-1 寻找类</a></h3><h3 id="第18章-12-2-序列化的控制"><a href="#第18章-12-2-序列化的控制" class="headerlink" title="第18章-12-2 序列化的控制"></a><a href="#index_18-12-2">第18章-12-2 序列化的控制</a></h3><h3 id="第18章-12-3-使用“持久性”"><a href="#第18章-12-3-使用“持久性”" class="headerlink" title="第18章-12-3 使用“持久性”"></a><a href="#index_18-12-3">第18章-12-3 使用“持久性”</a></h3><h2 id="第18章-13-XML"><a href="#第18章-13-XML" class="headerlink" title="第18章-13 XML"></a><a href="#index_18-13">第18章-13 XML</a></h2><h2 id="第18章-14-Preferences"><a href="#第18章-14-Preferences" class="headerlink" title="第18章-14 Preferences"></a><a href="#index_18-14">第18章-14 Preferences</a></h2><h2 id="第18章-15-总结"><a href="#第18章-15-总结" class="headerlink" title="第18章-15 总结"></a><a href="#index_18-15">第18章-15 总结</a></h2><h1 id="第19章-枚举类型"><a href="#第19章-枚举类型" class="headerlink" title="第19章 枚举类型"></a><a href="#index_19">第19章 枚举类型</a></h1><h2 id="第19章-1-基本enum特性"><a href="#第19章-1-基本enum特性" class="headerlink" title="第19章-1 基本enum特性"></a><a href="#index_19-1">第19章-1 基本enum特性</a></h2><h3 id="第19章-1-1-将静态导入用于enum"><a href="#第19章-1-1-将静态导入用于enum" class="headerlink" title="第19章-1-1 将静态导入用于enum"></a><a href="#index_19-1-1">第19章-1-1 将静态导入用于enum</a></h3><h2 id="第19章-2-向enum中添加新方法"><a href="#第19章-2-向enum中添加新方法" class="headerlink" title="第19章-2 向enum中添加新方法"></a><a href="#index_19-2">第19章-2 向enum中添加新方法</a></h2><h3 id="第19章-2-1-覆盖enum的方法"><a href="#第19章-2-1-覆盖enum的方法" class="headerlink" title="第19章-2-1 覆盖enum的方法"></a><a href="#index_19-2-1">第19章-2-1 覆盖enum的方法</a></h3><h2 id="第19章-3-switch语句中的enum"><a href="#第19章-3-switch语句中的enum" class="headerlink" title="第19章-3 switch语句中的enum"></a><a href="#index_19-3">第19章-3 switch语句中的enum</a></h2><h2 id="第19章-4-values-的神秘之处"><a href="#第19章-4-values-的神秘之处" class="headerlink" title="第19章-4 values()的神秘之处"></a><a href="#index_19-4">第19章-4 values()的神秘之处</a></h2><h2 id="第19章-5-实现而非继承"><a href="#第19章-5-实现而非继承" class="headerlink" title="第19章-5 实现而非继承"></a><a href="#index_19-5">第19章-5 实现而非继承</a></h2><h2 id="第19章-6-随机选取"><a href="#第19章-6-随机选取" class="headerlink" title="第19章-6 随机选取"></a><a href="#index_19-6">第19章-6 随机选取</a></h2><h2 id="第19章-7-使用接口组织枚举"><a href="#第19章-7-使用接口组织枚举" class="headerlink" title="第19章-7 使用接口组织枚举"></a><a href="#index_19-7">第19章-7 使用接口组织枚举</a></h2><h2 id="第19章-8-使用EnumSet替代标志"><a href="#第19章-8-使用EnumSet替代标志" class="headerlink" title="第19章-8 使用EnumSet替代标志"></a><a href="#index_19-8">第19章-8 使用EnumSet替代标志</a></h2><h2 id="第19章-9-使用EnumMap"><a href="#第19章-9-使用EnumMap" class="headerlink" title="第19章-9 使用EnumMap"></a><a href="#index_19-9">第19章-9 使用EnumMap</a></h2><h2 id="第19章-10-常量相关的方法（枚举类的抽象方法）"><a href="#第19章-10-常量相关的方法（枚举类的抽象方法）" class="headerlink" title="第19章-10 常量相关的方法（枚举类的抽象方法）"></a><a href="#index_19-10">第19章-10 常量相关的方法（枚举类的抽象方法）</a></h2><h3 id="第19章-10-1-使用enum的职责链"><a href="#第19章-10-1-使用enum的职责链" class="headerlink" title="第19章-10-1 使用enum的职责链"></a><a href="#index_19-10-1">第19章-10-1 使用enum的职责链</a></h3><h3 id="第19章-10-2-使用enum的状态机"><a href="#第19章-10-2-使用enum的状态机" class="headerlink" title="第19章-10-2 使用enum的状态机"></a><a href="#index_19-10-2">第19章-10-2 使用enum的状态机</a></h3><h2 id="第19章-11-多路分发"><a href="#第19章-11-多路分发" class="headerlink" title="第19章-11 多路分发"></a><a href="#index_19-11">第19章-11 多路分发</a></h2><h3 id="第19章-11-1-使用enum分发"><a href="#第19章-11-1-使用enum分发" class="headerlink" title="第19章-11-1 使用enum分发"></a><a href="#index_19-11-1">第19章-11-1 使用enum分发</a></h3><h3 id="第19章-11-2-使用常量相关的方法"><a href="#第19章-11-2-使用常量相关的方法" class="headerlink" title="第19章-11-2 使用常量相关的方法"></a><a href="#index_19-11-2">第19章-11-2 使用常量相关的方法</a></h3><h3 id="第19章-11-3-使用EnumMap分发"><a href="#第19章-11-3-使用EnumMap分发" class="headerlink" title="第19章-11-3 使用EnumMap分发"></a><a href="#index_19-11-3">第19章-11-3 使用EnumMap分发</a></h3><h3 id="第19章-11-4-使用二维数组"><a href="#第19章-11-4-使用二维数组" class="headerlink" title="第19章-11-4 使用二维数组"></a><a href="#index_19-11-4">第19章-11-4 使用二维数组</a></h3><h2 id="第19章-12-总结"><a href="#第19章-12-总结" class="headerlink" title="第19章-12 总结"></a><a href="#index_19-12">第19章-12 总结</a></h2><h1 id="第20章-注解"><a href="#第20章-注解" class="headerlink" title="第20章 注解"></a><a href="#index_20">第20章 注解</a></h1><h2 id="第20章-1-基本语法"><a href="#第20章-1-基本语法" class="headerlink" title="第20章-1 基本语法"></a><a href="#index_20-1">第20章-1 基本语法</a></h2><h3 id="第20章-1-1-定义注解"><a href="#第20章-1-1-定义注解" class="headerlink" title="第20章-1-1 定义注解"></a><a href="#index_20-1-1">第20章-1-1 定义注解</a></h3><h3 id="第20章-1-2-元注解"><a href="#第20章-1-2-元注解" class="headerlink" title="第20章-1-2 元注解"></a><a href="#index_20-1-2">第20章-1-2 元注解</a></h3><h2 id="第20章-2-编写注解处理器"><a href="#第20章-2-编写注解处理器" class="headerlink" title="第20章-2 编写注解处理器"></a><a href="#index_20-2">第20章-2 编写注解处理器</a></h2><h3 id="第20章-2-1-注解元素"><a href="#第20章-2-1-注解元素" class="headerlink" title="第20章-2-1 注解元素"></a><a href="#index_20-2-1">第20章-2-1 注解元素</a></h3><h3 id="第20章-2-2-默认值限制"><a href="#第20章-2-2-默认值限制" class="headerlink" title="第20章-2-2 默认值限制"></a><a href="#index_20-2-2">第20章-2-2 默认值限制</a></h3><h3 id="第20章-2-3-生成外部文件"><a href="#第20章-2-3-生成外部文件" class="headerlink" title="第20章-2-3 生成外部文件"></a><a href="#index_20-2-3">第20章-2-3 生成外部文件</a></h3><h3 id="第20章-2-4-注解不支持继承"><a href="#第20章-2-4-注解不支持继承" class="headerlink" title="第20章-2-4 注解不支持继承"></a><a href="#index_20-2-4">第20章-2-4 注解不支持继承</a></h3><h3 id="第20章-2-5-实现处理器"><a href="#第20章-2-5-实现处理器" class="headerlink" title="第20章-2-5 实现处理器"></a><a href="#index_20-2-5">第20章-2-5 实现处理器</a></h3><h2 id="第20章-3-使用apt处理注解"><a href="#第20章-3-使用apt处理注解" class="headerlink" title="第20章-3 使用apt处理注解"></a><a href="#index_20-3">第20章-3 使用apt处理注解</a></h2><h2 id="第20章-4-将观察者模式用于apt"><a href="#第20章-4-将观察者模式用于apt" class="headerlink" title="第20章-4 将观察者模式用于apt"></a><a href="#index_20-4">第20章-4 将观察者模式用于apt</a></h2><h2 id="第20章-5-基于注解的单元测试"><a href="#第20章-5-基于注解的单元测试" class="headerlink" title="第20章-5 基于注解的单元测试"></a><a href="#index_20-5">第20章-5 基于注解的单元测试</a></h2><h3 id="第20章-5-1-将-Unit用于泛型"><a href="#第20章-5-1-将-Unit用于泛型" class="headerlink" title="第20章-5-1 将@Unit用于泛型"></a><a href="#index_20-5-1">第20章-5-1 将@Unit用于泛型</a></h3><h3 id="第20章-5-2-不需要任何“套件”"><a href="#第20章-5-2-不需要任何“套件”" class="headerlink" title="第20章-5-2 不需要任何“套件”"></a><a href="#index_20-5-2">第20章-5-2 不需要任何“套件”</a></h3><h3 id="第20章-5-3-实现-Unit"><a href="#第20章-5-3-实现-Unit" class="headerlink" title="第20章-5-3 实现@Unit"></a><a href="#index_20-5-3">第20章-5-3 实现@Unit</a></h3><h3 id="第20章-5-4-移除测试代码"><a href="#第20章-5-4-移除测试代码" class="headerlink" title="第20章-5-4 移除测试代码"></a><a href="#index_20-5-4">第20章-5-4 移除测试代码</a></h3><h2 id="第20章-6-总结"><a href="#第20章-6-总结" class="headerlink" title="第20章-6 总结"></a><a href="#index_20-6">第20章-6 总结</a></h2><h1 id="第21章-并发"><a href="#第21章-并发" class="headerlink" title="第21章 并发"></a><a href="#index_21">第21章 并发</a></h1><h2 id="第21章-1-并发的多面性"><a href="#第21章-1-并发的多面性" class="headerlink" title="第21章-1 并发的多面性"></a><a href="#index_21-1">第21章-1 并发的多面性</a></h2><h2 id="第21章-2-基本的线程机制"><a href="#第21章-2-基本的线程机制" class="headerlink" title="第21章-2 基本的线程机制"></a><a href="#index_21-2">第21章-2 基本的线程机制</a></h2><h2 id="第21章-3-共享受限资源"><a href="#第21章-3-共享受限资源" class="headerlink" title="第21章-3 共享受限资源"></a><a href="#index_21-3">第21章-3 共享受限资源</a></h2><h2 id="第21章-4-终结任务"><a href="#第21章-4-终结任务" class="headerlink" title="第21章-4 终结任务"></a><a href="#index_21-4">第21章-4 终结任务</a></h2><h2 id="第21章-5-线程之间的协作"><a href="#第21章-5-线程之间的协作" class="headerlink" title="第21章-5 线程之间的协作"></a><a href="#index_21-5">第21章-5 线程之间的协作</a></h2><h2 id="第21章-6-死锁"><a href="#第21章-6-死锁" class="headerlink" title="第21章-6 死锁"></a><a href="#index_21-6">第21章-6 死锁</a></h2><h2 id="第21章-7-新类库中的构件"><a href="#第21章-7-新类库中的构件" class="headerlink" title="第21章-7 新类库中的构件"></a><a href="#index_21-7">第21章-7 新类库中的构件</a></h2><h2 id="第21章-8-仿真"><a href="#第21章-8-仿真" class="headerlink" title="第21章-8 仿真"></a><a href="#index_21-8">第21章-8 仿真</a></h2><h2 id="第21章-9-性能调优"><a href="#第21章-9-性能调优" class="headerlink" title="第21章-9 性能调优"></a><a href="#index_21-9">第21章-9 性能调优</a></h2><h2 id="第21章-10-活动对象"><a href="#第21章-10-活动对象" class="headerlink" title="第21章-10 活动对象"></a><a href="#index_21-10">第21章-10 活动对象</a></h2><h2 id="第21章-11-总结"><a href="#第21章-11-总结" class="headerlink" title="第21章-11 总结"></a><a href="#index_21-11">第21章-11 总结</a></h2><h1 id="第22章-图形化用户界面"><a href="#第22章-图形化用户界面" class="headerlink" title="第22章 图形化用户界面"></a><a href="#index_22">第22章 图形化用户界面</a></h1><hr>
<h1 id="📖参看"><a href="#📖参看" class="headerlink" title="📖参看"></a>📖参看</h1><div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>主要参看📖</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744">Java教程 - 廖雪峰的官方网站</a></li>
</ul>
 
    </div></div>
    </div>

<div class="xControl active">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>主要参看📖（站内资源）</span></div>
    <div class="xContent pre-open"><div class="inner">
        <ul>
<li><a href="/zh/post/Java/" title="Java | 夜与花海">Java | 夜与花海</a>&ensp;🖇</li>
<li><a href="/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B/" title="《Thinking-in-Java》 | 夜与花海">《Thinking-in-Java》 | 夜与花海</a>&ensp;🖇</li>
</ul>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>分类：解决问题✅</span></div>
    <div class="xContent"><div class="inner">
        <ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/heimu24/article/details/81189700">Markdown进阶（更改字体、颜色、大小，设置文字背景色，调整图片大小设置居中）_heimu24的博客-CSDN博客_markdown 颜色</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000019710978">(……) inline-block的元素垂直居中的问题 - SegmentFault 思否</a></li>
<li><a target="_blank" rel="noopener" href="https://www.itranslater.com/qa/details/2117469006360740864">如何在GitHub风格的Markdown中添加脚注？ - ITranslater</a></li>
</ul>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>分类：工具🧰&ensp;|&ensp;查阅🔍</span></div>
    <div class="xContent"><div class="inner">
        <ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc()">calc() - CSS（层叠样式表） | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/fit-content">fit-content() - CSS（层叠样式表） | MDN</a></li>
<li>【★】【GFM】<a target="_blank" rel="noopener" href="https://github.github.com/gfm/">GitHub Flavored Markdown Spec - github.github.com</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3schools.com/colors/colors_picker.asp">HTML Color Picker</a></li>
<li><font style="font-style:italic;"><b>「</b>本站_标准颜色<b>」</b></font>&ensp;⤵<ul>
<li><font style="color:#CC0000;font-weight:bold;">『&thinsp;红&thinsp;』</font>&ensp;<code>#CC0000</code></li>
<li><font style="color:#FF6699;font-weight:bold;">『&thinsp;粉&thinsp;』</font>&ensp;<code>#FF6699</code></li>
<li><font style="color:#FCC000;font-weight:bold;">『&thinsp;橙&thinsp;』</font>&ensp;<code>#FCC000</code></li>
<li><font style="color:#6AA84F;font-weight:bold;">『&thinsp;绿&thinsp;』</font>&ensp;<code>#6AA84F</code></li>
<li><font style="color:#4343FF;font-weight:bold;">『&thinsp;蓝&thinsp;』</font>&ensp;<code>#4343FF</code></li>
<li><font style="color:#9900FF;font-weight:bold;">『&thinsp;紫&thinsp;』</font>&ensp;<code>#9900FF</code></li>
<li><font style="color:#808080;font-weight:bold;">『&thinsp;灰&thinsp;』</font>&ensp;<code>#808080</code></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="http://www.oicqzone.com/pc/2015083122336.html">HTML中&amp;nbsp; &amp;ensp; &amp;emsp; &amp;thinsp;等6种空白空格的区别_电脑小技巧_上网技巧_QQ地带</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 教程 | 菜鸟教程</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F446/">👆 - 白色指向反手指数 表情符号: U+1F446 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F4D6/">📖 - 打开书 表情符号: U+1F4D6 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F517/">🔗 - 链接符号 表情符号: U+1F517 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F587/">🖇 - 链接回形针 表情符号: U+1F587 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F5CE/">🗎 - 文献: U+1F5CE - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/203B/">※ - 参考标志: U+203B - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/260C/">☌ - 关联: U+260C - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F845/">🡅 - 向上重箭头: U+1F845 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F846/">🡆 - 向右重箭头: U+1F846 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F847/">🡇 - 向下重箭头: U+1F847 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F844/">🡄 - 向左重箭: U+1F844 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/2934/">⤴ - 指向右侧然后向上弯曲的箭头 表情符号: U+2934 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/2935/">⤵ - 指向右侧然后向下弯曲的箭头 表情符号: U+2935 cudarrr - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/2936/">⤶ - 指向下侧然后向左弯曲的箭头: U+2936 ldca - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/2937/">⤷ - 指向下侧然后向右弯曲的箭头: U+2937 rdca - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/1F3B5/">🎵 - 快乐的音符 表情符号: U+1F3B5 - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/21D4/">⇔ - 左右双箭头: U+21D4 hArr - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/21D2/">⇒ - 向右双箭头: U+21D2 rArr - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://unicode-table.com/cn/2014/">— - Em 长划: U+2014 mdash - Unicode 字符百科</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%87%E7%82%B9%E7%AC%A6%E5%8F%B7">标点符号 - 维基百科，自由的百科全书</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BF%9E%E6%8E%A5%E5%8F%B7">连接号 - 维基百科，自由的百科全书</a></li>
</ul>
 
    </div></div>
    </div>

<div class="xControl">
    <div class="xHeading"><div class="xIcon"><i class="fa fa-plus"></i></div><span>分类：其他（二度及以上关联☌）</span></div>
    <div class="xContent"><div class="inner">
         
    </div></div>
    </div>

<hr>
<h1 id="※参考和引用"><a href="#※参考和引用" class="headerlink" title="※参考和引用"></a>※参考和引用</h1><ol>
<li><a id="cite_note-1" href="#cite_ref-1" aria-label="跳转" title="跳转">^</a>&ensp;<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象程序设计 - 维基百科，自由的百科全书</a></li>
<li><a id="cite_note-2" href="#cite_ref-2" aria-label="跳转" title="跳转">^</a>&ensp;<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/24792">面向对象程序设计（一种计算机编程架构）_百度百科</a></li>
</ol>
<hr>
<h1 id="🔗外部链接"><a href="#🔗外部链接" class="headerlink" title="🔗外部链接"></a>🔗外部链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54">Wikipedia&#39;s external link ltr-icon</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload) | 菜鸟教程</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/46dbd930f6a2">Java 中的枚举 (enum) - 简书</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27093465/article/details/52180865">Java 枚举(enum) 详解7种常见的用法_请叫我大师兄-CSDN博客_枚举</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
<li><a target="_blank" rel="noopener" href="https://github.com/SuiteLHY/DingDing">SuiteLHY/DingDing: Instant Messaging System, Microservice Architecture, DDD (Domain-driven design); Spring, Spring MVC, Spring Data JPA, Hibernate, Spring Cloud, Spring Cloud Alibaba</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473188087424">枚举类 - 廖雪峰的官方网站</a><div style="display:inline-block !important;vertical-align:top !important;width:12px !important;height:fit-content(100%);padding:0 !important;border:0 !important;margin:0 !important;"><img src="https://zh.wikipedia.org/w/skins/Vector/resources/skins.vector.styles/images/external-link-ltr-icon.svg?48e54" alt="" style="display:inline-block;vertical-align:top !important;width:12px;height:12px;border:0 !important;margin:0 !important;" /></div></li>
</ul>

            </div>
            
                <div class="kratos-copyright text-center clearfix">
                    <h5>本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
                </div>
            
            <footer class="kratos-entry-footer clearfix">
                
                    <div class="post-like-donate text-center clearfix" id="post-like-donate">
                    
                    
                        <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                        <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://suitelhy.github.io/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://suitelhy.github.io/zh/post/%E3%80%8AThinking-in-Java%E3%80%8B-4th-Edition/";
            const title         = "「《Thinking in Java》（第4版） ← 整理手册」";
            const excerpt       = `《Thinking in Java》(4th)&thinsp;的译本《Java编程思想》(第四版)&thinsp;的整理笔记。
该手册中还包括&thinsp;本人添加的&thinsp;一些知识更新和拓展。`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                    
                    </div>
                
                <div class="footer-tag clearfix">
                    <div class="pull-left">
                    <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/Java/" rel="tag">Java</a>, <a class="tag-none-link" href="/tags/%E3%80%8AThinking-in-Java%E3%80%8B/" rel="tag">《Thinking in Java》</a>, <a class="tag-none-link" href="/tags/Computer-Science/" rel="tag">计算机科学</a>
                    </div>
                    <div class="pull-date">
                    <span>最后编辑：2021-05-16</span>
                    </div>
                </div>
            </footer>
        </div>
        
            <nav class="navigation post-navigation clearfix" role="navigation">
                
                <div class="nav-previous clearfix">
                    <a title=" 实践手册" href="/zh/post/实践手册/">&lt; 上一篇</a>
                </div>
                
                
                <div class="nav-next clearfix">
                    <a title=" 《Thinking in Java》" href="/zh/post/《Thinking-in-Java》/">下一篇 &gt;</a>
                </div>
                
            </nav>
        
        
    </article>
</section>

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="https://avatars.githubusercontent.com/SuiteLHY" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">青春倚靠着时光，轻快的脚步在世间流韵； 云上光华从指间绽放，地上人们自由而幸福。</p>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix">
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar"></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA"><span class="toc-text">第1章 面向对象导论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Object-oriend-Programming%EF%BC%8COOP%EF%BC%89%E3%80%82"><span class="toc-text">面向对象程序设计（Object-oriend Programming，OOP）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85%E6%80%A7%E3%80%81%E7%BB%A7%E6%89%BF%E6%80%A7%E3%80%81%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">主要特征：封装性、继承性、多态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%BC%98%E7%82%B9"><span class="toc-text">设计优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="toc-text">设计缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-text">名词解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">第1章-1 抽象过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-2-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3"><span class="toc-text">第1章-2 每个对象都有一个接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-3-%E6%AF%8F%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="toc-text">第1章-3 每个对象都提供服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-4-%E8%A2%AB%E9%9A%90%E8%97%8F%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">第1章-4 被隐藏的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-5-%E5%A4%8D%E7%94%A8%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">第1章-5 复用具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-%E7%BB%A7%E6%89%BF"><span class="toc-text">第1章-6 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-6-1-%E2%80%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E4%B8%8E%E2%80%9C%E5%83%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E2%80%9D%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">第1章-6-1 “是一个”与“像是一个”的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-7-%E4%BC%B4%E9%9A%8F%E5%A4%9A%E6%80%81%E7%9A%84%E5%8F%AF%E4%BA%92%E6%8D%A2%E5%AF%B9%E8%B1%A1"><span class="toc-text">第1章-7 伴随多态的可互换对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-8-%E5%8D%95%E6%A0%B9%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84"><span class="toc-text">第1章-8 单根继承结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-%E5%AE%B9%E5%99%A8"><span class="toc-text">第1章-9 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-9-1-%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B"><span class="toc-text">第1章-9-1 参数化类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">第1章-10 对象的创建和生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-text">第1章-11 异常处理：错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">第1章-12 并发编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-Java%E4%B8%8EInternet"><span class="toc-text">第1章-13 Java与Internet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-1-Web%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">第1章-13-1 Web是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-text">第1章-13-2 客户端编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-13-3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%96%E7%A8%8B"><span class="toc-text">第1章-13-3 服务器端编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第1章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-text">第2章 一切都是对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-1-%E7%94%A8%E5%BC%95%E7%94%A8%E6%93%8D%E7%BA%B5%E5%AF%B9%E8%B1%A1"><span class="toc-text">第2章-1 用引用操纵对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-%E5%BF%85%E9%A1%BB%E7%94%B1%E4%BD%A0%E5%88%9B%E5%BB%BA%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E3%80%90%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-text">第2章-2 必须由你创建所有对象【底层存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-1-%E5%AD%98%E5%82%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E3%80%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8%E3%80%91"><span class="toc-text">第2章-2-1 存储到什么地方【对象的存储】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-text">寄存器。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%EF%BC%88Heap%EF%BC%89%E3%80%82"><span class="toc-text">堆栈（Heap）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Stack%EF%BC%89%E3%80%82"><span class="toc-text">堆（Stack）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%89%E3%80%82"><span class="toc-text">常量存储（常量池）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9ERAM%E5%AD%98%E5%82%A8%E3%80%82"><span class="toc-text">非RAM存储。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-2-%E7%89%B9%E4%BE%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">第2章-2-2 特例：基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-2-3-Java%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-text">第2章-2-3 Java中的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-3-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">第2章-3 永远不需要销毁对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第2章-4 创建新的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-5-%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">第2章-5 方法、参数和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-text">第2章-6 构建一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-7-%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-text">第2章-7 你的第一个Java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-8-%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%96%87%E6%A1%A3"><span class="toc-text">第2章-8 注释和嵌入式文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-9-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-text">第2章-9 编码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第2章-10 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-11-%E7%BB%83%E4%B9%A0"><span class="toc-text">第2章-11 练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-1-%E6%9B%B4%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5"><span class="toc-text">第3章-1 更简单的打印语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-2-%E4%BD%BF%E7%94%A8Java%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-2 使用Java操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-3-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">第3章-3 优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-%E8%B5%8B%E5%80%BC"><span class="toc-text">第3章-4 赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-4-1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84%E5%88%AB%E5%90%8D%E9%97%AE%E9%A2%98"><span class="toc-text">第3章-4.1 方法调用中的别名问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-%E7%AE%97%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-5 算数操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-5-1-%E4%B8%80%E5%85%83%E5%8A%A0%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-5-1 一元加减操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-6-%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F"><span class="toc-text">第3章-6 自动递增和递减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-7 关系操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-7-1-%E6%B5%8B%E8%AF%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-text">第3章-7-1 测试对象的等价性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-8 逻辑操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-8-1-%E7%9F%AD%E8%B7%AF"><span class="toc-text">第3章-8-1 短路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-%E7%9B%B4%E6%8E%A5%E5%B8%B8%E9%87%8F"><span class="toc-text">第3章-9 直接常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-9-1-%E6%8C%87%E6%95%B0%E8%AE%B0%E6%95%B0%E6%B3%95"><span class="toc-text">第3章-9-1 指数记数法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-10-%E6%8C%89%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-10 按位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-11-%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-11 移位操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-12-%E4%B8%89%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6if-else"><span class="toc-text">第3章-12 三元操作符if-else</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%92%8C"><span class="toc-text">第3章-13 字符串操作符+和&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-14-%E4%BD%BF%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%97%B6%E5%B8%B8%E7%8A%AF%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">第3章-14 使用操作符时常犯的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第3章-15 类型转换操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-1-%E6%88%AA%E5%B0%BE%E5%92%8C%E8%88%8D%E5%85%A5"><span class="toc-text">第3章-15-1 截尾和舍入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-15-2-%E6%8F%90%E5%8D%87"><span class="toc-text">第3章-15-2 提升</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-16-Java%E6%B2%A1%E6%9C%89sizeof"><span class="toc-text">第3章-16 Java没有sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%B0%8F%E7%BB%93"><span class="toc-text">第3章-17 操作符小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-18-%E6%80%BB%E7%BB%93"><span class="toc-text">第3章-18 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">第4章 控制执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text">第5章 初始化与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-1-%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E7%A1%AE%E4%BF%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-1 用构造器确保初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-2-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-text">第5章-2 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">第5章-3 默认构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">第5章-4 this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-1-%E5%9C%A8%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">第5章-4-1 在构造器中调用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-4-2-static%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">第5章-4-2 static的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">第5章-5 清理：终结处理和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-1-finalize-%E7%9A%84%E7%94%A8%E9%80%94%E4%BD%95%E5%9C%A8"><span class="toc-text">第5章-5-1 finalize()的用途何在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-2-%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%AE%9E%E6%96%BD%E6%B8%85%E7%90%86"><span class="toc-text">第5章-5-2 你必须实施清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-3-%E7%BB%88%E7%BB%93%E6%9D%A1%E4%BB%B6"><span class="toc-text">第5章-5-3 终结条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-5-4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-text">第5章-5-4 垃圾回收器如何工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-6 成员初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-6-1-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-6-1 指定初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7 构造器初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-text">第5章-7-1 初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-2-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7-2 静态数据的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B9%A6%E4%B8%AD%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8D%E5%A4%9F%E5%A5%BD%EF%BC%8C%E8%AF%A6%E8%A7%81%E4%B9%A0%E9%A2%98%EF%BC%89"><span class="toc-text">总结一下对象创建的过程（书中的总结不够好，详见习题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-3-%E6%98%BE%E5%BC%8F%E7%9A%84%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7-3 显式的静态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-7-4-%E9%9D%9E%E9%9D%99%E6%80%81%E5%AE%9E%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-7-4 非静态实例初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第5章-8 数组初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%86%92%E6%A6%82%E5%BF%B5"><span class="toc-text">数组→概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%86%92%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">数组→定义和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E2%86%92%E7%89%B9%E7%82%B9"><span class="toc-text">数组→特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">数组初始化的3种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-8-1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-text">第5章-8-1 可变参数列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第5章-9 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">额外参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enum%EF%BC%89%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">第5章-9-1 枚举类（enum）——基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-9-2-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">第5章-9-2 枚举类的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第5章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-text">第6章 访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-%E5%8C%85%EF%BC%9A%E5%BA%93%E5%8D%95%E5%85%83"><span class="toc-text">第6章-1 包：库单元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-1-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87"><span class="toc-text">第6章-1-1 代码组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-2-%E5%88%9B%E5%BB%BA%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%8C%85%E5%90%8D"><span class="toc-text">第6章-1-2 创建独一无二的包名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B2%E7%AA%81"><span class="toc-text">冲突</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-3-%E5%AE%9A%E5%88%B6%E5%B7%A5%E5%85%B7%E5%BA%93"><span class="toc-text">第6章-1-3 定制工具库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-4-%E7%94%A8import%E6%94%B9%E5%8F%98%E8%A1%8C%E4%B8%BA"><span class="toc-text">第6章-1-4 用import改变行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-1-5-%E5%AF%B9%E4%BD%BF%E7%94%A8%E5%8C%85%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-text">第6章-1-5 对使用包的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-2-Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-text">第6章-2 Java访问权限修饰词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-3-%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">第6章-3 接口和实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B0%81%E8%A3%85%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%88%E5%A5%BD%E5%A4%84%EF%BC%89"><span class="toc-text">使用封装的原因（好处）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-4-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-text">第6章-4 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-5-%E6%80%BB%E7%BB%93"><span class="toc-text">第6章-5 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB"><span class="toc-text">第7章 复用类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-1-%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-text">第7章-1 组合语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-text">第7章-2 继承语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB"><span class="toc-text">第7章-2-1 初始化基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%AF%B9%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E3%80%82"><span class="toc-text">Java会自动在派生类的构造器中插入对基类构造器的调用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">带参数的构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%8B%93%E5%B1%95%E3%80%91%E7%AC%AC7%E7%AB%A0-2-2-%E9%87%8D%E5%86%99"><span class="toc-text">【拓展】第7章-2-2 重写</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E8%A7%84%E5%88%99"><span class="toc-text">重写（Override）规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Super关键字的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">重写（Override）与重载（Overload）之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E4%B8%8E%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-text">重写（Override）与重载（Overload）之间的联系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-3-%E4%BB%A3%E7%90%86"><span class="toc-text">第7章-3 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-text">第7章-4 结合使用组合和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-1-%E7%A1%AE%E4%BF%9D%E6%AD%A3%E7%A1%AE%E6%B8%85%E7%90%86"><span class="toc-text">第7章-4-1 确保正确清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-4-2-%E5%90%8D%E7%A7%B0%E5%B1%8F%E8%94%BD"><span class="toc-text">第7章-4-2 名称屏蔽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-5-%E5%9C%A8%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9"><span class="toc-text">第7章-5 在组合与继承之间选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">组合和继承的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">在组合和继承之间的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-6-protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">第7章-6 protected关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第7章-7 向上转型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A7%B0%E4%B8%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第7章-7-1 为什么称为向上转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-7-2-%E5%86%8D%E8%AE%BA%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-text">第7章-7-2 再论组合与继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">第7章-8 final关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-1-final%E6%95%B0%E6%8D%AE"><span class="toc-text">第7章-8-1 final数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E7%99%BDfinal"><span class="toc-text">空白final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%8F%82%E6%95%B0"><span class="toc-text">final参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-2-final%E6%96%B9%E6%B3%95"><span class="toc-text">第7章-8-2 final方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final%E5%92%8Cprivate%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">final和private关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-3-final%E7%B1%BB"><span class="toc-text">第7章-8-3 final类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-8-4-%E6%9C%89%E5%85%B3final%E7%9A%84%E5%BF%A0%E5%91%8A"><span class="toc-text">第7章-8-4 有关final的忠告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-9-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-text">第7章-9 初始化类及类的加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-9-1-%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第7章-9-1 继承与初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第7章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-text">第8章 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-1-%E5%86%8D%E8%AE%BA%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第8章-1 再论向上转型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-1-1-%E5%BF%98%E8%AE%B0%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-text">第8章-1-1 忘记对象类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-%E8%BD%AC%E6%9C%BA"><span class="toc-text">第8章-2 转机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%BB%91%E5%AE%9A"><span class="toc-text">第8章-2-1 方法调用绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-2-%E4%BA%A7%E7%94%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">第8章-2-2 产生正确的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-3-%E5%8F%AF%E6%8B%93%E5%B1%95%E6%80%A7"><span class="toc-text">第8章-2-3 可拓展性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-4-%E7%BC%BA%E9%99%B7%EF%BC%9A%E2%80%9C%E8%A6%86%E7%9B%96%E2%80%9D%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-text">第8章-2-4 缺陷：“覆盖”私有方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-2-5-%E7%BC%BA%E9%99%B7%EF%BC%9A%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">第8章-2-5 缺陷：域与静态方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-text">第8章-3 构造器和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-1-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="toc-text">第8章-3-1 构造器的调用顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-2-%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B8%85%E7%90%86"><span class="toc-text">第8章-3-2 继承与清理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-3-3-%E6%9E%84%E9%80%A0%E5%99%A8%E5%86%85%E9%83%A8%E7%9A%84%E5%A4%9A%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">第8章-3-3 构造器内部的多态方法的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-4-%E5%8D%8F%E5%8F%98%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-text">第8章-4 协变返回类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-text">第8章-5 用继承进行设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-1-%E7%BA%AF%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%8B%93%E5%B1%95"><span class="toc-text">第8章-5-1 纯继承与拓展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-5-2-%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB"><span class="toc-text">第8章-5-2 向下转型与运行时类型识别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB%EF%BC%88RTTI%EF%BC%89"><span class="toc-text">运行时类型识别（RTTI）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-text">第8章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3"><span class="toc-text">关于接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">第9章-1 抽象类和抽象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%85%B7%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-text">抽象类具体定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">抽象类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%85%B7%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="toc-text">抽象方法具体定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-2-%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-2 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-3-%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-text">第9章-3 完全解耦</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-4-Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">第9章-4 Java中的多重继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-5-%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%8B%93%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-5 通过继承来拓展接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-6-%E9%80%82%E9%85%8D%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-6 适配接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-7-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%9F%9F"><span class="toc-text">第9章-7 接口中的域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-8-%E5%B5%8C%E5%A5%97%E6%8E%A5%E5%8F%A3"><span class="toc-text">第9章-8 嵌套接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%B7%A5%E5%8E%82"><span class="toc-text">第9章-9 接口与工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第9章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-1-%E5%88%9B%E5%BB%BA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-1 创建内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-2-%E9%93%BE%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-2 链接到外部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-3-%E4%BD%BF%E7%94%A8-this%E4%B8%8E-new"><span class="toc-text">第10章-3 使用.this与.new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-4-%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%8E%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-text">第10章-4 内部类与向上转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-5-%E5%9C%A8%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%86%85%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-5 在方法和作用域内的内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-6 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-7-%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="toc-text">第10章-7 嵌套类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-8-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-8 为什么需要内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-9-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-text">第10章-9 内部类的继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-10-%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%A6%86%E7%9B%96%E5%90%97"><span class="toc-text">第10章-10 内部类可以被覆盖吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-11-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第10章-11 局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-12-%E5%86%85%E9%83%A8%E7%B1%BB%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">第10章-12 内部类标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-13-%E6%80%BB%E7%BB%93"><span class="toc-text">第10章-13 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-text">第11章 持有对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-1-%E6%B3%9B%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">第11章-1 泛型和类型安全的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">第11章-2 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E4%B8%80%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">第11章-3 添加一组元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-4-%E5%AE%B9%E5%99%A8%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-text">第11章-4 容器的打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-5-List%EF%BC%88%E5%8E%9F%E7%90%86-amp-%E7%AE%80%E4%BB%8B%EF%BC%89"><span class="toc-text">第11章-5 List（原理 &amp; 简介）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-6-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">第11章-6 迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-7-LinkedList"><span class="toc-text">第11章-7 LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-8-Stack"><span class="toc-text">第11章-8 Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-9-Set"><span class="toc-text">第11章-9 Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-10-Map"><span class="toc-text">第11章-10 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-11-Queue"><span class="toc-text">第11章-11 Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-12-Collection%E5%92%8CIterator"><span class="toc-text">第11章-12 Collection和Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-Foreach%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">第11章-13 Foreach与迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-13-1-%E9%80%82%E9%85%8D%E5%99%A8%E6%96%B9%E6%B3%95%E6%83%AF%E7%94%A8%E6%B3%95%E2%86%92%E7%A4%BA%E4%BE%8B%E6%BA%90%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-text">第11章-13-1 适配器方法惯用法→示例源码说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第11章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-text">第12章 通过异常处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">第12章-1 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-2 基本异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-2-1-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%8F%82%E6%95%B0"><span class="toc-text">第12章-2-1 捕获异常参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-3 捕获异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-1-try%E5%9D%97"><span class="toc-text">第12章-3-1 try块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-3-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="toc-text">第12章-3-2 异常处理程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-4 创建自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-4-1-%E5%BC%82%E5%B8%B8%E4%B8%8E%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97"><span class="toc-text">第12章-4-1 异常与记录日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-5-%E5%BC%82%E5%B8%B8%E8%AF%B4%E6%98%8E"><span class="toc-text">第12章-5 异常说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-6 捕获所有异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-1-%E6%A0%88%E8%BD%A8%E8%BF%B9"><span class="toc-text">第12章-6-1 栈轨迹</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-2-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-6-2 重新抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-6-3-%E5%BC%82%E5%B8%B8%E9%93%BE"><span class="toc-text">第12章-6-3 异常链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-Java%E6%A0%87%E5%87%86%E5%BC%82%E5%B8%B8"><span class="toc-text">第12章-7 Java标准异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-7-1-%E7%89%B9%E4%BE%8B%EF%BC%9ARuntimeException"><span class="toc-text">第12章-7-1 特例：RuntimeException</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-%E4%BD%BF%E7%94%A8finally%E8%BF%9B%E8%A1%8C%E6%B8%85%E7%90%86"><span class="toc-text">第12章-8 使用finally进行清理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-1-finally%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">第12章-8-1 finally用来做什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-2-%E5%9C%A8return%E4%B8%AD%E4%BD%BF%E7%94%A8finally"><span class="toc-text">第12章-8-2 在return中使用finally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-8-3-%E7%BC%BA%E6%86%BE%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BC%BA%E5%A4%B1"><span class="toc-text">第12章-8-3 缺憾：异常缺失</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-9-%E5%BC%82%E5%B8%B8%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">第12章-9 异常的限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-10-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">第12章-10 构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-11-%E5%BC%82%E5%B8%B8%E5%8C%B9%E9%85%8D"><span class="toc-text">第12章-11 异常匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89%E6%96%B9%E5%BC%8F"><span class="toc-text">第12章-12 其他可选方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-1-%E5%8E%86%E5%8F%B2"><span class="toc-text">第12章-12-1 历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-2-%E8%A7%82%E7%82%B9"><span class="toc-text">第12章-12-2 观点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-3-%E6%8A%8A%E5%BC%82%E5%B8%B8%E4%BC%A0%E9%80%92%E7%BB%99%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-text">第12章-12-3 把异常传递给控制台</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-12-4-%E6%8A%8A%E2%80%9C%E8%A2%AB%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E2%80%9C%E4%B8%8D%E6%A3%80%E6%9F%A5%E7%9A%84%E5%BC%82%E5%B8%B8%E2%80%9D"><span class="toc-text">第12章-12-4 把“被检查的异常”转换为“不检查的异常”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-13-%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97"><span class="toc-text">第12章-13 异常使用指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第12章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">第13章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-1-%E4%B8%8D%E5%8F%AF%E5%8F%98String"><span class="toc-text">第13章-1 不可变String</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-2-%E9%87%8D%E8%BD%BD%E2%80%9C-%E2%80%9D%E4%B8%8EStringBuilder"><span class="toc-text">第13章-2 重载“+”与StringBuilder</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-3-%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E9%80%92%E5%BD%92"><span class="toc-text">第13章-3 无意识的递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-4-String%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">第13章-4 String上的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">第13章-5 格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-5-4-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">第13章-5-4 格式化说明符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">第13章-6 正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-7-%E6%89%AB%E6%8F%8F%E8%BE%93%E5%85%A5"><span class="toc-text">第13章-7 扫描输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-8-StringTokenizer%EF%BC%88%E5%B7%B2%E5%BA%9F%E5%BC%83%EF%BC%89"><span class="toc-text">第13章-8 StringTokenizer（已废弃）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-9-%E6%80%BB%E7%BB%93"><span class="toc-text">第13章-9 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%88RTTI%EF%BC%89"><span class="toc-text">第14章 类型信息（RTTI）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81RTTI"><span class="toc-text">第14章-1 为什么需要RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-Class%E5%AF%B9%E8%B1%A1"><span class="toc-text">第14章-2 Class对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-1-%E7%B1%BB%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">第14章-2-1 类字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-2-%E6%B3%9B%E5%8C%96%E7%9A%84Class%E5%BC%95%E7%94%A8"><span class="toc-text">第14章-2-2 泛化的Class引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-2-3-%E7%B1%BB%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E5%8E%9F%EF%BC%9A%E6%96%B0%E7%9A%84%E8%BD%AC%E5%9E%8B%E8%AF%AD%E6%B3%95%EF%BC%89"><span class="toc-text">第14章-2-3 类的转换（原：新的转型语法）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%89%8D%E5%85%88%E5%81%9A%E6%A3%80%E6%9F%A5"><span class="toc-text">第14章-3 类型转换前先做检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-4-%E6%B3%A8%E5%86%8C%E5%B7%A5%E5%8E%82"><span class="toc-text">第14章-4 注册工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-5-instanceof%E4%B8%8EClass%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="toc-text">第14章-5 instanceof与Class的等价性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-%E5%8F%8D%E5%B0%84%EF%BC%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E7%B1%BB%E4%BF%A1%E6%81%AF"><span class="toc-text">第14章-6 反射：运行时的类信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-6-1-%E7%B1%BB%E6%96%B9%E6%B3%95%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-text">第14章-6-1 类方法提取器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-7-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">第14章-7 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">第14章-8 空对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-8-1-%E6%A8%A1%E6%8B%9F%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%A1%A9"><span class="toc-text">第14章-8-1 模拟对象与桩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-9-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-text">第14章-9 接口与类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-10-%E6%80%BB%E7%BB%93"><span class="toc-text">第14章-10 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-text">第15章 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-1-%E4%B8%8EC-%E6%AF%94%E8%BE%83"><span class="toc-text">第15章-1 与C++比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-text">第15章-2 简单泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-1-%E4%B8%80%E4%B8%AA%E5%85%83%E7%A5%96%E7%B1%BB%E5%BA%93"><span class="toc-text">第15章-2-1 一个元祖类库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-2-%E4%B8%80%E4%B8%AA%E5%A0%86%E6%A0%88%E7%B1%BB"><span class="toc-text">第15章-2-2 一个堆栈类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-2-3-RandomList"><span class="toc-text">第15章-2-3 RandomList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-3-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">第15章-3 泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">第15章-4 泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-1-%E6%9D%A0%E6%9D%86%E5%88%A9%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%88%A4%E6%96%AD"><span class="toc-text">第15章-4-1 杠杆利用类型参数判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%8E%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">第15章-4-2 可变参数与泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-3-%E7%94%A8%E4%BA%8EGenerator%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">第15章-4-3 用于Generator的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-4-%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84Generator"><span class="toc-text">第15章-4-4 一个通用的Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-5-%E7%AE%80%E5%8C%96%E5%85%83%E7%A5%96%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">第15章-4-5 简化元祖的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-4-6-%E4%B8%80%E4%B8%AASet%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">第15章-4-6 一个Set实用工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-5-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">第15章-5 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-6-%E6%9E%84%E5%BB%BA%E5%A4%8D%E6%9D%82%E6%A8%A1%E5%9E%8B"><span class="toc-text">第15章-6 构建复杂模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-%E6%93%A6%E9%99%A4%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-text">第15章-7 擦除的神秘之处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-1-C-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">第15章-7-1 C++的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-2-%E8%BF%81%E7%A7%BB%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">第15章-7-2 迁移兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-3-%E6%93%A6%E9%99%A4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">第15章-7-3 擦除的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-7-4-%E8%BE%B9%E7%95%8C%E5%A4%84%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="toc-text">第15章-7-4 边界处的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-%E6%93%A6%E9%99%A4%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-text">第15章-8 擦除的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-1-%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="toc-text">第15章-8-1 创建类型实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-8-2-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-text">第15章-8-2 泛型数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-9-%E8%BE%B9%E7%95%8C"><span class="toc-text">第15章-9 边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">第15章-10 通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-1-%E7%BC%96%E8%AF%91%E5%99%A8%E6%9C%89%E5%A4%9A%E8%81%AA%E6%98%8E"><span class="toc-text">第15章-10-1 编译器有多聪明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-2-%E9%80%86%E5%8F%98"><span class="toc-text">第15章-10-2 逆变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-3-%E6%97%A0%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">第15章-10-3 无界通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-10-4-%E6%8D%95%E8%8E%B7%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7%EF%BC%89"><span class="toc-text">第15章-10-4 捕获转换（通配符捕获）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-%E9%97%AE%E9%A2%98"><span class="toc-text">第15章-11 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-1-%E4%BB%BB%E4%BD%95%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E9%83%BD%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E7%B1%BB%E5%9E%8B"><span class="toc-text">第15章-11-1 任何基本类型都不能作为类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-2-%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E5%8C%96%E6%8E%A5%E5%8F%A3"><span class="toc-text">第15章-11-2 实现参数化接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-3-%E8%BD%AC%E5%9E%8B%E5%92%8C%E8%AD%A6%E5%91%8A"><span class="toc-text">第15章-11-3 转型和警告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-4-%E9%87%8D%E8%BD%BD"><span class="toc-text">第15章-11-4 重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-11-5-%E5%9F%BA%E7%B1%BB%E5%8A%AB%E6%8C%81%E4%BA%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">第15章-11-5 基类劫持了接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-%E8%87%AA%E9%99%90%E5%AE%9A%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">第15章-12 自限定的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-1-%E5%8F%A4%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%B3%9B%E5%9E%8B"><span class="toc-text">第15章-12-1 古怪的循环泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-2-%E8%87%AA%E9%99%90%E5%AE%9A"><span class="toc-text">第15章-12-2 自限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-12-3-%E5%8F%82%E6%95%B0%E5%8D%8F%E5%8F%98"><span class="toc-text">第15章-12-3 参数协变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-13-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-text">第15章-13 动态类型安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-14-%E5%BC%82%E5%B8%B8"><span class="toc-text">第15章-14 异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-%E6%B7%B7%E5%9E%8B"><span class="toc-text">第15章-15 混型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-1-C-%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%9E%8B"><span class="toc-text">第15章-15-1 C++中的混型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-2-%E4%B8%8E%E6%8E%A5%E5%8F%A3%E6%B7%B7%E5%90%88"><span class="toc-text">第15章-15-2 与接口混合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-3-%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-text">第15章-15-3 使用装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-15-4-%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%B7%B7%E5%90%88"><span class="toc-text">第15章-15-4 与动态代理混合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-16-%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">第15章-16 潜在类型机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-%E5%AF%B9%E7%BC%BA%E4%B9%8F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-text">第15章-17 对缺乏潜在类型机制的补偿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-1-%E5%8F%8D%E5%B0%84"><span class="toc-text">第15章-17-1 反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-2-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E4%BA%8E%E5%BA%8F%E5%88%97"><span class="toc-text">第15章-17-2 将一个方法应用于序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-3-%E5%BD%93%E4%BD%A0%E5%B9%B6%E4%B8%BA%E7%A2%B0%E5%B7%A7%E6%8B%A5%E6%9C%89%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%97%B6"><span class="toc-text">第15章-17-3 当你并为碰巧拥有正确的接口时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-17-4-%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E4%BB%BF%E7%9C%9F%E6%BD%9C%E5%9C%A8%E7%B1%BB%E5%9E%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">第15章-17-4 用适配器仿真潜在类型机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-18-%E5%B0%86%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BD%9C%E7%AD%96%E7%95%A5"><span class="toc-text">第15章-18 将函数对象用作策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-%E6%80%BB%E7%BB%93%EF%BC%9A%E8%BD%AC%E5%9E%8B%E7%9C%9F%E7%9A%84%E5%A6%82%E6%AD%A4%E4%B9%8B%E7%B3%9F%E5%90%97%EF%BC%9F"><span class="toc-text">第15章-19 总结：转型真的如此之糟吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-19-1-%E8%BF%9B%E9%98%B6%E8%AF%BB%E7%89%A9"><span class="toc-text">第15章-19-1 进阶读物</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%95%B0%E7%BB%84"><span class="toc-text">第16章 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-1-%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%B9%E6%AE%8A"><span class="toc-text">第16章-1 数组为什么特殊</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-2-%E6%95%B0%E7%BB%84%E6%98%AF%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%AF%B9%E8%B1%A1"><span class="toc-text">第16章-2 数组是第一级对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-3-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-3 返回一个数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-4 多维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-5-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">第16章-5 数组与泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-text">第16章-6 创建测试数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-1-Arrays-fill"><span class="toc-text">第16章-6-1 Arrays.fill()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-2-%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">第16章-6-2 数据生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-6-3-%E4%BB%8EGenerator%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-6-3 从Generator中创建数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-Arrays%E5%AE%9E%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-text">第16章-7 Arrays实用功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-1-%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84"><span class="toc-text">第16章-7-1 复制数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-2-%E6%95%B0%E7%BB%84%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">第16章-7-2 数组的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-3-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">第16章-7-3 数组元素的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-4-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-text">第16章-7-4 数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-7-5-%E5%9C%A8%E5%B7%B2%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE"><span class="toc-text">第16章-7-5 在已排序的数组中查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-8-%E6%80%BB%E7%BB%93"><span class="toc-text">第16章-8 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="toc-text">第17章 容器深入研究</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-1-%E5%AE%8C%E6%95%B4%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-text">第17章-1 完整容器分类法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-%E5%A1%AB%E5%85%85%E5%AE%B9%E5%99%A8"><span class="toc-text">第17章-2 填充容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-1-%E4%B8%80%E7%A7%8DGenerator%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">第17章-2-1 一种Generator解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-2-Map%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">第17章-2-2 Map生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-2-3-%E4%BD%BF%E7%94%A8Abstract%E7%B1%BB"><span class="toc-text">第17章-2-3 使用Abstract类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-3-Collection%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-text">第17章-3 Collection的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-%E5%8F%AF%E9%80%89%E6%93%8D%E4%BD%9C"><span class="toc-text">第17章-4 可选操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-4-1-%E6%9C%AA%E8%8E%B7%E6%94%AF%E6%8C%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">第17章-4-1 未获支持的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-5-List%E7%9A%84%E5%8A%9F%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-text">第17章-5 List的功能方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-Set%E5%92%8C%E5%AD%98%E5%82%A8%E6%8E%92%E5%BA%8F"><span class="toc-text">第17章-6 Set和存储排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-6-1-SortedSet"><span class="toc-text">第17章-6-1 SortedSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-%E9%98%9F%E5%88%97"><span class="toc-text">第17章-7 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-1-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-text">第17章-7-1 优先级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-7-2-%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97"><span class="toc-text">第17章-7-2 双向队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-%E7%90%86%E8%A7%A3Map"><span class="toc-text">第17章-8 理解Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-1-%E6%80%A7%E8%83%BD"><span class="toc-text">第17章-8-1 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-2-SortedMap"><span class="toc-text">第17章-8-2 SortedMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-8-3-LinkedHashMap"><span class="toc-text">第17章-8-3 LinkedHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-%E6%95%A3%E5%88%97%E4%B8%8E%E6%95%A3%E5%88%97%E7%A0%81"><span class="toc-text">第17章-9 散列与散列码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-1-%E7%90%86%E8%A7%A3hashCode"><span class="toc-text">第17章-9-1 理解hashCode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-2-%E4%B8%BA%E9%80%9F%E5%BA%A6%E8%80%8C%E6%95%A3%E5%88%97"><span class="toc-text">第17章-9-2 为速度而散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-9-3-%E8%A6%86%E7%9B%96hashCode"><span class="toc-text">第17章-9-3 覆盖hashCode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-%E9%80%89%E6%8B%A9%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">第17章-10 选择接口的不同实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-1-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-text">第17章-10-1 性能测试框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-2-%E5%AF%B9List%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">第17章-10-2 对List的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-3-%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8D%B1%E9%99%A9"><span class="toc-text">第17章-10-3 微基准测试的危险</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-4-%E5%AF%B9Set%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">第17章-10-4 对Set的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-10-5-%E5%AF%B9Map%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">第17章-10-5 对Map的选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">第17章-11 实用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-1-List%E7%9A%84%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2"><span class="toc-text">第17章-11.1 List的排序和查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-2-%E8%AE%BE%E5%AE%9ACollection%E6%88%96Map%E4%B8%BA%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-text">第17章-11.2 设定Collection或Map为不可修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-11-3-Collection%E6%88%96Map%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-text">第17章-11.3 Collection或Map的同步控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-%E6%8C%81%E6%9C%89%E5%BC%95%E7%94%A8"><span class="toc-text">第17章-12 持有引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-12-1-WeakHashMap"><span class="toc-text">第17章-12.1 WeakHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-Java-1-0-1-1%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">第17章-13 Java 1.0-1.1的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-1-Vector%E5%92%8CEnumeration"><span class="toc-text">第17章-13.1 Vector和Enumeration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-2-Hashtable"><span class="toc-text">第17章-13.2 Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-3-Stack"><span class="toc-text">第17章-13.3 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-13-4-BitSet"><span class="toc-text">第17章-13.4 BitSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-14-%E6%80%BB%E7%BB%93"><span class="toc-text">第17章-14 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-Java-IO%E7%B3%BB%E7%BB%9F"><span class="toc-text">第18章 Java IO系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-File%E7%B1%BB"><span class="toc-text">第18章-1 File类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-1-%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E5%99%A8"><span class="toc-text">第18章-1-1 目录列表器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-2-%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">第18章-1-2 目录实用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-1-3-%E7%9B%AE%E5%BD%95%E7%9A%84%E6%A3%80%E6%9F%A5%E5%8F%8A%E5%88%9B%E5%BB%BA"><span class="toc-text">第18章-1-3 目录的检查及创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-%E8%BE%93%E5%85%A5%EF%BC%88Input%EF%BC%89%E5%92%8C%E8%BE%93%E5%87%BA%EF%BC%88Output%EF%BC%89"><span class="toc-text">第18章-2 输入（Input）和输出（Output）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-1-InputStream%E7%B1%BB%E5%9E%8B"><span class="toc-text">第18章-2-1 InputStream类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-2-2-OutputStream%E7%B1%BB%E5%9E%8B"><span class="toc-text">第18章-2-2 OutputStream类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">第18章-3 添加属性和有用的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-1-%E9%80%9A%E8%BF%87FilterInputStream%E4%BB%8EInputStream%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-3-1 通过FilterInputStream从InputStream读取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-3-2-%E9%80%9A%E8%BF%87FilterOutputStream%E4%BB%8EOutputStream%E5%86%99%E5%85%A5"><span class="toc-text">第18章-3-2 通过FilterOutputStream从OutputStream写入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-Reader%E5%92%8CWriter"><span class="toc-text">第18章-4 Reader和Writer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-1-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9D%A5%E6%BA%90%E5%92%8C%E5%8E%BB%E5%A4%84%EF%BC%88%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E5%85%B3%E8%81%94%EF%BC%89"><span class="toc-text">第18章-4-1 数据的来源和去处（字节流和字符流类库的关联）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-2-%E6%9B%B4%E6%94%B9%E6%B5%81%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text">第18章-4-2 更改流的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-4-3-%E6%9C%AA%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E7%B1%BB"><span class="toc-text">第18章-4-3 未发生变化的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-5-%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="toc-text">第18章-5 自我独立的类：RandomAccessFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-IO%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">第18章-6 IO流的典型使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-1-%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-6-1 缓冲输入文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-2-%E4%BB%8E%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-text">第18章-6-2 从内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-3-%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E5%86%85%E5%AD%98%E8%BE%93%E5%85%A5"><span class="toc-text">第18章-6-3 格式化的内存输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-4-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-text">第18章-6-4 基本的文件输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-5-%E5%AD%98%E5%82%A8%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-6-5 存储和恢复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-6-%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-6-6 随机读写访问文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-6-7-%E7%AE%A1%E9%81%93%E6%B5%81"><span class="toc-text">第18章-6-7 管道流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">第18章-7 文件读写的实用工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-7-1-%E8%AF%BB%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-7-1 读取二进制文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-%E6%A0%87%E5%87%86IO"><span class="toc-text">第18章-8 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-1-%E4%BB%8E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="toc-text">第18章-8-1 从标准输入中读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-2-%E5%B0%86System-out%E8%BD%AC%E6%8D%A2%E6%88%90PrintWriter"><span class="toc-text">第18章-8-2 将System.out转换成PrintWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-8-3-%E6%A0%87%E5%87%86IO%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">第18章-8-3 标准IO重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-9-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">第18章-9 进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-%E6%96%B0IO"><span class="toc-text">第18章-10 新IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-1-%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-10-1 转换数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-2-%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">第18章-10-2 获取基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-3-%E8%A7%86%E5%9B%BE%E7%BC%93%E5%86%B2%E5%99%A8"><span class="toc-text">第18章-10-3 视图缓冲器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-4-%E7%94%A8%E7%BC%93%E5%86%B2%E5%99%A8%E6%93%8D%E7%BA%B5%E6%95%B0%E6%8D%AE"><span class="toc-text">第18章-10-4 用缓冲器操纵数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-5-%E7%BC%93%E5%86%B2%E5%99%A8%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">第18章-10-5 缓冲器的细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-6-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-10-6 内存映射文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-10-7-%E6%96%87%E4%BB%B6%E5%8A%A0%E9%94%81"><span class="toc-text">第18章-10-7 文件加锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-%E5%8E%8B%E7%BC%A9"><span class="toc-text">第18章-11 压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-1-%E7%94%A8GZIP%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%8E%8B%E7%BC%A9"><span class="toc-text">第18章-11-1 用GZIP进行简单压缩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-2-%E7%94%A8Zip%E8%BF%9B%E8%A1%8C%E5%A4%9A%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98"><span class="toc-text">第18章-11-2 用Zip进行多文件保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-11-3-Java%E6%A1%A3%E6%A1%88%E6%96%87%E4%BB%B6"><span class="toc-text">第18章-11-3 Java档案文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">第18章-12 对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-1-%E5%AF%BB%E6%89%BE%E7%B1%BB"><span class="toc-text">第18章-12-1 寻找类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-2-%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-text">第18章-12-2 序列化的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-12-3-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%8C%81%E4%B9%85%E6%80%A7%E2%80%9D"><span class="toc-text">第18章-12-3 使用“持久性”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-13-XML"><span class="toc-text">第18章-13 XML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-14-Preferences"><span class="toc-text">第18章-14 Preferences</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-15-%E6%80%BB%E7%BB%93"><span class="toc-text">第18章-15 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第19章 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-%E5%9F%BA%E6%9C%ACenum%E7%89%B9%E6%80%A7"><span class="toc-text">第19章-1 基本enum特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-1-1-%E5%B0%86%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5%E7%94%A8%E4%BA%8Eenum"><span class="toc-text">第19章-1-1 将静态导入用于enum</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-%E5%90%91enum%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B0%E6%96%B9%E6%B3%95"><span class="toc-text">第19章-2 向enum中添加新方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-2-1-%E8%A6%86%E7%9B%96enum%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">第19章-2-1 覆盖enum的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-3-switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84enum"><span class="toc-text">第19章-3 switch语句中的enum</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-4-values-%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84"><span class="toc-text">第19章-4 values()的神秘之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-5-%E5%AE%9E%E7%8E%B0%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-text">第19章-5 实现而非继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-6-%E9%9A%8F%E6%9C%BA%E9%80%89%E5%8F%96"><span class="toc-text">第19章-6 随机选取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-7-%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%BB%84%E7%BB%87%E6%9E%9A%E4%B8%BE"><span class="toc-text">第19章-7 使用接口组织枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-8-%E4%BD%BF%E7%94%A8EnumSet%E6%9B%BF%E4%BB%A3%E6%A0%87%E5%BF%97"><span class="toc-text">第19章-8 使用EnumSet替代标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-9-%E4%BD%BF%E7%94%A8EnumMap"><span class="toc-text">第19章-9 使用EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-text">第19章-10 常量相关的方法（枚举类的抽象方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-1-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E8%81%8C%E8%B4%A3%E9%93%BE"><span class="toc-text">第19章-10-1 使用enum的职责链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-10-2-%E4%BD%BF%E7%94%A8enum%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">第19章-10-2 使用enum的状态机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-%E5%A4%9A%E8%B7%AF%E5%88%86%E5%8F%91"><span class="toc-text">第19章-11 多路分发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-1-%E4%BD%BF%E7%94%A8enum%E5%88%86%E5%8F%91"><span class="toc-text">第19章-11-1 使用enum分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-2-%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">第19章-11-2 使用常量相关的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-3-%E4%BD%BF%E7%94%A8EnumMap%E5%88%86%E5%8F%91"><span class="toc-text">第19章-11-3 使用EnumMap分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-11-4-%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">第19章-11-4 使用二维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-12-%E6%80%BB%E7%BB%93"><span class="toc-text">第19章-12 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">第20章-1 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-1-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章-1-1 定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-1-2-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章-1-2 元注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-%E7%BC%96%E5%86%99%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">第20章-2 编写注解处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-1-%E6%B3%A8%E8%A7%A3%E5%85%83%E7%B4%A0"><span class="toc-text">第20章-2-1 注解元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-2-%E9%BB%98%E8%AE%A4%E5%80%BC%E9%99%90%E5%88%B6"><span class="toc-text">第20章-2-2 默认值限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-3-%E7%94%9F%E6%88%90%E5%A4%96%E9%83%A8%E6%96%87%E4%BB%B6"><span class="toc-text">第20章-2-3 生成外部文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-4-%E6%B3%A8%E8%A7%A3%E4%B8%8D%E6%94%AF%E6%8C%81%E7%BB%A7%E6%89%BF"><span class="toc-text">第20章-2-4 注解不支持继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-2-5-%E5%AE%9E%E7%8E%B0%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">第20章-2-5 实现处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-3-%E4%BD%BF%E7%94%A8apt%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3"><span class="toc-text">第20章-3 使用apt处理注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-4-%E5%B0%86%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%94%A8%E4%BA%8Eapt"><span class="toc-text">第20章-4 将观察者模式用于apt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">第20章-5 基于注解的单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-1-%E5%B0%86-Unit%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B"><span class="toc-text">第20章-5-1 将@Unit用于泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-2-%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BB%BB%E4%BD%95%E2%80%9C%E5%A5%97%E4%BB%B6%E2%80%9D"><span class="toc-text">第20章-5-2 不需要任何“套件”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-3-%E5%AE%9E%E7%8E%B0-Unit"><span class="toc-text">第20章-5-3 实现@Unit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-5-4-%E7%A7%BB%E9%99%A4%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-text">第20章-5-4 移除测试代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC20%E7%AB%A0-6-%E6%80%BB%E7%BB%93"><span class="toc-text">第20章-6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-%E5%B9%B6%E5%8F%91"><span class="toc-text">第21章 并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-1-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%A4%9A%E9%9D%A2%E6%80%A7"><span class="toc-text">第21章-1 并发的多面性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-2-%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="toc-text">第21章-2 基本的线程机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-3-%E5%85%B1%E4%BA%AB%E5%8F%97%E9%99%90%E8%B5%84%E6%BA%90"><span class="toc-text">第21章-3 共享受限资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-4-%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1"><span class="toc-text">第21章-4 终结任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-5-%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E4%BD%9C"><span class="toc-text">第21章-5 线程之间的协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-6-%E6%AD%BB%E9%94%81"><span class="toc-text">第21章-6 死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-7-%E6%96%B0%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84%E6%9E%84%E4%BB%B6"><span class="toc-text">第21章-7 新类库中的构件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-8-%E4%BB%BF%E7%9C%9F"><span class="toc-text">第21章-8 仿真</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-9-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-text">第21章-9 性能调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-10-%E6%B4%BB%E5%8A%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">第21章-10 活动对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC21%E7%AB%A0-11-%E6%80%BB%E7%BB%93"><span class="toc-text">第21章-11 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC22%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2"><span class="toc-text">第22章 图形化用户界面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%96%E5%8F%82%E7%9C%8B"><span class="toc-text">📖参看</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%BB%E5%8F%82%E8%80%83%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-text">※参考和引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%97%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5"><span class="toc-text">🔗外部链接</span></a></li></ol>
    </div>
</aside>
                
                
  <aside id="krw-categories" class="widget widget-kratos-categories clearfix">
    <h4 class="widget-title"><i class="fa fa-folder"></i>分类目录</h4>
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/HelloWorld/">HelloWorld🐣</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/InformationTechnology/">信息技术</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/InformationTechnology/Handbook/">手册</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">其他🗒</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Blog/">博客</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Handbook/">手册</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/DailyRecord/">日常记录</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">生命</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Knowledge/">知识</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Society/">社会</a><span class="category-list-count">30</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Society/InformationTechnology/">信息技术</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Society/ComputerScience/">计算机科学</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Society/ComputerScience/InformationTechnology/">信息技术</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/SiteRecord/">站点记录</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerEngineering/">计算机工程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/">计算机科学</a><span class="category-list-count">34</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/InformationTechnology/">信息技术</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ComputerScience/Handbook/">手册</a><span class="category-list-count">2</span></li></ul></li></ul>
  </aside>


            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/Git/" style="font-size: 0.76em;">Git</a> <a href="/tags/GitHub/" style="font-size: 0.6em;">GitHub</a> <a href="/tags/Github/" style="font-size: 0.72em;">Github</a> <a href="/tags/HelloWorld/" style="font-size: 0.68em;">HelloWorld🐣</a> <a href="/tags/Hexo/" style="font-size: 0.6em;">Hexo</a> <a href="/tags/Java/" style="font-size: 0.76em;">Java</a> <a href="/tags/Object-Relational-Mapping/" style="font-size: 0.64em;">ORM</a> <a href="/tags/Apache-Tomcat/" style="font-size: 0.6em;">Tomcat</a> <a href="/tags/%E3%80%8AThinking-in-Java%E3%80%8B/" style="font-size: 0.64em;">《Thinking in Java》</a> <a href="/tags/Spring-Framework/" style="font-size: 0.64em;">【Java】Spring Framework</a> <a href="/tags/bcrypt/" style="font-size: 0.6em;">【密码散列函数】bcrypt</a> <a href="/tags/Internet/" style="font-size: 0.72em;">互联网</a> <a href="/tags/Ethics/" style="font-size: 0.6em;">伦理</a> <a href="/tags/Tutorial/" style="font-size: 0.64em;">使用手册</a> <a href="/tags/Information-Technology/" style="font-size: 0.8em;">信息技术</a> <a href="/tags/Kernel-operating-system/" style="font-size: 0.6em;">内核（操作系统）</a> <a href="/tags/Functional-requirement/" style="font-size: 0.68em;">功能需求</a> <a href="/tags/Blog/" style="font-size: 0.68em;">博客</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/zh/post/%E3%80%90%E7%A4%BE%E4%BC%9A%E3%80%91%E3%80%90%E8%81%8C%E4%B8%9A%E3%80%91%E8%81%8C%E5%9C%BA%E8%AE%B0%E5%BD%95-%E6%9D%82%E5%BD%95/"><i class="fa  fa-book"></i> 【社会】【职业】职场记录-杂录</a>
            
          
        
          
          
            <a class="list-group-item" href="/zh/post/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Software-design-pattern/"><i class="fa  fa-book"></i> 软件设计模式(Software design pattern)</a>
            
          
        
          
          
            <a class="list-group-item" href="/zh/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%89/"><i class="fa  fa-book"></i> 设计模式（可复用面向对象软件的基础）</a>
            
          
        
          
          
            <a class="list-group-item" href="/zh/post/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-Architectural-pattern/"><i class="fa  fa-book"></i> 架构模式(Architectural pattern)</a>
            
          
        
          
          
            <a class="list-group-item" href="/zh/post/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-Scripting-language/"><i class="fa  fa-book"></i> 脚本语言(Scripting language)</a>
            
          
        
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://t.me/SuiteLHY"><i class="fa fa-telegram"></i></a></li>
                        
                        
                        
                        
                        <li><a target="_blank" rel="nofollow" href="https://github.com/SuiteLHY"><i class="fa fa-github"></i></a></li>
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2021 夜与花海 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by Suite.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>
<script>const notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));</script>

    <div>
        <canvas id="snow"></canvas>
        <script async type="text/javascript" src="/js/snow.min.js"></script>
    </div>

<script async src="/js/candy.min.js"></script>

    <script defer src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="900328786"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script>
<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>


    <script defer src="/js/kr-dark.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>